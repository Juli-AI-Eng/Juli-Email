This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: README.md, docs/A2A_HANDOFF.md, docs/APPROVAL_SYSTEM_GUIDE.md, docs/CLAUDE.md, docs/DOCKER_GUIDE.md, docs/MCP_DEVELOPER_GUIDE.md, docs/TOOLS_DOCUMENTATION.md, CLAUDE.md, CONTRIBUTING.md, Dockerfile, docker-compose.yml, package.json, .gitignore, specification/schemas/agent-card.schema.json, specification/schemas/credentials-manifest.schema.json, src/ai/emailAI.ts, src/server.ts, src/setup/setupManager.ts, src/tools/emailInsights.ts, src/tools/findEmails.ts, src/tools/manageEmail.ts, src/tools/organizeInbox.ts, src/tools/smartFolders.ts, src/types/index.ts, tests/e2e/a2a.test.ts, tests/e2e/config.ts, tests/e2e/fullRealApiJourney.test.ts, tests/e2e/onboardingFlow.test.ts, tests/e2e/run-e2e-tests.ts, tests/e2e/setup.test.ts, tests/e2e/setup.ts, tests/e2e/toolApprovals.test.ts, tests/e2e/utils/config.ts, tests/e2e/utils/httpClient.ts, tests/e2e/utils/testLogger.ts
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  A2A_HANDOFF.md
  APPROVAL_SYSTEM_GUIDE.md
  CLAUDE.md
  DOCKER_GUIDE.md
  MCP_DEVELOPER_GUIDE.md
  TOOLS_DOCUMENTATION.md
specification/
  schemas/
    agent-card.schema.json
    credentials-manifest.schema.json
src/
  ai/
    emailAI.ts
  setup/
    setupManager.ts
  tools/
    emailInsights.ts
    findEmails.ts
    manageEmail.ts
    organizeInbox.ts
    smartFolders.ts
  types/
    index.ts
  server.ts
tests/
  e2e/
    utils/
      config.ts
      httpClient.ts
      testLogger.ts
    a2a.test.ts
    config.ts
    fullRealApiJourney.test.ts
    onboardingFlow.test.ts
    run-e2e-tests.ts
    setup.test.ts
    setup.ts
    toolApprovals.test.ts
.gitignore
CLAUDE.md
CONTRIBUTING.md
docker-compose.yml
Dockerfile
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/A2A_HANDOFF.md">
# Juli Email A2A Integration Handoff

Audience: Juli Brain team

## Summary
- Use JSON-RPC A2A as the interface between Juli Brain and this agent.
- Keep connector model (server env: `NYLAS_API_KEY`, Brain injects `EMAIL_ACCOUNT_GRANT`).
- Authenticate Brain → Email using OIDC ID tokens; dev shared secret optional.

Reference: A2A protocol overview and goals are outlined here: https://github.com/a2aproject/A2A

## Discovery
- GET `/.well-known/a2a.json` → Agent Card with:
  - `agent_id`, `version`, `capabilities` (tools + JSON schemas)
  - `approvals.modes: ["stateless_preview_then_approve"]`
  - `auth`: single scheme or `{ schemes: [...] }`
  - `rpc: { endpoint: "/a2a/rpc" }`
  - `extensions.x-juli.credentials_manifest: "/.well-known/a2a-credentials.json"`

## Auth
- Production: Obtain Google OIDC ID token with audience = `A2A_AUDIENCE` (or server base URL). Send `Authorization: Bearer <id_token>`.
- Dev: send `X-A2A-Dev-Secret` when configured.

## Execute Flow (JSON-RPC)
- POST `/a2a/rpc` with:
```json
{ "jsonrpc":"2.0","id":"1","method":"tool.execute","params":{ "tool":"manage_email","arguments":{},"user_context":{"credentials":{"EMAIL_ACCOUNT_GRANT":"<uuid>"}},"request_id":"<uuid>" } }
```
- Responses:
  - Success: `{ "request_id": "...", "result": { ... } }`
  - Approval required: `{ "request_id": "...", "result": { "needs_approval": true, "action_type": "send_email", "action_data": { ... }, "preview": { ... } } }`
  - Error: `{ "request_id": "...", "error": "message" }`

## Approve Flow (JSON-RPC)
- POST `/a2a/rpc` with:
```json
{ "jsonrpc":"2.0","id":"2","method":"tool.approve","params":{ "tool":"manage_email","original_arguments":{},"action_data":{},"user_context":{"credentials":{"EMAIL_ACCOUNT_GRANT":"<uuid>"}},"request_id":"<uuid>" } }
```
- Response: `{ "request_id": "...", "result": { "success": true, "message_id": "..." } }`

## Required from Juli Brain
1) Agent auth
- Provision a Google service account able to mint OIDC ID tokens for audience = `A2A_AUDIENCE` (set to the Email base URL in env).
- Attach `Authorization: Bearer <id_token>` to all A2A requests.
- For local dev, support `X-A2A-Dev-Secret`.

2) Credential injection
- Keep storing `NYLAS_GRANT_ID` and include it in `user_context.credentials` on each A2A call.

3) Discovery
- On agent registration or periodically, read `/.well-known/a2a.json` to cache capabilities and input schemas.

4) Approval UX
- Handle `needs_approval` by surfacing preview and safeties; call `/a2a/approve` with the returned `action_data`.

5) Error handling & retries
- Respect 400/401/500 codes; retry idempotent calls; treat `request_id` as unique per call; prevent replay.

## Environment variables
- Server:
  - `NYLAS_API_KEY`, `NYLAS_CLIENT_ID`, `NYLAS_CALLBACK_URI`, `NYLAS_API_URI`
  - `A2A_AUDIENCE` (optional; defaults to server base URL)
  - `A2A_DEV_SHARED_SECRET` (dev only)
</file>

<file path="specification/schemas/agent-card.schema.json">
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "A2A Agent Card",
    "description": "Defines the capabilities, authentication, and connection information for an A2A-compliant agent.",
    "type": "object",
    "required": [
        "agent_id",
        "version",
        "auth",
        "capabilities",
        "rpc"
    ],
    "properties": {
        "agent_id": {
            "type": "string"
        },
        "version": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "auth": {
            "oneOf": [
                {
                    "$ref": "#/definitions/authScheme"
                },
                {
                    "type": "object",
                    "properties": {
                        "schemes": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/authScheme"
                            }
                        }
                    },
                    "required": [
                        "schemes"
                    ]
                }
            ]
        },
        "approvals": {
            "type": "object",
            "properties": {
                "modes": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "enum": [
                            "stateless_preview_then_approve"
                        ]
                    }
                }
            }
        },
        "context_requirements": {
            "type": "object",
            "properties": {
                "credentials": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "capabilities": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "input_schema": {
                        "type": "object"
                    }
                },
                "required": [
                    "name",
                    "description",
                    "input_schema"
                ]
            }
        },
        "rpc": {
            "type": "object",
            "properties": {
                "endpoint": {
                    "type": "string"
                }
            },
            "required": [
                "endpoint"
            ]
        },
        "extensions": {
            "type": "object"
        }
    },
    "definitions": {
        "authScheme": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string",
                    "enum": [
                        "oidc",
                        "shared_secret"
                    ]
                }
            },
            "required": [
                "type"
            ]
        }
    }
}
</file>

<file path="specification/schemas/credentials-manifest.schema.json">
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "A2A Credentials Manifest",
    "description": "Describes the credentials required by an agent and how a client can obtain them.",
    "type": "object",
    "required": [
        "credentials"
    ],
    "properties": {
        "credentials": {
            "type": "array",
            "items": {
                "type": "object",
                "required": [
                    "key",
                    "display_name",
                    "flows"
                ],
                "properties": {
                    "key": {
                        "type": "string"
                    },
                    "display_name": {
                        "type": "string"
                    },
                    "sensitive": {
                        "type": "boolean",
                        "default": true
                    },
                    "notes": {
                        "type": "string"
                    },
                    "flows": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "required": [
                                "type"
                            ],
                            "properties": {
                                "type": {
                                    "type": "string",
                                    "enum": [
                                        "hosted_auth"
                                    ]
                                },
                                "connect_url": {
                                    "type": "string"
                                },
                                "callback": {
                                    "type": "string"
                                },
                                "provider_scopes": {
                                    "type": "object"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="tests/e2e/a2a.test.ts">
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { HttpTestClient, startTestServer } from './utils/httpClient';
import { E2E_CONFIG } from './config';
import { logger } from './utils/testLogger';
import { hasNylasCredentials } from './utils/config';
const SKIP_REAL_API = !hasNylasCredentials() || !process.env.OPENAI_API_KEY;
const realApiSuite = SKIP_REAL_API ? describe.skip : describe;
describe('A2A JSON-RPC Endpoint', () => {
    let client: HttpTestClient;
    let server: { port: number; stop: () => Promise<void> };
    beforeAll(async () => {
        logger.logSection('A2A RPC TEST INITIALIZATION');
        process.env.A2A_DEV_SHARED_SECRET = process.env.A2A_DEV_SHARED_SECRET || 'test-secret';
        server = await startTestServer();
        client = new HttpTestClient({
            baseUrl: 'http://localhost',
            port: server.port,
            devAgentSecret: process.env.A2A_DEV_SHARED_SECRET,
            credentials: {
                nylasGrantId: (E2E_CONFIG as any).nylas?.nylasGrantId
            }
        });
        logger.logSuccess(`Test server started on port ${server.port}`);
    }, 60000);
    afterAll(async () => {
        if (server) await server.stop();
    });
    test('should fail without valid auth', async () => {
        const unauthedClient = new HttpTestClient({
            baseUrl: 'http://localhost',
            port: server.port,
            devAgentSecret: 'wrong-secret'
        });
        const response = await unauthedClient.callRpc('agent.card');
        expect(response.error).toBeDefined();
        expect(response.error.code).toBe(401);
        expect(response.error.message).toBe('unauthorized_agent');
    });
    test('should respond to agent.card', async () => {
        const response = await client.callRpc('agent.card');
        expect(response.error).toBeUndefined();
        expect(response.result).toBeDefined();
        expect(response.result.agent_id).toBe('inbox-mcp');
        expect(response.result.rpc.endpoint).toBe('/a2a/rpc');
        expect(Array.isArray(response.result.capabilities)).toBe(true);
    });
    realApiSuite('Tool RPCs', () => {
        test('should return missing_credentials without EMAIL_ACCOUNT_GRANT', async () => {
            const response = await client.callRpc('tool.execute', {
                tool: 'find_emails',
                arguments: { query: 'test' }
            });
            expect(response.error).toBeDefined();
            expect(response.error.code).toBe(401);
            expect(response.error.message).toMatch(/missing_credentials/);
        });
    });
});
</file>

<file path="docs/APPROVAL_SYSTEM_GUIDE.md">
# Juli Approval System Guide

Understanding how the approval system works between Juli and MCP servers for safe execution of sensitive actions.

## Overview

The approval system ensures users maintain control over potentially impactful actions. When an MCP server needs user confirmation before proceeding, it returns a special response that Juli intercepts and handles with a native UI.

## How It Works

### Flow Diagram

```
User Request → MCP Server → Needs Approval? → Return Approval Request
                                ↓                        ↓
                              No                    Juli Shows UI
                                ↓                        ↓
                          Execute Action            User Decides
                                                         ↓
                                                   Approve/Deny
                                                         ↓
                                                  Retry with Decision
```

### The Stateless Approval Protocol

**Key Principle**: MCP servers don't store pending approvals. Instead, they return all data needed to execute the action, and Juli handles the approval UI and retry.

## Implementation

### 1. When to Require Approval

```typescript
function needsApproval(action: any): boolean {
  // Require approval for:
  // - Sending emails
  // - Deleting data
  // - Bulk operations
  // - Financial transactions
  // - Any irreversible actions
  
  return action.type === 'send' || 
         action.bulk_count > 10 ||
         action.involves_money ||
         action.is_destructive;
}
```

### 2. Approval Response Format

```typescript
interface ApprovalRequiredResponse {
  needs_approval: true;
  action_type: string;        // Type of action requiring approval
  action_data: any;          // Complete data needed to execute
  preview: {
    summary: string;         // One-line summary
    details: any;           // Detailed preview info
    risks?: string[];       // Optional warnings
  };
  suggested_modifications?: any;  // Optional suggestions
}
```

### 3. Real Example: Email Approval

```typescript
// User says: "reply to Sarah about the meeting"
async function handleManageEmail(params: any) {
  // AI generates the email
  const emailContent = await generateEmail(params.query);
  
  // Check if approval needed
  if (params.action === 'send' && !params.approved) {
    return {
      needs_approval: true,
      action_type: 'send_email',
      action_data: {
        email_content: {
          to: ['sarah@company.com'],
          subject: 'Re: Tomorrow\'s Meeting',
          body: 'Hi Sarah,\n\nThank you for...',
          thread_id: 'thread_123'
        },
        original_params: params
      },
      preview: {
        summary: 'Send email to sarah@company.com',
        details: {
          recipient: 'Sarah Johnson',
          subject: 'Re: Tomorrow\'s Meeting',
          word_count: 127,
          has_attachments: false
        }
      }
    };
  }
  
  // If approved, execute
  if (params.approved && params.action_data) {
    const result = await sendEmail(params.action_data.email_content);
    return {
      success: true,
      message: 'Email sent successfully',
      message_id: result.id
    };
  }
}
```

### 4. Bulk Operations Example

```typescript
// User says: "archive all newsletters older than a month"
async function handleOrganizeInbox(params: any) {
  // Find matching emails
  const emails = await findEmails({
    category: 'newsletter',
    older_than: '1 month'
  });
  
  // Require approval for bulk operations
  if (!params.confirmed) {
    return {
      needs_approval: true,
      action_type: 'bulk_archive',
      action_data: {
        email_ids: emails.map(e => e.id),
        operation: 'archive',
        filter_used: params.instruction
      },
      preview: {
        summary: `Archive ${emails.length} newsletters`,
        details: {
          count: emails.length,
          oldest_email: emails[0]?.date,
          newest_email: emails[emails.length-1]?.date,
          sample_subjects: emails.slice(0, 3).map(e => e.subject)
        },
        risks: emails.length > 100 ? 
          ['This will archive a large number of emails'] : 
          undefined
      }
    };
  }
  
  // Execute if confirmed
  if (params.confirmed && params.action_data) {
    await archiveEmails(params.action_data.email_ids);
    return {
      success: true,
      message: `Archived ${params.action_data.email_ids.length} emails`
    };
  }
}
```

## What Juli Handles

### 1. Approval UI

When Juli receives a `needs_approval` response, it:

```typescript
// Juli's internal handling
if (response.needs_approval) {
  // Show native approval dialog
  const userDecision = await showApprovalDialog({
    title: response.action_type,
    summary: response.preview.summary,
    details: response.preview.details,
    risks: response.preview.risks
  });
  
  if (userDecision.approved) {
    // Retry with approval
    const finalResponse = await callMCPTool(toolName, {
      ...originalParams,
      approved: true,
      action_data: response.action_data
    });
    return finalResponse;
  } else {
    // User denied
    return {
      cancelled: true,
      message: 'Action cancelled by user'
    };
  }
}
```

### 2. Approval UI Components

Juli renders a beautiful approval dialog with:
- Clear action summary
- Detailed preview (formatted based on action type)
- Risk warnings in red
- Approve/Deny buttons
- Optional "Modify" button for editable actions

### 3. Modification Flow

For editable actions (like emails), users can modify before approving:

```typescript
// MCP returns suggested modifications
{
  needs_approval: true,
  action_type: 'send_email',
  action_data: { ... },
  preview: { ... },
  suggested_modifications: {
    editable_fields: ['body', 'subject'],
    constraints: {
      body: { max_length: 10000 },
      subject: { max_length: 200 }
    }
  }
}

// Juli allows editing these fields in the approval dialog
```

## Best Practices

### 1. Clear Preview Information

```typescript
// ✅ Good: Specific and actionable
preview: {
  summary: 'Send email to 3 team members about project update',
  details: {
    recipients: ['john@company.com', 'sarah@company.com', 'mike@company.com'],
    subject: 'Project Alpha: Status Update',
    mentions_deadline: true,
    attachments: 0
  }
}

// ❌ Bad: Vague
preview: {
  summary: 'Send email',
  details: { count: 3 }
}
```

### 2. Appropriate Risk Warnings

```typescript
risks: [
  // Only include real risks
  'This will permanently delete 42 records',
  'Email will be sent to all 1,847 subscribers',
  'This action cannot be undone'
]

// Don't include non-risks like:
// 'This will send an email' (obvious from action)
// 'Please review before approving' (redundant)
```

### 3. Granular Approval Control

```typescript
// Allow users to control approval preferences
interface ToolParams {
  require_approval?: boolean;  // Override default
  auto_approve_threshold?: number;  // For bulk operations
}

// Example: Don't require approval for small operations
if (emails.length <= 5 && !params.require_approval) {
  // Execute without approval
}
```

### 4. Stateless Design

```typescript
// ✅ Good: Return all data needed
return {
  needs_approval: true,
  action_data: {
    email_content: fullEmailObject,
    thread_id: threadId,
    references: messageReferences
  }
};

// ❌ Bad: Storing state
const approvalId = generateId();
pendingApprovals.set(approvalId, emailData);
return {
  needs_approval: true,
  approval_id: approvalId  // Don't do this!
};
```

## Common Approval Scenarios

### 1. Communication Actions
- Sending emails
- Posting to social media
- Sending messages
- Making phone calls

### 2. Data Modifications
- Deleting records
- Bulk updates
- Archiving content
- Modifying sensitive data

### 3. Financial Operations
- Processing payments
- Issuing refunds
- Changing billing
- Subscription modifications

### 4. System Changes
- Deploying code
- Changing configurations
- Updating permissions
- Modifying integrations

## Testing Approvals

```typescript
describe('Approval Flow', () => {
  it('should require approval for sending emails', async () => {
    const response = await mcp.handleTool('manage_email', {
      action: 'send',
      query: 'email John about the meeting'
    });
    
    expect(response.needs_approval).toBe(true);
    expect(response.action_type).toBe('send_email');
    expect(response.action_data).toHaveProperty('email_content');
    expect(response.preview.summary).toContain('Send email');
  });
  
  it('should execute when approved', async () => {
    const approvalResponse = await mcp.handleTool('manage_email', {
      action: 'send',
      query: 'email John about the meeting'
    });
    
    const finalResponse = await mcp.handleTool('manage_email', {
      ...approvalResponse.action_data.original_params,
      approved: true,
      action_data: approvalResponse.action_data
    });
    
    expect(finalResponse.success).toBe(true);
    expect(finalResponse.message).toContain('sent');
  });
});
```

## Security Considerations

### 1. Action Data Validation

Always re-validate action data when executing approved actions:

```typescript
if (params.approved && params.action_data) {
  // Re-validate the action data
  if (!isValidEmailContent(params.action_data.email_content)) {
    return {
      error: 'Invalid email content in approval data'
    };
  }
  
  // Verify it matches what would be generated
  const expectedContent = await generateEmail(params.action_data.original_params);
  if (!contentMatches(expectedContent, params.action_data.email_content)) {
    return {
      error: 'Approval data does not match expected content'
    };
  }
}
```

### 2. Prevent Approval Bypass

```typescript
// Always check approval status for sensitive actions
if (action.type === 'send' && !params.approved) {
  // Force approval flow
  return { needs_approval: true, ... };
}

// Don't allow approval flag without action_data
if (params.approved && !params.action_data) {
  return {
    error: 'Approved flag requires action_data'
  };
}
```

## Summary

The Juli approval system provides:

1. **User Control** - Users always have final say on sensitive actions
2. **Transparency** - Clear previews of what will happen
3. **Flexibility** - Developers decide what needs approval
4. **Simplicity** - Stateless design makes implementation easy
5. **Security** - No way to bypass user approval for sensitive actions

By following this guide, your MCP server will integrate seamlessly with Juli's approval system, giving users confidence to use powerful tools while maintaining control over their data and actions.
</file>

<file path="docs/DOCKER_GUIDE.md">
# Docker Deployment Guide for Inbox MCP

This guide explains how to run Inbox MCP using Docker for easy deployment and scaling.

## Table of Contents
- [Prerequisites](#prerequisites)
- [Quick Start](#quick-start)
- [Building the Docker Image](#building-the-docker-image)
- [Running with Docker](#running-with-docker)
- [Using Docker Compose](#using-docker-compose)
- [Configuration](#configuration)
- [Production Deployment](#production-deployment)
- [Troubleshooting](#troubleshooting)

## Prerequisites

- Docker Engine 20.10+ installed
- Docker Compose 2.0+ (optional, for easier management)
- OpenAI API key

## Quick Start

1. Clone the repository:
```bash
git clone https://github.com/yourusername/inbox-mcp.git
cd inbox-mcp
```

2. Create a `.env` file:
```bash
cp .env.example .env
# Edit .env and add your OpenAI API key
```

3. Run with Docker Compose:
```bash
docker-compose up -d
```

The server will be available at `http://localhost:3000`

## Building the Docker Image

### Build locally:
```bash
docker build -t inbox-mcp:latest .
```

### Build with specific version tag:
```bash
docker build -t inbox-mcp:v1.0.0 .
```

### Multi-platform build (for ARM64 and AMD64):
```bash
docker buildx build --platform linux/amd64,linux/arm64 -t inbox-mcp:latest .
```

## Running with Docker

### Basic run:
```bash
docker run -d \
  --name inbox-mcp \
  -p 3000:3000 \
  -e OPENAI_API_KEY="your_openai_key_here" \
  inbox-mcp:latest
```

### Run with environment file:
```bash
docker run -d \
  --name inbox-mcp \
  -p 3000:3000 \
  --env-file .env \
  inbox-mcp:latest
```

### Run with custom port:
```bash
docker run -d \
  --name inbox-mcp \
  -p 8080:3000 \
  -e PORT=3000 \
  -e OPENAI_API_KEY="your_openai_key_here" \
  inbox-mcp:latest
```

### Run with volume for logs (if needed):
```bash
docker run -d \
  --name inbox-mcp \
  -p 3000:3000 \
  -v $(pwd)/logs:/app/logs \
  --env-file .env \
  inbox-mcp:latest
```

## Using Docker Compose

### Start the service:
```bash
docker-compose up -d
```

### View logs:
```bash
docker-compose logs -f
```

### Stop the service:
```bash
docker-compose down
```

### Rebuild and restart:
```bash
docker-compose up -d --build
```

### Scale the service (for load balancing):
```bash
docker-compose up -d --scale inbox-mcp=3
```

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `OPENAI_API_KEY` | Your OpenAI API key (required) | - |
| `PORT` | Port the server listens on | 3000 |
| `NODE_ENV` | Environment (development/production) | production |

### Docker Compose Configuration

The `docker-compose.yml` file includes:
- Automatic container restart
- Health checks
- Log rotation
- Resource limits (can be added)

### Adding Resource Limits

Update `docker-compose.yml` to add resource constraints:

```yaml
services:
  inbox-mcp:
    # ... other configuration ...
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
```

## Production Deployment

### 1. Use a Reverse Proxy

Add Nginx configuration for HTTPS and load balancing:

```nginx
upstream inbox_mcp {
    server inbox-mcp:3000;
}

server {
    listen 80;
    server_name api.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.yourdomain.com;
    
    ssl_certificate /etc/nginx/certs/cert.pem;
    ssl_certificate_key /etc/nginx/certs/key.pem;
    
    location / {
        proxy_pass http://inbox_mcp;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 2. Use Docker Secrets for API Keys

Instead of environment variables, use Docker secrets:

```bash
# Create secret
echo "your_openai_key" | docker secret create openai_api_key -

# Update docker-compose.yml
services:
  inbox-mcp:
    secrets:
      - openai_api_key
    environment:
      - OPENAI_API_KEY_FILE=/run/secrets/openai_api_key

secrets:
  openai_api_key:
    external: true
```

### 3. Enable Monitoring

Add Prometheus metrics endpoint or use Docker's built-in monitoring:

```bash
docker stats inbox-mcp
```

### 4. Set Up Logging

Configure centralized logging with ELK stack or CloudWatch:

```yaml
services:
  inbox-mcp:
    logging:
      driver: "awslogs"
      options:
        awslogs-group: "inbox-mcp"
        awslogs-region: "us-east-1"
        awslogs-stream-prefix: "server"
```

## Troubleshooting

### Check container status:
```bash
docker ps -a | grep inbox-mcp
```

### View container logs:
```bash
docker logs inbox-mcp
```

### Access container shell:
```bash
docker exec -it inbox-mcp sh
```

### Test health endpoint:
```bash
curl http://localhost:3000/health
```

### Common Issues

1. **Container exits immediately**
   - Check logs: `docker logs inbox-mcp`
   - Verify environment variables are set correctly
   - Ensure OpenAI API key is valid

2. **Cannot connect to server**
   - Verify port mapping: `docker port inbox-mcp`
   - Check firewall rules
   - Ensure container is running: `docker ps`

3. **Permission denied errors**
   - The container runs as non-root user (nodejs)
   - Ensure mounted volumes have correct permissions

4. **High memory usage**
   - Add resource limits in docker-compose.yml
   - Monitor with `docker stats`

### Debugging Build Issues

```bash
# Build with no cache
docker build --no-cache -t inbox-mcp:latest .

# Build with verbose output
docker build --progress=plain -t inbox-mcp:latest .

# Check image layers
docker history inbox-mcp:latest
```

## Security Best Practices

1. **Run as non-root user** (already configured)
2. **Use secrets management** for sensitive data
3. **Enable security scanning**:
   ```bash
   docker scan inbox-mcp:latest
   ```
4. **Keep base images updated**:
   ```bash
   docker pull node:20-alpine
   docker build --pull -t inbox-mcp:latest .
   ```
5. **Use read-only filesystem** where possible:
   ```yaml
   services:
     inbox-mcp:
       read_only: true
       tmpfs:
         - /tmp
   ```

## Backup and Recovery

### Backup configuration:
```bash
# Backup environment configuration
cp .env .env.backup

# Export container configuration
docker inspect inbox-mcp > inbox-mcp-config.json
```

### Restore from backup:
```bash
# Restore environment
cp .env.backup .env

# Recreate container with same configuration
docker-compose up -d
```

## Integration with CI/CD

### GitHub Actions example:
```yaml
name: Build and Push Docker Image

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: yourusername/inbox-mcp:latest
          platforms: linux/amd64,linux/arm64
```

## Performance Optimization

1. **Use multi-stage builds** (already implemented)
2. **Enable BuildKit** for faster builds:
   ```bash
   DOCKER_BUILDKIT=1 docker build -t inbox-mcp:latest .
   ```
3. **Cache npm dependencies** (already optimized in Dockerfile)
4. **Use Alpine Linux** for smaller image size (already used)

## Monitoring and Observability

### Add health check endpoint monitoring:
```bash
# Simple monitoring script
while true; do
  if ! curl -f http://localhost:3000/health > /dev/null 2>&1; then
    echo "Health check failed at $(date)"
    # Send alert or restart container
  fi
  sleep 30
done
```

### Container metrics:
```bash
# Real-time stats
docker stats inbox-mcp

# Export metrics to file
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" > metrics.txt
```

## Conclusion

Docker provides a consistent and scalable way to deploy Inbox MCP. This guide covers basic usage through production deployment strategies. For additional help, refer to the main README or open an issue on GitHub.
</file>

<file path="src/setup/setupManager.ts">
import Nylas from 'nylas';
import { SetupResponse, SetupInstruction } from '../types/index.js';
export class SetupManager {
  async handleSetup(params: any): Promise<SetupResponse> {
    const { action, credentials } = params;
    switch (action) {
      case 'get_instructions':
        return this.getInstructions();
      case 'validate_credentials':
        if (!credentials) {
          return {
            type: 'validation_error',
            message: 'No credentials provided',
            missing_fields: ['credentials']
          };
        }
        return this.validateCredentials(credentials);
      case 'test_connection':
        // In HTTP mode, this is typically called after credentials are stored
        return {
          type: 'setup_success',
          message: 'Connection test feature coming soon. Please validate credentials first.'
        };
      case 'troubleshoot':
        return this.troubleshoot(params.issue || 'general issue');
      default:
        return {
          type: 'setup_error',
          message: `Unknown setup action: ${action}`
        };
    }
  }
  async getInstructions(): Promise<SetupResponse> {
    return {
      type: 'setup_instructions',
      title: 'Email Setup Guide',
      estimated_time: '5 minutes',
      steps: [
        {
          step: 1,
          title: 'Create Your Free Nylas Account',
          description: 'Nylas provides 5 free email connections - perfect for personal use!',
          actions: [
            {
              type: 'link',
              label: 'Open Nylas Signup',
              url: 'https://dashboard-v3.nylas.com/register?utm_source=juli',
            }
          ],
          tips: [
            'Use the same email you\'ll be connecting later',
            'No credit card required for free tier'
          ]
        },
        {
          step: 2,
          title: 'Get Your API Key',
          description: 'After signing in, find your API key in the dashboard',
          actions: [
            {
              type: 'copy_field',
              label: 'I\'ll paste my API key here',
              field: 'nylas_api_key',
              validation: 'regex:^nyk_[a-zA-Z0-9]+$'
            }
          ],
          tips: [
            'API key starts with \'nyk_\'',
            'Keep this key secret - it\'s like a password!'
          ]
        },
        {
          step: 3,
          title: 'Connect Your Email Account',
          description: 'Add your email account to Nylas',
          substeps: [
            'Click \'Grants\' in the sidebar',
            'Click \'Add Test Grant\' button (top right)',
            'Choose your email provider (Gmail, Outlook, etc)',
            'Authorize Nylas to access your email',
            'Copy the Grant ID that appears'
          ],
          actions: [
            {
              type: 'copy_field',
              label: 'I\'ll paste my Grant ID here',
              field: 'nylas_grant_id',
              validation: 'regex:^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
            }
          ],
          common_issues: [
            {
              issue: 'Can\'t find Grant ID',
              solution: 'It\'s in the table under the \'ID\' column after you connect'
            },
            {
              issue: 'Authorization failed',
              solution: 'Make sure to allow all requested permissions'
            }
          ]
        }
      ],
      next_step: {
        description: 'Once you have both credentials, validate them through Juli',
        command: 'setup_email_connection',
        parameters: {
          action: 'validate_credentials',
          credentials: {
            nylas_api_key: 'your_key_here',
            nylas_grant_id: 'your_grant_id_here'
          }
        }
      }
    };
  }
  async validateCredentials(
    credentials: any
  ): Promise<SetupResponse> {
    // Debug logging
    console.log('Validating credentials:', {
      hasApiKey: !!credentials?.nylas_api_key,
      apiKeyPrefix: credentials?.nylas_api_key?.substring(0, 10) + '...',
      grantId: credentials?.nylas_grant_id
    });
    // Check for missing credentials
    if (!credentials?.nylas_api_key || !credentials?.nylas_grant_id) {
      return {
        type: 'validation_error',
        message: 'Both API key and Grant ID are required',
        missing_fields: [
          !credentials?.nylas_api_key && 'nylas_api_key',
          !credentials?.nylas_grant_id && 'nylas_grant_id'
        ].filter(Boolean) as string[]
      };
    }
    // Validate API key format
    if (!credentials.nylas_api_key.startsWith('nyk_')) {
      return {
        type: 'validation_error',
        message: 'API key should start with \'nyk_\'',
      };
    }
    // Validate Grant ID format (UUID)
    const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    if (!uuidRegex.test(credentials.nylas_grant_id)) {
      return {
        type: 'validation_error',
        message: 'Grant ID should be a valid UUID',
      };
    }
    try {
      // Test the credentials
      console.log('Creating Nylas client with API key:', credentials.nylas_api_key.substring(0, 20) + '...');
      const testClient = new Nylas({ apiKey: credentials.nylas_api_key });
      // Try to fetch grant info to verify
      console.log('Fetching grant:', credentials.nylas_grant_id);
      const grant = await testClient.grants.find({
        grantId: credentials.nylas_grant_id
      });
      // Get email address for confirmation
      const emailAddress = grant.data.email || 'your email';
      return {
        type: 'setup_success',
        message: `Successfully connected ${emailAddress}!`,
        credentials_validated: true,
        credentials_to_store: {
          nylas_api_key: credentials.nylas_api_key,
          nylas_grant_id: credentials.nylas_grant_id,
          email_address: emailAddress,
          provider: grant.data.provider
        }
      };
    } catch (error: any) {
      // Log the full error for debugging
      console.error('Nylas validation error:', {
        statusCode: error.statusCode,
        message: error.message,
        type: error.type,
        providerError: error.provider_error,
        requestId: error.request_id,
        fullError: error
      });
      // Handle different error types
      if (error.statusCode === 401) {
        return {
          type: 'setup_error',
          message: 'Invalid API key',
          error_details: 'Double-check your API key from the Nylas dashboard'
        };
      } else if (error.statusCode === 404) {
        return {
          type: 'setup_error',
          message: 'Grant ID not found',
          error_details: 'Make sure you completed the \'Add Test Grant\' step'
        };
      } else {
        return {
          type: 'setup_error',
          message: 'Could not connect to Nylas',
          error_details: error.message
        };
      }
    }
  }
  async troubleshoot(issue: string): Promise<SetupResponse> {
    const lowerIssue = issue.toLowerCase();
    // Check for permission issues
    if (lowerIssue.includes('permission') || lowerIssue.includes('denied') || lowerIssue.includes('access')) {
      return {
        type: 'setup_instructions',
        title: 'Permission Issue Resolution',
        estimated_time: '2 minutes',
        steps: [
          {
            step: 1,
            title: 'Re-authorize Your Email',
            description: 'Re-authorize your email in Nylas dashboard with all permissions enabled',
            substeps: [
              'Go to Nylas dashboard',
              'Find your grant in the Grants section',
              'Delete the existing grant',
              'Create a new test grant',
              'Make sure to allow ALL requested permissions'
            ]
          }
        ]
      };
    }
    // Check for expired grant
    if (lowerIssue.includes('expired') || lowerIssue.includes('invalid grant')) {
      return {
        type: 'setup_instructions',
        title: 'Grant Expired - Create New Grant',
        estimated_time: '3 minutes',
        steps: [
          {
            step: 1,
            title: 'Create a New Test Grant',
            description: 'Test grants expire after 30 days. Let\'s create a fresh one.',
            substeps: [
              'Go to Nylas dashboard',
              'Navigate to Grants section',
              'Click \'Add Test Grant\'',
              'Re-authorize your email',
              'Copy the new Grant ID'
            ]
          }
        ]
      };
    }
    // Generic troubleshooting
    return {
      type: 'setup_instructions',
      title: 'General Troubleshooting',
      estimated_time: '5 minutes',
      steps: [
        {
          step: 1,
          title: 'Verify Your Nylas Account',
          description: 'Make sure your Nylas account is active'
        },
        {
          step: 2,
          title: 'Check API Key Validity',
          description: 'Ensure your API key is still valid and not regenerated'
        },
        {
          step: 3,
          title: 'Verify Email Grant',
          description: 'Check if your email grant hasn\'t expired (30 days for test grants)'
        },
        {
          step: 4,
          title: 'Try Creating Fresh Credentials',
          description: 'Sometimes starting fresh with new grant helps'
        }
      ]
    };
  }
}
</file>

<file path="src/tools/emailInsights.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { 
  EmailInsightsParams, 
  Email, 
  EmailAnalysis,
  ActionItem
} from '../types';
export class EmailInsightsTool {
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: EmailInsightsParams): Promise<any> {
    try {
      // Use AI to understand what kind of insight the user wants
      const intent = await this.emailAI.understandInsightsQuery(params.query);
      // Execute the appropriate insight generation based on AI understanding
      switch (intent.insight_type) {
        case 'daily_summary':
          return this.generateDailySummary();
        case 'weekly_summary':
          return this.generateWeeklySummary();
        case 'important_items':
          return this.findImportantItems();
        case 'response_needed':
          return this.findResponseNeeded();
        case 'analytics':
          return this.generateAnalytics(intent.time_period || params.time_period || 'week');
        case 'relationships':
          return this.analyzeRelationships();
        default:
          // This shouldn't happen with proper AI understanding, but fallback to daily summary
          return this.generateDailySummary();
      }
    } catch (error: any) {
      throw new Error(`Failed to generate insights: ${error.message}`);
    }
  }
  private async generateDailySummary(): Promise<any> {
    // Get emails from today
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);
    const startTimestamp = Math.floor(todayStart.getTime() / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: startTimestamp,
        limit: 100
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: "No emails received today. Your inbox is clear!",
        insights: {
          total_emails: 0,
          suggestions: ["Great time to focus on deep work", "Check your sent items if expecting replies"]
        }
      };
    }
    // Analyze importance
    let analysis: EmailAnalysis[] = [];
    try {
      if (emails.length > 0) {
        analysis = await this.emailAI.analyzeEmailImportance(emails);
      }
    } catch (error) {
      console.error('AI analysis failed:', error);
    }
    const unreadCount = emails.filter(e => e.unread).length;
    const importantEmails = analysis.filter(a => a.importance_score > 0.8);
    // Group by category
    const categories: Record<string, number> = {};
    analysis.forEach(a => {
      categories[a.category] = (categories[a.category] || 0) + 1;
    });
    // Generate AI-powered insights about the day's emails
    try {
      const insights = await this.emailAI.generateDailyInsights(emails, analysis);
      return {
        summary: insights.executive_summary,
        insights: {
          total_emails: emails.length,
          unread_count: unreadCount,
          key_highlights: insights.key_highlights,
          action_priorities: insights.action_priorities,
          communication_patterns: insights.patterns,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories,
          recommendations: insights.recommendations
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      const summary = `You received ${emails.length} emails today (${unreadCount} unread). ` +
        `${importantEmails.length} are marked as important. ` +
        `Categories: ${Object.entries(categories).map(([cat, count]) => `${cat}: ${count}`).join(', ')}.`;
      return {
        summary,
        insights: {
          total_emails: emails.length,
          unread_count: unreadCount,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories
        }
      };
    }
  }
  private async generateWeeklySummary(): Promise<any> {
    // Get emails from the past week
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    weekAgo.setHours(0, 0, 0, 0);
    const startTimestamp = Math.floor(weekAgo.getTime() / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: startTimestamp,
        limit: 500
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: "No emails received this week. Enjoy the peace and quiet!",
        insights: {
          total_emails: 0,
          suggestions: ["Perfect time for strategic planning", "Consider reaching out to important contacts"]
        }
      };
    }
    // Analyze importance
    let analysis: EmailAnalysis[] = [];
    try {
      if (emails.length > 0) {
        // Analyze a sample for performance reasons
        const sampleSize = Math.min(emails.length, 100);
        const emailSample = emails.slice(0, sampleSize);
        analysis = await this.emailAI.analyzeEmailImportance(emailSample);
      }
    } catch (error) {
      console.error('AI analysis failed:', error);
    }
    // Group by day for trend analysis
    const emailsByDay: Record<string, Email[]> = {};
    emails.forEach(email => {
      const date = new Date(email.date * 1000);
      const dayKey = date.toLocaleDateString();
      if (!emailsByDay[dayKey]) {
        emailsByDay[dayKey] = [];
      }
      emailsByDay[dayKey].push(email);
    });
    const unreadCount = emails.filter(e => e.unread).length;
    const importantEmails = analysis.filter(a => a.importance_score > 0.8);
    // Group by category
    const categories: Record<string, number> = {};
    analysis.forEach(a => {
      categories[a.category] = (categories[a.category] || 0) + 1;
    });
    // Generate AI-powered weekly insights
    try {
      const insights = await this.emailAI.generateWeeklyInsights(emails, analysis, emailsByDay);
      return {
        summary: insights.executive_summary,
        insights: {
          total_emails: emails.length,
          daily_average: Math.round(emails.length / 7),
          unread_count: unreadCount,
          week_over_week_trend: insights.week_trend,
          key_themes: insights.key_themes,
          productivity_insights: insights.productivity_insights,
          important_conversations: insights.important_conversations,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories,
          recommendations: insights.recommendations
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      const summary = `You received ${emails.length} emails this week (avg ${Math.round(emails.length / 7)}/day, ${unreadCount} unread). ` +
        `${importantEmails.length} are marked as important. ` +
        `Categories: ${Object.entries(categories).map(([cat, count]) => `${cat}: ${count}`).join(', ')}.`;
      return {
        summary,
        insights: {
          total_emails: emails.length,
          daily_average: Math.round(emails.length / 7),
          unread_count: unreadCount,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories
        }
      };
    }
  }
  private async findImportantItems(): Promise<any> {
    // Get recent unread emails
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        unread: true,
        limit: 50
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: 'No unread emails to analyze.',
        insights: {
          important_emails: [],
          action_items: []
        }
      };
    }
    // Analyze importance
    let analysis: EmailAnalysis[] = [];
    try {
      analysis = await this.emailAI.analyzeEmailImportance(emails);
    } catch (error) {
      console.error('AI analysis failed:', error);
      return {
        summary: 'Unable to analyze email importance at this time.',
        insights: {
          total_emails: emails.length,
          important_emails: []
        }
      };
    }
    // Generate AI-powered insights about important items
    try {
      const insights = await this.emailAI.generateImportantItemsInsights(emails, analysis);
      // Extract action items from important emails
      const actionItems: ActionItem[] = [];
      const importantAnalysis = analysis.filter(a => a.importance_score > 0.8);
      for (const a of importantAnalysis) {
        const email = emails.find(e => e.id === a.email_id);
        if (email && a.action_required) {
          try {
            const items = await this.emailAI.extractActionItems(email);
            actionItems.push(...items);
          } catch (error) {
            console.error('Failed to extract action items:', error);
          }
        }
      }
      return {
        summary: insights.executive_summary,
        insights: {
          priority_items: insights.priority_items,
          action_plan: insights.action_plan,
          key_deadlines: insights.key_deadlines,
          action_items: actionItems,
          total_analyzed: emails.length
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      const importantEmails = analysis
        .filter(a => a.importance_score > 0.8)
        .map(a => {
          const email = emails.find(e => e.id === a.email_id);
          return {
            id: a.email_id,
            subject: email?.subject,
            from: email?.from[0]?.email,
            reason: a.reason,
            action_required: a.action_required
          };
        });
      return {
        summary: `Found ${importantEmails.length} important emails that require attention.`,
        insights: {
          important_emails: importantEmails,
          action_items: []
        }
      };
    }
  }
  private async findResponseNeeded(): Promise<any> {
    // Get recent emails that might need responses
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        limit: 50
      }
    });
    const emails = messages.data as Email[];
    // Filter emails that likely need responses
    const needsResponse: Email[] = [];
    for (const email of emails) {
      // Skip if from self or automated emails
      if (email.from[0]?.email?.includes('noreply') || 
          email.from[0]?.email?.includes('notification')) {
        continue;
      }
      // Check if email has been replied to
      if (email.thread_id) {
        try {
          const thread = await this.nylas.threads.find({
            identifier: this.grantId,
            threadId: email.thread_id
          });
          // If thread has only one message, it hasn't been replied to
          if (thread.data.messageIds && thread.data.messageIds.length === 1) {
            needsResponse.push(email);
          }
        } catch (error) {
          console.error('Failed to check thread:', error);
        }
      }
    }
    if (needsResponse.length === 0) {
      return {
        summary: 'No emails currently need responses.',
        insights: {
          response_priorities: [],
          response_strategy: [],
          time_estimate: '0 minutes'
        }
      };
    }
    // Generate AI-powered insights about response needs
    try {
      const insights = await this.emailAI.generateResponseNeededInsights(emails, needsResponse);
      return {
        summary: insights.executive_summary,
        insights: {
          response_priorities: insights.response_priorities,
          response_strategy: insights.response_strategy,
          time_estimate: insights.time_estimate,
          total_needing_response: needsResponse.length
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      let analysis: EmailAnalysis[] = [];
      if (needsResponse.length > 0) {
        try {
          analysis = await this.emailAI.analyzeEmailImportance(needsResponse);
        } catch (error) {
          console.error('AI analysis failed:', error);
        }
      }
      const responseEmails = needsResponse.map(email => {
        const a = analysis.find(an => an.email_id === email.id);
        return {
          id: email.id,
          subject: email.subject,
          from: email.from[0]?.email,
          importance_score: a?.importance_score || 0.5,
          reason: a?.reason || 'Needs response'
        };
      }).sort((a, b) => b.importance_score - a.importance_score);
      const summary = `${responseEmails.length} emails need responses. ` +
        `${responseEmails.filter(e => e.importance_score > 0.7).length} are high priority.`;
      return {
        summary,
        insights: {
          needs_response: responseEmails
        }
      };
    }
  }
  private async generateAnalytics(timePeriod: string): Promise<any> {
    // Calculate date range
    const now = new Date();
    let daysAgo = 7;
    switch (timePeriod) {
      case 'day':
        daysAgo = 1;
        break;
      case 'week':
        daysAgo = 7;
        break;
      case 'month':
        daysAgo = 30;
        break;
    }
    const startDate = new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
    const startTimestamp = Math.floor(startDate.getTime() / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: startTimestamp,
        limit: 500
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: `No emails found for the past ${timePeriod}.`,
        insights: {
          volume_analysis: {
            trend: 'No activity',
            pattern: 'No emails',
            anomalies: []
          }
        }
      };
    }
    // Calculate analytics
    const senderCounts = new Map<string, number>();
    emails.forEach(email => {
      const sender = email.from[0]?.email;
      if (sender) {
        senderCounts.set(sender, (senderCounts.get(sender) || 0) + 1);
      }
    });
    // Categorize emails
    let categories: Record<string, number> = {};
    try {
      const categoryMap = await this.emailAI.categorizeEmails(emails.slice(0, 100));
      categoryMap.forEach((emailIds, category) => {
        categories[category] = emailIds.length;
      });
    } catch (error) {
      console.error('Categorization failed:', error);
    }
    // Generate AI-powered analytics insights
    try {
      const insights = await this.emailAI.generateAnalyticsInsights(
        emails,
        timePeriod,
        senderCounts,
        categories
      );
      return {
        summary: insights.executive_summary,
        insights: {
          volume_analysis: insights.volume_analysis,
          sender_insights: insights.sender_insights,
          productivity_metrics: insights.productivity_metrics,
          recommendations: insights.recommendations,
          raw_analytics: {
            total_emails: emails.length,
            emails_per_day: emails.length / daysAgo,
            unread_count: emails.filter(e => e.unread).length
          }
        }
      };
    } catch (error) {
      console.error('AI analytics generation failed:', error);
      // Fallback to basic analytics
      const topSenders = Array.from(senderCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([sender]) => sender);
      const analytics = {
        total_emails: emails.length,
        emails_per_day: emails.length / daysAgo,
        top_senders: topSenders,
        categories: categories,
        unread_count: emails.filter(e => e.unread).length
      };
      const summary = `Email analytics for the past ${timePeriod}: ` +
        `${analytics.total_emails} total emails (${analytics.emails_per_day.toFixed(1)}/day). ` +
        `Top sender: ${topSenders[0] || 'None'}.`;
      return {
        summary,
        insights: {
          analytics
        }
      };
    }
  }
  private async analyzeRelationships(): Promise<any> {
    // Get emails from past month
    const thirtyDaysAgo = Math.floor((Date.now() - 30 * 24 * 60 * 60 * 1000) / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: thirtyDaysAgo,
        limit: 500
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: 'No emails found to analyze relationships.',
        insights: {
          key_relationships: [],
          communication_patterns: {
            balance_analysis: 'No data available',
            response_patterns: [],
            collaboration_insights: []
          }
        }
      };
    }
    // Analyze communication patterns
    const contactStats = new Map<string, { sent: number; received: number; importance: number }>();
    // First, we need to identify the user's email
    const userEmail = emails.find(e => e.from[0]?.email)?.to?.[0]?.email || 'me@company.com';
    emails.forEach(email => {
      const isFromMe = email.from[0]?.email === userEmail;
      const contact = isFromMe ? email.to?.[0]?.email : email.from[0]?.email;
      if (contact) {
        const stats = contactStats.get(contact) || { sent: 0, received: 0, importance: 0 };
        if (isFromMe) {
          stats.sent++;
        } else {
          stats.received++;
        }
        contactStats.set(contact, stats);
      }
    });
    // Get importance scores for relationships
    try {
      const analysis = await this.emailAI.analyzeEmailImportance(emails.slice(0, 100));
      analysis.forEach(a => {
        const email = emails.find(e => e.id === a.email_id);
        const contact = email?.from[0]?.email;
        if (contact && contactStats.has(contact)) {
          const stats = contactStats.get(contact)!;
          stats.importance += a.importance_score;
          contactStats.set(contact, stats);
        }
      });
    } catch (error) {
      console.error('AI analysis failed:', error);
    }
    // Generate AI-powered relationship insights
    try {
      const insights = await this.emailAI.generateRelationshipInsights(emails, contactStats);
      return {
        summary: insights.executive_summary,
        insights: {
          key_relationships: insights.key_relationships,
          communication_patterns: insights.communication_patterns,
          network_insights: insights.network_insights,
          recommendations: insights.recommendations
        }
      };
    } catch (error) {
      console.error('AI relationship insights generation failed:', error);
      // Fallback to basic analysis
      const relationships = Array.from(contactStats.entries())
        .map(([contact, stats]) => ({
          contact,
          total_interactions: stats.sent + stats.received,
          balance: stats.sent / (stats.received || 1),
          avg_importance: stats.importance / (stats.received || 1)
        }))
        .sort((a, b) => b.total_interactions - a.total_interactions)
        .slice(0, 10);
      const frequentContacts = relationships.slice(0, 5).map(r => r.contact);
      const communicationBalance = relationships.reduce((acc, r) => {
        if (r.balance > 2) return { ...acc, over_communicating: acc.over_communicating + 1 };
        if (r.balance < 0.5) return { ...acc, under_communicating: acc.under_communicating + 1 };
        return { ...acc, balanced: acc.balanced + 1 };
      }, { over_communicating: 0, under_communicating: 0, balanced: 0 });
      const summary = `Analyzed communication patterns with ${contactStats.size} contacts. ` +
        `Most frequent: ${frequentContacts[0] || 'None'}.`;
      return {
        summary,
        insights: {
          relationships: {
            frequent_contacts: frequentContacts,
            communication_balance: communicationBalance,
            top_relationships: relationships.slice(0, 5)
          }
        }
      };
    }
  }
}
</file>

<file path="src/tools/findEmails.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { 
  FindEmailsParams, 
  Email, 
  EmailAnalysis,
  ActionItem,
  EmailIntent
} from '../types';
export class FindEmailsTool {
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: FindEmailsParams): Promise<any> {
    try {
      // Use AI to understand the search query
      const searchIntent = await this.emailAI.understandSearchQuery(params.query);
      // Build Nylas search parameters from AI understanding
      const queryParams = await this.buildSearchParamsFromIntent(searchIntent);
      queryParams.limit = params.limit || 2;
      // Search emails
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams
      });
      const emails = messages.data as Email[];
      // Handle empty results
      if (emails.length === 0) {
        return {
          emails: [],
          summary: 'No emails found matching your query.',
          total_count: 0
        };
      }
      // Perform analysis based on type
      let result: any = {
        emails,
        total_count: emails.length
      };
      switch (params.analysis_type) {
        case 'summary':
          // Summary only - no email content, just AI-powered natural language summary
          console.log(`Generating AI summary for ${emails.length} emails...`);
          try {
            const aiSummary = await this.emailAI.generateAggregatedSummary(emails);
            console.log('AI summary generated successfully');
            return {
              summary: aiSummary,
              total_count: emails.length,
              query: params.query
            };
          } catch (error) {
            console.error('AI summary generation failed:', error);
            // Fallback to basic summary if AI fails
            const basicSummary = await this.generateBasicSummary(emails, params.query);
            return {
              summary: basicSummary,
              total_count: emails.length,
              query: params.query
            };
          }
        case 'full':
          // Full email content without any analysis
          // Already set in result initialization
          break;
        case 'detailed':
          try {
            const analysis = await this.emailAI.analyzeEmailImportance(emails);
            result.analysis = analysis;
            result.summary = this.generateDetailedSummary(emails, analysis);
          } catch (error) {
            console.error('AI analysis failed:', error);
            // Simple summary when AI fails
            result.summary = `Found ${emails.length} email${emails.length !== 1 ? 's' : ''} matching "${params.query}".`;
          }
          break;
        case 'action_items':
          const actionAnalysis = await this.emailAI.analyzeEmailImportance(emails);
          const actionItems = await this.extractAllActionItems(emails);
          result.analysis = actionAnalysis;
          result.action_items = actionItems;
          result.summary = this.generateActionSummary(emails, actionItems);
          // Filter to only emails that need response if query mentions it
          if (params.query.toLowerCase().includes('respond') || 
              params.query.toLowerCase().includes('reply')) {
            result.emails = await this.filterUnrepliedEmails(emails);
            result.total_count = result.emails.length;
          }
          break;
        case 'priority':
          const priorityAnalysis = await this.emailAI.analyzeEmailImportance(emails);
          // Sort by importance score
          const sortedAnalysis = priorityAnalysis.sort(
            (a, b) => b.importance_score - a.importance_score
          );
          result.analysis = sortedAnalysis;
          result.emails = this.sortEmailsByAnalysis(emails, sortedAnalysis);
          result.summary = this.generatePrioritySummary(emails, sortedAnalysis);
          break;
        default:
          // Default to 'full' - return full emails without analysis
          // Already set in result initialization
      }
      return result;
    } catch (error: any) {
      throw new Error(`Failed to find emails: ${error.message}`);
    }
  }
  private async buildSearchParamsFromIntent(searchIntent: any): Promise<any> {
    const params: any = {};
    // Apply filters from AI understanding
    if (searchIntent.filters) {
      if (searchIntent.filters.unread !== undefined) {
        params.unread = searchIntent.filters.unread;
      }
      if (searchIntent.filters.starred !== undefined) {
        params.starred = searchIntent.filters.starred;
      }
      if (searchIntent.filters.hasAttachments !== undefined) {
        params.hasAttachment = searchIntent.filters.hasAttachments;
      }
    }
    // Apply timeframe
    if (searchIntent.timeframe) {
      if (searchIntent.timeframe.start) {
        const startTime = searchIntent.timeframe.start.getTime();
        if (!isNaN(startTime)) {
          params.receivedAfter = Math.floor(startTime / 1000);
        }
      }
      if (searchIntent.timeframe.end) {
        const endTime = searchIntent.timeframe.end.getTime();
        if (!isNaN(endTime)) {
          params.receivedBefore = Math.floor(endTime / 1000);
        }
      }
    }
    // Build search query from AI understanding
    const searchParts: string[] = [];
    // Add senders
    if (searchIntent.senders && searchIntent.senders.length > 0) {
      searchIntent.senders.forEach((sender: string) => {
        searchParts.push(`from:${sender}`);
      });
    }
    // Add keywords
    if (searchIntent.keywords && searchIntent.keywords.length > 0) {
      searchParts.push(...searchIntent.keywords);
    }
    if (searchParts.length > 0) {
      params.searchQueryNative = searchParts.join(' ');
    }
    return params;
  }
  private async filterUnrepliedEmails(emails: Email[]): Promise<Email[]> {
    const unreplied: Email[] = [];
    for (const email of emails) {
      if (email.thread_id) {
        try {
          // Check if thread has replies from us
          const thread = await this.nylas.threads.find({
            identifier: this.grantId,
            threadId: email.thread_id
          });
          // Simple check: if thread has only one message, it's unreplied
          if (thread.data.messageIds && thread.data.messageIds.length === 1) {
            unreplied.push(email);
          }
        } catch (error) {
          console.error(`Failed to check thread ${email.thread_id}:`, error);
          // Include email if we can't check
          unreplied.push(email);
        }
      } else {
        // No thread means single email, likely unreplied
        unreplied.push(email);
      }
    }
    return unreplied;
  }
  private async extractAllActionItems(emails: Email[]): Promise<ActionItem[]> {
    const allActionItems: ActionItem[] = [];
    for (const email of emails) {
      try {
        const items = await this.emailAI.extractActionItems(email);
        allActionItems.push(...items);
      } catch (error) {
        console.error(`Failed to extract action items from email ${email.id}:`, error);
      }
    }
    return allActionItems;
  }
  private async generateBasicSummary(emails: Email[], query: string): Promise<string> {
    const count = emails.length;
    const unreadCount = emails.filter(e => e.unread).length;
    const starredCount = emails.filter(e => e.starred).length;
    let summary = `Found ${count} email${count !== 1 ? 's' : ''} matching "${query}"`;
    const details: string[] = [];
    if (unreadCount > 0) details.push(`${unreadCount} unread`);
    if (starredCount > 0) details.push(`${starredCount} starred`);
    if (details.length > 0) {
      summary += ` (${details.join(', ')})`;
    }
    summary += '.';
    // Add sender information
    if (emails.length > 0) {
      const senders = emails.slice(0, 3).map(e => 
        e.from[0]?.name || e.from[0]?.email?.split('@')[0] || 'Unknown'
      );
      summary += ` From: ${senders.join(', ')}`;
      if (emails.length > 3) {
        summary += ` and ${emails.length - 3} others`;
      }
      summary += '.';
    }
    return summary;
  }
  private generateDetailedSummary(emails: Email[], analysis: EmailAnalysis[]): string {
    const count = emails.length;
    const importantCount = analysis.filter(a => a.importance_score > 0.7).length;
    const actionRequired = analysis.filter(a => a.action_required).length;
    const categories = analysis.reduce((acc, a) => {
      acc[a.category] = (acc[a.category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    let summary = `Analyzed ${count} emails: `;
    summary += `${importantCount} important, `;
    summary += `${actionRequired} need action. `;
    summary += `By category: ${Object.entries(categories)
      .map(([cat, cnt]) => `${cat.replace('_', ' ')} (${cnt})`)
      .join(', ')}.`;
    return summary;
  }
  private generateActionSummary(emails: Email[], actionItems: ActionItem[]): string {
    const highPriority = actionItems.filter(a => a.priority === 'high').length;
    const withDeadlines = actionItems.filter(a => a.deadline).length;
    let summary = `Found ${emails.length} emails with ${actionItems.length} action items`;
    const details: string[] = [];
    if (highPriority > 0) details.push(`${highPriority} high priority`);
    if (withDeadlines > 0) details.push(`${withDeadlines} with deadlines`);
    if (details.length > 0) {
      summary += ` (${details.join(', ')})`;
    }
    summary += '.';
    return summary;
  }
  private generatePrioritySummary(emails: Email[], analysis: EmailAnalysis[]): string {
    const topPriority = analysis.slice(0, 3);
    const names = topPriority
      .map(a => {
        const email = emails.find(e => e.id === a.email_id);
        return email?.from[0]?.name || email?.from[0]?.email?.split('@')[0] || 'Unknown';
      })
      .join(', ');
    return `${emails.length} emails sorted by priority. Most important from: ${names}.`;
  }
  private sortEmailsByAnalysis(emails: Email[], analysis: EmailAnalysis[]): Email[] {
    const emailMap = new Map(emails.map(e => [e.id, e]));
    const sortedEmails: Email[] = [];
    // First add emails in order of analysis (already sorted by importance)
    for (const a of analysis) {
      const email = emailMap.get(a.email_id);
      if (email) {
        sortedEmails.push(email);
        emailMap.delete(a.email_id);
      }
    }
    // Add any remaining emails
    sortedEmails.push(...emailMap.values());
    return sortedEmails;
  }
}
</file>

<file path="src/tools/organizeInbox.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { 
  OrganizeInboxParams, 
  Email, 
  EmailAnalysis,
  ApprovalRequiredResponse
} from '../types';
export class OrganizeInboxTool {
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: OrganizeInboxParams): Promise<any> {
    // Check if this is an approved action execution
    if (params.approved && params.action_data) {
      return this.executeApprovedOrganization(params);
    }
    // First, always run in preview mode to gather the plan
    const planResult = await this.createOrganizationPlan(params);
    // If dry_run is true or there are no actions, return the preview
    if (params.dry_run || planResult.total_actions === 0) {
      return planResult;
    }
    // Otherwise, return an approval request
    return this.createApprovalRequest(planResult, params);
  }
  private async createOrganizationPlan(params: OrganizeInboxParams): Promise<any> {
    const result = {
      organized_count: 0,
      actions_taken: [] as string[],
      preview_actions: [] as string[],
      errors: [] as string[],
      total_actions: 0,
      organization_plan: null as any
    };
    try {
      // Use AI to understand the organization instruction
      const intent = await this.emailAI.understandOrganizationIntent(params.instruction);
      // Get emails to organize
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: {
          limit: params.scope?.limit || 100
        }
      });
      const emails = messages.data as Email[];
      // Apply each AI-generated rule to the emails
      for (const email of emails) {
        for (const rule of intent.rules) {
          if (this.emailMatchesCondition(email, rule.condition)) {
            const action = `${rule.action} email "${email.subject}" from ${email.from[0]?.email}`;
            if (rule.target) {
              result.preview_actions.push(`${action} to folder "${rule.target}"`);
            } else {
              result.preview_actions.push(action);
            }
            result.organized_count++;
            break; // Only apply first matching rule
          }
        }
      }
      result.organization_plan = intent;
      result.total_actions = result.preview_actions.length;
    } catch (error: any) {
      result.errors.push(`Organization planning failed: ${error.message}`);
    }
    return result;
  }
  private createApprovalRequest(
    planResult: any,
    params: OrganizeInboxParams
  ): ApprovalRequiredResponse {
    const actionSummary = this.summarizeActions(planResult.preview_actions);
    return {
      needs_approval: true,
      action_type: 'organize_inbox',
      action_data: {
        organization_plan: planResult,
        original_params: params
      },
      preview: {
        summary: `Organize ${planResult.total_actions} emails based on: "${params.instruction}"`,
        details: {
          instruction: params.instruction,
          total_actions: planResult.total_actions,
          actions_by_type: actionSummary,
          preview_actions: planResult.preview_actions.slice(0, 10), // First 10 for preview
          organization_rules: planResult.organization_plan?.rules || []
        },
        risks: this.assessOrganizationRisks(planResult, params)
      }
    };
  }
  private summarizeActions(actions: string[]): Record<string, number> {
    const summary: Record<string, number> = {};
    actions.forEach(action => {
      if (action.includes('move')) summary.move = (summary.move || 0) + 1;
      if (action.includes('archive')) summary.archive = (summary.archive || 0) + 1;
      if (action.includes('star')) summary.star = (summary.star || 0) + 1;
      if (action.includes('mark')) summary.mark_read = (summary.mark_read || 0) + 1;
      if (action.includes('delete')) summary.delete = (summary.delete || 0) + 1;
    });
    return summary;
  }
  private assessOrganizationRisks(
    planResult: any,
    params: OrganizeInboxParams
  ): string[] {
    const risks: string[] = [];
    if (planResult.total_actions > 50) {
      risks.push(`Large number of emails will be affected (${planResult.total_actions})`);
    }
    const deleteCount = planResult.preview_actions.filter((a: string) => 
      a.toLowerCase().includes('delete')
    ).length;
    if (deleteCount > 0) {
      risks.push(`${deleteCount} emails will be permanently deleted`);
    }
    // Always warn about AI interpretation since we're using natural language
    risks.push('AI-interpreted organization rules based on your instruction');
    return risks;
  }
  private async executeApprovedOrganization(params: OrganizeInboxParams): Promise<any> {
    if (!params.action_data?.organization_plan || !params.action_data?.original_params) {
      throw new Error('Missing organization plan in approved action');
    }
    const { organization_plan } = params.action_data;
    const result = {
      organized_count: 0,
      actions_taken: [] as string[],
      errors: [] as string[]
    };
    try {
      // Execute the organization plan that was generated during preview
      await this.executeOrganizationPlan(organization_plan, result);
      return {
        ...result,
        approval_executed: true,
        message: `Successfully organized ${result.organized_count} emails`
      };
    } catch (error: any) {
      throw new Error(`Failed to execute approved organization: ${error.message}`);
    }
  }
  private async executeOrganizationPlan(
    plan: any,
    result: any
  ): Promise<void> {
    try {
      // Get emails to organize
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: {
          limit: 100
        }
      });
      const emails = messages.data as Email[];
      const folders = await this.getFolderMap();
      // Apply each rule from the plan
      for (const email of emails) {
        for (const rule of plan.rules || []) {
          if (this.emailMatchesCondition(email, rule.condition)) {
            switch (rule.action.toLowerCase()) {
              case 'move to folder':
                if (rule.target) {
                  const folderId = await this.ensureFolder(rule.target, folders);
                  await this.moveToFolder(email.id, folderId);
                  result.actions_taken.push(`Moved "${email.subject}" to ${rule.target}`);
                  result.organized_count++;
                }
                break;
              case 'archive':
                const archiveFolderId = await this.getArchiveFolderId();
                await this.moveToFolder(email.id, archiveFolderId);
                result.actions_taken.push(`Archived "${email.subject}"`);
                result.organized_count++;
                break;
              case 'star':
              case 'flag':
                await this.starEmail(email.id);
                result.actions_taken.push(`Starred "${email.subject}"`);
                result.organized_count++;
                break;
              case 'mark read':
              case 'mark as read':
                await this.markAsRead(email.id);
                result.actions_taken.push(`Marked "${email.subject}" as read`);
                result.organized_count++;
                break;
              case 'delete':
                await this.deleteEmail(email.id);
                result.actions_taken.push(`Deleted "${email.subject}"`);
                result.organized_count++;
                break;
            }
            break; // Only apply first matching rule per email
          }
        }
      }
    } catch (error: any) {
      throw new Error(`Organization execution failed: ${error.message}`);
    }
  }
  private emailMatchesCondition(email: Email, condition: string): boolean {
    const lowerCondition = condition.toLowerCase();
    // Check subject contains
    if (lowerCondition.includes('subject contains')) {
      const searchTerm = lowerCondition.split('subject contains')[1].trim();
      return email.subject.toLowerCase().includes(searchTerm);
    }
    // Check from email
    if (lowerCondition.includes('from')) {
      const searchTerm = lowerCondition.split('from')[1].trim();
      return email.from.some(f => 
        f.email.toLowerCase().includes(searchTerm) ||
        (f.name && f.name.toLowerCase().includes(searchTerm))
      );
    }
    // Check if unread
    if (lowerCondition === 'unread') {
      return email.unread === true;
    }
    // Check if starred
    if (lowerCondition === 'starred' || lowerCondition === 'important') {
      return email.starred === true;
    }
    // Check date conditions
    if (lowerCondition.includes('older than')) {
      const daysMatch = lowerCondition.match(/older than (\d+) days?/);
      if (daysMatch && email.date) {
        const days = parseInt(daysMatch[1]);
        const cutoffTime = Date.now() - (days * 24 * 60 * 60 * 1000);
        return email.date * 1000 < cutoffTime;
      }
    }
    // Default: check if any part of the email contains the condition text
    return email.subject.toLowerCase().includes(lowerCondition) ||
           email.snippet?.toLowerCase().includes(lowerCondition) || false;
  }
  private async getFolderMap(): Promise<Map<string, string>> {
    const folders = await this.nylas.folders.list({
      identifier: this.grantId
    });
    const folderMap = new Map<string, string>();
    folders.data.forEach(folder => {
      folderMap.set(folder.name.toLowerCase(), folder.id);
    });
    return folderMap;
  }
  private async ensureFolder(name: string, folderMap: Map<string, string>): Promise<string> {
    const lowerName = name.toLowerCase();
    if (folderMap.has(lowerName)) {
      return folderMap.get(lowerName)!;
    }
    try {
      // Create the folder
      const newFolder = await this.nylas.folders.create({
        identifier: this.grantId,
        requestBody: {
          name: name
        }
      });
      const folderId = newFolder.data.id;
      folderMap.set(lowerName, folderId);
      return folderId;
    } catch (error: any) {
      throw new Error(`Failed to create folder ${name}: ${error.message}`);
    }
  }
  private async getArchiveFolderId(): Promise<string> {
    const folders = await this.nylas.folders.list({
      identifier: this.grantId
    });
    const archiveFolder = folders.data.find(f => 
      f.attributes?.includes('\\Archive') || 
      f.name.toLowerCase() === 'archive'
    );
    if (!archiveFolder) {
      throw new Error('Archive folder not found');
    }
    return archiveFolder.id;
  }
  private async moveToFolder(messageId: string, folderId: string): Promise<void> {
    await this.nylas.messages.update({
      identifier: this.grantId,
      messageId,
      requestBody: {
        folders: [folderId]
      }
    });
  }
  private async starEmail(messageId: string): Promise<void> {
    await this.nylas.messages.update({
      identifier: this.grantId,
      messageId,
      requestBody: {
        starred: true
      }
    });
  }
  private async markAsRead(messageId: string): Promise<void> {
    await this.nylas.messages.update({
      identifier: this.grantId,
      messageId,
      requestBody: {
        unread: false
      }
    });
  }
  private async deleteEmail(messageId: string): Promise<void> {
    await this.nylas.messages.destroy({
      identifier: this.grantId,
      messageId
    });
  }
  private async findOldEmails(): Promise<Email[]> {
    const thirtyDaysAgo = Math.floor((Date.now() - 30 * 24 * 60 * 60 * 1000) / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedBefore: thirtyDaysAgo,
        unread: false,
        limit: 50
      }
    });
    return messages.data as Email[];
  }
  private async findEmailsByCondition(condition: string): Promise<Email[]> {
    const queryParams: any = {};
    // Parse condition
    if (condition.startsWith('from:')) {
      const from = condition.substring(5);
      queryParams.searchQueryNative = `from:${from}`;
    } else if (condition === 'older_than:30d') {
      const thirtyDaysAgo = Math.floor((Date.now() - 30 * 24 * 60 * 60 * 1000) / 1000);
      queryParams.receivedBefore = thirtyDaysAgo;
    } else {
      queryParams.searchQueryNative = condition;
    }
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams
    });
    return messages.data as Email[];
  }
  private filterEmailsByCondition(emails: Email[], condition: string): Email[] {
    const lowerCondition = condition.toLowerCase();
    if (lowerCondition.includes('subject contains')) {
      const searchTerm = lowerCondition.split('subject contains')[1].trim();
      return emails.filter(e => e.subject.toLowerCase().includes(searchTerm));
    }
    if (lowerCondition.includes('from')) {
      const searchTerm = lowerCondition.split('from')[1].trim();
      return emails.filter(e => 
        e.from.some(f => f.email.toLowerCase().includes(searchTerm))
      );
    }
    return [];
  }
}
</file>

<file path="src/tools/smartFolders.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { SmartFoldersParams, Email, ApprovalRequiredResponse } from '../types';
interface StoredFolderRule {
  id: string;
  rules: string[];
  description?: string;
}
export class SmartFoldersTool {
  private folderRulesStore: Map<string, StoredFolderRule> = new Map();
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: SmartFoldersParams): Promise<any> {
    // Check if this is an approved action execution
    if (params.approved && params.action_data) {
      return this.executeApprovedAction(params);
    }
    // Parse the natural language query to understand intent
    const query = params.query.toLowerCase();
    if (query.includes('list') || query.includes('show') || query.includes('what folders')) {
      return this.listSmartFolders();
    } else if (query.includes('create') || query.includes('make') || query.includes('set up')) {
      return this.createSmartFolder(params);
    } else if (query.includes('update') || query.includes('change') || query.includes('modify')) {
      return this.updateSmartFolder(params);
    } else if (query.includes('apply') || query.includes('organize') || query.includes('move emails')) {
      // For apply action, check if approval is needed
      return this.handleApplyAction(params);
    } else {
      // Default to create if we can't determine intent
      return this.createSmartFolder(params);
    }
  }
  private async handleApplyAction(params: SmartFoldersParams): Promise<any> {
    // First get the preview of what would be applied
    const previewResult = await this.applySmartFolder({ ...params, dry_run: true });
    // If dry_run was requested or no emails to move, return the preview
    if (params.dry_run || !previewResult.preview?.total_count) {
      return previewResult;
    }
    // Otherwise, return an approval request
    return this.createApprovalRequest(previewResult, params);
  }
  private createApprovalRequest(
    previewResult: any,
    params: SmartFoldersParams
  ): ApprovalRequiredResponse {
    return {
      needs_approval: true,
      action_type: 'apply_smart_folder',
      action_data: {
        folder_plan: previewResult,
        original_params: params
      },
      preview: {
        summary: `Apply smart folder "${previewResult.preview.folder_name}" to ${previewResult.preview.total_count} emails`,
        details: {
          folder_name: previewResult.preview.folder_name,
          total_emails: previewResult.preview.total_count,
          sample_emails: previewResult.preview.emails_to_move.slice(0, 5),
          action: 'move_to_folder'
        },
        risks: this.assessApplyRisks(previewResult)
      }
    };
  }
  private assessApplyRisks(previewResult: any): string[] {
    const risks: string[] = [];
    if (previewResult.preview.total_count > 50) {
      risks.push(`Large number of emails will be moved (${previewResult.preview.total_count})`);
    }
    risks.push('Emails will be moved from their current folders');
    return risks;
  }
  private async executeApprovedAction(params: SmartFoldersParams): Promise<any> {
    if (!params.action_data?.original_params) {
      throw new Error('Missing action data in approved action');
    }
    const { original_params } = params.action_data;
    // Execute the actual action with dry_run = false
    const executeParams = { ...original_params, dry_run: false };
    try {
      const result = await this.applySmartFolder(executeParams);
      return {
        ...result,
        approval_executed: true
      };
    } catch (error: any) {
      throw new Error(`Failed to execute approved smart folder action: ${error.message}`);
    }
  }
  private async createSmartFolder(params: SmartFoldersParams): Promise<any> {
    try {
      // Use AI to generate folder rules from the natural language query
      const generatedRules = await this.emailAI.generateSmartFolderRules(params.query);
      // Use provided name or AI-generated name
      const folderName = params.folder_name || generatedRules.name;
      // Create the folder
      const folder = await this.nylas.folders.create({
        identifier: this.grantId,
        requestBody: {
          name: folderName
        }
      });
      // Store the rules
      this.folderRulesStore.set(folderName.toLowerCase(), {
        id: folder.data.id,
        rules: generatedRules.rules,
        description: generatedRules.description
      });
      return {
        success: true,
        folder_id: folder.data.id,
        folder_name: folderName,
        rules: generatedRules.rules,
        description: generatedRules.description,
        message: `Smart folder "${folderName}" created with ${generatedRules.rules.length} rules`
      };
    } catch (error: any) {
      throw new Error(`Failed to create smart folder: ${error.message}`);
    }
  }
  private async updateSmartFolder(params: SmartFoldersParams): Promise<any> {
    // Extract folder name from query
    const query = params.query.toLowerCase();
    let folderName = params.folder_name;
    if (!folderName) {
      // Try to extract folder name from query
      const folderMatch = query.match(/folder\s+["']?([^"']+)["']?/);
      if (folderMatch) {
        folderName = folderMatch[1];
      } else {
        throw new Error('Could not determine which folder to update. Please specify the folder name.');
      }
    }
    // Find existing folder
    const folders = await this.nylas.folders.list({
      identifier: this.grantId
    });
    const existingFolder = folders.data.find(
      f => f.name.toLowerCase() === folderName!.toLowerCase()
    );
    if (!existingFolder) {
      throw new Error(`Folder "${folderName}" not found`);
    }
    // Generate updated rules based on the query
    const updatedRules = await this.emailAI.generateSmartFolderRules(
      `Update folder "${folderName}" based on: ${params.query}`
    );
    // Update stored rules
    this.folderRulesStore.set(folderName.toLowerCase(), {
      id: existingFolder.id,
      rules: updatedRules.rules,
      description: updatedRules.description
    });
    return {
      success: true,
      folder_id: existingFolder.id,
      folder_name: folderName,
      rules: updatedRules.rules,
      description: updatedRules.description,
      message: `Smart folder "${folderName}" updated successfully`
    };
  }
  private async applySmartFolder(params: SmartFoldersParams): Promise<any> {
    // Get stored folder rules
    const folderRules = await this.getStoredFolderRules();
    // Find the folder mentioned in the query
    let targetFolder: StoredFolderRule | undefined;
    let folderName: string | undefined;
    const query = params.query.toLowerCase();
    for (const [name, rule] of folderRules) {
      if (query.includes(name)) {
        targetFolder = rule;
        folderName = name;
        break;
      }
    }
    if (!targetFolder || !folderName) {
      // If no specific folder mentioned, use AI to understand the query
      const generatedRules = await this.emailAI.generateSmartFolderRules(params.query);
      if (!generatedRules || !generatedRules.name) {
        throw new Error('Could not determine which folder to apply. Please specify a folder name.');
      }
      folderName = params.folder_name || generatedRules.name;
      // Check if this folder exists
      const folders = await this.nylas.folders.list({
        identifier: this.grantId
      });
      const existingFolder = folders.data.find(
        f => f.name.toLowerCase() === folderName!.toLowerCase()
      );
      if (!existingFolder) {
        return {
          success: false,
          error: `Folder "${folderName}" not found. Please create it first.`
        };
      }
      targetFolder = {
        id: existingFolder.id,
        rules: generatedRules.rules,
        description: generatedRules.description
      };
    }
    // Find emails matching the rules
    const matchingEmails: Email[] = [];
    for (const rule of targetFolder.rules) {
      const emails = await this.findEmailsByRule(rule);
      matchingEmails.push(...emails);
    }
    // Remove duplicates
    const uniqueEmails = Array.from(
      new Map(matchingEmails.map(e => [e.id, e])).values()
    );
    if (params.dry_run) {
      return {
        success: true,
        preview: {
          folder_name: folderName,
          emails_to_move: uniqueEmails.map(e => ({
            id: e.id,
            subject: e.subject,
            from: e.from[0]?.email
          })),
          total_count: uniqueEmails.length
        }
      };
    }
    // Move emails to the folder
    let movedCount = 0;
    for (const email of uniqueEmails) {
      try {
        await this.nylas.messages.update({
          identifier: this.grantId,
          messageId: email.id,
          requestBody: {
            folders: [targetFolder.id]
          }
        });
        movedCount++;
      } catch (error) {
        console.error(`Failed to move email ${email.id}:`, error);
      }
    }
    return {
      success: true,
      emails_processed: movedCount,
      message: `Applied rules to ${movedCount} emails`
    };
  }
  private async listSmartFolders(): Promise<any> {
    const folderRules = await this.getStoredFolderRules();
    const smartFolders = Array.from(folderRules.entries()).map(([name, rule]) => ({
      name,
      folder_id: rule.id,
      rules: rule.rules,
      description: rule.description
    }));
    return {
      smart_folders: smartFolders,
      total_count: smartFolders.length
    };
  }
  private async findEmailsByRule(rule: string): Promise<Email[]> {
    const queryParams: any = {};
    // Parse simple rules
    if (rule.includes('from:')) {
      const fromMatch = rule.match(/from:([^\s]+)/);
      if (fromMatch) {
        queryParams.searchQueryNative = rule;
      }
    } else if (rule.includes('subject contains')) {
      queryParams.searchQueryNative = rule;
    } else {
      // For complex rules, use the rule as-is
      queryParams.searchQueryNative = rule;
    }
    queryParams.limit = 100;
    try {
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams
      });
      return messages.data as Email[];
    } catch (error) {
      console.error(`Failed to find emails for rule "${rule}":`, error);
      return [];
    }
  }
  private async getStoredFolderRules(): Promise<Map<string, StoredFolderRule>> {
    // In a real implementation, this would persist to a database
    // For now, we'll try to reconstruct from folder names
    if (this.folderRulesStore.size === 0) {
      try {
        const folders = await this.nylas.folders.list({
          identifier: this.grantId
        });
        // Look for folders that seem to be smart folders
        // In production, you'd store this metadata properly
        folders.data.forEach(folder => {
          if (!folder.attributes?.includes('\\System')) {
            // Assume user-created folders might be smart folders
            this.folderRulesStore.set(folder.name.toLowerCase(), {
              id: folder.id,
              rules: [], // Would need to retrieve stored rules
              description: `Smart folder: ${folder.name}`
            });
          }
        });
      } catch (error) {
        console.error('Failed to load folder rules:', error);
      }
    }
    return this.folderRulesStore;
  }
}
</file>

<file path="src/types/index.ts">
// Email AI Types
export interface EmailIntent {
  intent: 'send' | 'reply' | 'forward' | 'find' | 'organize';
  recipients?: string[];
  subject?: string;
  key_points: string[];
  urgency: 'low' | 'normal' | 'high' | 'urgent';
  tone: 'professional' | 'casual' | 'friendly' | 'formal' | 'grateful';
  context_message_id?: string;
}
export interface GeneratedEmail {
  to: string[];
  cc?: string[];
  bcc?: string[];
  subject: string;
  body: string;
  in_reply_to?: string;
  tone_confirmation?: string;
}
export interface EmailAnalysis {
  email_id: string;
  importance_score: number; // 0-1
  category: 'urgent_alert' | 'client_email' | 'newsletter' | 'notification' | 'personal' | 'other';
  reason: string;
  action_required: boolean;
  suggested_folder?: string;
}
export interface ActionItem {
  task: string;
  deadline?: string;
  priority: 'low' | 'medium' | 'high';
  assigned_to?: string;
}
export interface EmailSummary {
  total_emails: number;
  important_count: number;
  requires_response: number;
  categories: Record<string, number>;
  key_senders: string[];
  urgent_items: string[];
}
// Approval System Types - Legacy (removed)
// New stateless approval response that includes all action data
export interface ApprovalRequiredResponse {
  needs_approval: true;
  action_type: 'send_email' | 'organize_inbox' | 'apply_smart_folder';
  action_data: any; // Contains all data needed to execute the action
  preview: {
    summary: string;
    details: any;
    risks?: string[];
  };
  suggested_modifications?: any;
}
// Response for when an approved action is executed
export interface ApprovedActionResponse {
  success: boolean;
  message: string;
  result?: any;
}
// Legacy approval types removed - using stateless approval flow
// Setup Types
export interface SetupInstruction {
  step: number;
  title: string;
  description: string;
  actions?: {
    type: 'link' | 'copy_field';
    label: string;
    url?: string;
    field?: string;
    validation?: string;
  }[];
  substeps?: string[];
  tips?: string[];
  common_issues?: {
    issue: string;
    solution: string;
  }[];
}
export interface SetupResponse {
  type: 'setup_instructions' | 'setup_success' | 'setup_error' | 'validation_error';
  title?: string;
  estimated_time?: string;
  steps?: SetupInstruction[];
  next_step?: {
    description: string;
    command: string;
    parameters: any;
  };
  message?: string;
  credentials_validated?: boolean;
  credentials_to_store?: {
    nylas_api_key: string;
    nylas_grant_id: string;
    email_address?: string;
    provider?: string;
  };
  error_details?: string;
  missing_fields?: string[];
}
// MCP Context Types
export interface MCPContext {
  userId: string;
  credentials?: {
    nylas_api_key?: string;
    nylas_grant_id?: string;
  };
  approvalToken?: string;
}
// Email types (simplified from Nylas)
export interface Email {
  id: string;
  subject: string;
  from: { email: string; name?: string }[];
  to?: { email: string; name?: string }[];
  body?: string;
  snippet?: string;
  date?: number;
  unread?: boolean;
  starred?: boolean;
  folders?: string[];
  thread_id?: string;
}
// Tool Parameter Types
export interface ManageEmailParams {
  action: 'send' | 'reply' | 'forward' | 'draft';
  query: string;
  context_message_id?: string;
  require_approval?: boolean;
  // Context injection fields from Juli
  user_name?: string;
  user_email?: string;
  // Fields for stateless approval flow
  approved?: boolean;
  action_data?: {
    email_content: GeneratedEmail;
    original_params: any;
  };
}
export interface FindEmailsParams {
  query: string;
  analysis_type?: 'full' | 'summary' | 'detailed' | 'action_items' | 'priority';
  limit?: number;
}
export interface OrganizeInboxParams {
  instruction: string;
  scope?: {
    folder?: string;
    date_range?: string;
    limit?: number;
  };
  dry_run?: boolean;
  // New fields for stateless approval flow
  approved?: boolean;
  action_data?: {
    organization_plan: any;
    original_params: any;
  };
}
export interface EmailInsightsParams {
  query: string;
  time_period?: string;
}
export interface SmartFoldersParams {
  query: string;
  folder_name?: string;
  dry_run?: boolean;
  // New fields for stateless approval flow
  approved?: boolean;
  action_data?: {
    folder_plan: any;
    original_params: any;
  };
}
</file>

<file path="tests/e2e/utils/testLogger.ts">
/**
 * Enhanced logger for E2E tests with comprehensive output formatting
 */
import { E2E_CONFIG } from './config';
import * as fs from 'fs';
import * as path from 'path';
export class TestLogger {
  private startTime: number = Date.now();
  private operationTimings: Map<string, number> = new Map();
  private responseDir: string;
  constructor() {
    // Create directory for saving responses if enabled
    if (E2E_CONFIG.logging.saveResponses) {
      this.responseDir = path.join(process.cwd(), 'test-responses', new Date().toISOString().split('T')[0]);
      if (!fs.existsSync(this.responseDir)) {
        fs.mkdirSync(this.responseDir, { recursive: true });
      }
    }
  }
  /**
   * Log a section header
   */
  logSection(title: string) {
    const width = 60;
    const padding = Math.max(0, width - title.length - 2);
    const leftPad = Math.floor(padding / 2);
    const rightPad = padding - leftPad;
    console.log('\n' + '═'.repeat(width));
    console.log('═' + ' '.repeat(leftPad) + title + ' '.repeat(rightPad) + '═');
    console.log('═'.repeat(width) + '\n');
  }
  /**
   * Log a numbered step
   */
  logStep(step: number, description: string) {
    console.log(`\n📍 Step ${step}: ${description}`);
    if (E2E_CONFIG.logging.logTimings) {
      this.startOperation(`step_${step}`);
    }
  }
  /**
   * Log an API call
   */
  logApiCall(method: string, endpoint: string, data?: any) {
    if (!E2E_CONFIG.logging.logApiCalls) return;
    console.log(`\n🔄 API Call: ${method} ${endpoint}`);
    if (data && E2E_CONFIG.logging.verbose) {
      console.log('📤 Request Data:');
      this.logData('', data, 2);
    }
  }
  /**
   * Log an API response
   */
  logApiResponse(status: number, data: any, endpoint?: string) {
    if (!E2E_CONFIG.logging.logApiCalls) return;
    const statusEmoji = status >= 200 && status < 300 ? '✅' : '❌';
    console.log(`\n${statusEmoji} API Response: ${status}`);
    if (E2E_CONFIG.logging.verbose && data) {
      console.log('📥 Response Data:');
      this.logData('', data, 2);
    }
    // Save response to file if enabled
    if (E2E_CONFIG.logging.saveResponses && endpoint) {
      const filename = `${Date.now()}_${endpoint.replace(/\//g, '_')}.json`;
      const filepath = path.join(this.responseDir, filename);
      fs.writeFileSync(filepath, JSON.stringify(data, null, 2));
      console.log(`💾 Response saved to: ${filepath}`);
    }
  }
  /**
   * Log a success message
   */
  logSuccess(message: string) {
    console.log(`\n✅ ${message}`);
  }
  /**
   * Log an error message
   */
  logError(message: string, error?: any) {
    console.log(`\n❌ ${message}`);
    if (error) {
      console.error('Error details:', JSON.stringify(error, null, 2));
    }
  }
  /**
   * Log a warning message
   */
  logWarning(message: string) {
    console.log(`\n⚠️  ${message}`);
  }
  /**
   * Log an info message
   */
  logInfo(message: string) {
    console.log(`\nℹ️  ${message}`);
  }
  /**
   * Log data with pretty formatting
   */
  logData(label: string, data: any, indent: number = 0) {
    const prefix = ' '.repeat(indent);
    if (label) {
      console.log(`${prefix}📊 ${label}:`);
    }
    if (typeof data === 'object' && data !== null) {
      const formatted = JSON.stringify(data, null, 2)
        .split('\n')
        .map(line => prefix + '  ' + line)
        .join('\n');
      console.log(formatted);
    } else {
      console.log(`${prefix}  ${data}`);
    }
  }
  /**
   * Start timing an operation
   */
  startOperation(operationName: string) {
    if (E2E_CONFIG.logging.logTimings) {
      this.operationTimings.set(operationName, Date.now());
    }
  }
  /**
   * End timing an operation and log the duration
   */
  endOperation(operationName: string) {
    if (!E2E_CONFIG.logging.logTimings) return;
    const startTime = this.operationTimings.get(operationName);
    if (startTime) {
      const duration = Date.now() - startTime;
      console.log(`⏱️  ${operationName} took ${duration}ms`);
      this.operationTimings.delete(operationName);
    }
  }
  /**
   * Log timing for an async operation
   */
  async timeOperation<T>(operationName: string, operation: () => Promise<T>): Promise<T> {
    this.startOperation(operationName);
    try {
      const result = await operation();
      this.endOperation(operationName);
      return result;
    } catch (error) {
      this.endOperation(operationName);
      throw error;
    }
  }
  /**
   * Log test summary
   */
  logTestSummary(passed: number, failed: number, skipped: number = 0) {
    const total = passed + failed + skipped;
    const duration = ((Date.now() - this.startTime) / 1000).toFixed(2);
    this.logSection('TEST SUMMARY');
    console.log(`Total Tests: ${total}`);
    console.log(`✅ Passed: ${passed}`);
    if (failed > 0) console.log(`❌ Failed: ${failed}`);
    if (skipped > 0) console.log(`⏭️  Skipped: ${skipped}`);
    console.log(`\n⏱️  Total Duration: ${duration}s`);
    if (this.responseDir) {
      console.log(`\n💾 Responses saved to: ${this.responseDir}`);
    }
  }
  /**
   * Create a sub-logger for nested operations
   */
  createSubLogger(prefix: string): SubLogger {
    return new SubLogger(this, prefix);
  }
}
/**
 * Sub-logger for nested operations
 */
class SubLogger {
  constructor(private parent: TestLogger, private prefix: string) {}
  log(message: string) {
    console.log(`  ${this.prefix}: ${message}`);
  }
  logData(label: string, data: any) {
    this.parent.logData(`${this.prefix} - ${label}`, data, 2);
  }
}
// Export a singleton instance for convenience
export const logger = new TestLogger();
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
logs
*.log

# Environment variables
.env
.env.test
.env.local
.env.development.local
.env.test.local
.env.production.local

# TypeScript
*.tsbuildinfo

# Editor directories and files
.idea/
*.swp
*.swo

# Setup metadata
.nylas-setup.json

# Test files
test_*.js
test_*.mjs
test_*.html
test_*.json

# Coverage reports
coverage/
.nyc_output/

# Claude Code settings
.claude/

# Temporary files
*.tmp
*.temp
.tmp/
.temp/

# Debug logs
debug.log
lerna-debug.log*

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Editor files
*.sublime-project
*.sublime-workspace
.project
.classpath
.c9/
*.launch
.settings/
*.iml
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# Backup files
*.bak
*.backup
*~

# Logs
server.log
tests/e2e/logs/

# Lock files (keep only package-lock.json)
bun.lockb
yarn.lock
pnpm-lock.yaml

# Smithery config (if not needed for public)
smithery.yaml
</file>

<file path="CONTRIBUTING.md">
# Contributing to Inbox MCP

Thank you for your interest in contributing to Inbox MCP! We welcome contributions from the community.

## Getting Started

1. Fork the repository
2. Clone your fork: `git clone https://github.com/yourusername/inbox-mcp.git`
3. Install dependencies: `npm install`
4. Create a feature branch: `git checkout -b feature/your-feature-name`

## Development Setup

1. Copy `.env.example` to `.env` and add your OpenAI API key
2. Build the project: `npm run build`
3. Run in development mode: `npm run dev`

## Testing

- Run unit tests: `npm test`
- Run specific tests: `npm test -- path/to/test`
- Run tests in watch mode: `npm test -- --watch`

For E2E tests, you'll need Nylas credentials in `.env.test`.

## Code Style

- We use TypeScript for type safety
- Follow existing code patterns and conventions
- Keep functions focused and testable
- Add JSDoc comments for public APIs

## Submitting Changes

1. Ensure all tests pass
2. Update documentation if needed
3. Commit with clear, descriptive messages
4. Push to your fork
5. Create a Pull Request with:
   - Clear description of changes
   - Any related issue numbers
   - Screenshots if UI changes

## Pull Request Guidelines

- Keep changes focused and atomic
- Include tests for new functionality
- Update README.md if adding features
- Ensure no sensitive data in commits

## Questions?

Feel free to open an issue for questions or discussions!
</file>

<file path="docker-compose.yml">
version: '3.8'
services:
  inbox-mcp:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: inbox-mcp-server
    ports:
      - "${PORT:-3000}:3000"
    environment:
      - NODE_ENV=${NODE_ENV:-production}
      - PORT=${PORT:-3000}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    env_file:
      - .env
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
  # Optional: Add a reverse proxy for production use
  # nginx:
  #   image: nginx:alpine
  #   container_name: inbox-mcp-nginx
  #   ports:
  #     - "80:80"
  #     - "443:443"
  #   volumes:
  #     - ./nginx.conf:/etc/nginx/nginx.conf:ro
  #     - ./certs:/etc/nginx/certs:ro
  #   depends_on:
  #     - inbox-mcp
  #   restart: unless-stopped
# Optional: Add a network for isolation
networks:
  default:
    name: inbox-mcp-network
</file>

<file path="Dockerfile">
# ---------- Build stage ----------
FROM node:20-alpine AS build

# Install build dependencies
RUN apk add --no-cache python3 make g++

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install all dependencies (including dev dependencies for building)
RUN npm ci

# Copy source code
COPY src ./src

# Build the TypeScript code
RUN npm run build

# ---------- Runtime stage ----------
FROM node:20-alpine

# Install runtime dependencies
RUN apk add --no-cache tini

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install only production dependencies
RUN npm ci --omit=dev && npm cache clean --force

# Copy built application from build stage
COPY --from=build /app/dist ./dist

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Change ownership of app directory
RUN chown -R nodejs:nodejs /app

# Switch to non-root user
USER nodejs

# Expose the default port
EXPOSE 3000

# Use tini for proper signal handling
ENTRYPOINT ["/sbin/tini", "--"]

# Start the server
CMD ["node", "dist/server.js"]
</file>

<file path="package.json">
{
  "name": "inbox-mcp",
  "version": "1.0.0",
  "description": "Transform your inbox into an intelligent AI assistant. MCP server for email management via Nylas API with natural language processing.",
  "type": "module",
  "main": "dist/server.js",
  "bin": {
    "inbox-mcp": "dist/server.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/inbox-mcp"
  },
  "author": "Your Name",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/yourusername/inbox-mcp/issues"
  },
  "homepage": "https://github.com/yourusername/inbox-mcp#readme",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "tsx watch src/server.ts",
    "dev:stdio": "echo 'stdio mode removed - use HTTP server'",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "jest --config tests/e2e/jest.config.js",
    "test:e2e:interactive": "jest --config tests/e2e/jest.config.js --runInBand",
    "test:e2e:watch": "jest --config tests/e2e/jest.config.js --watch",
    "test:e2e:run": "tsx tests/e2e/run-e2e-tests.ts",
    "test:e2e:onboarding": "jest --config tests/e2e/jest.config.js onboardingFlow",
    "test:approval": "jest --config tests/e2e/jest.config.js --testNamePattern=\"send email with approval flow\"",
    "test:tools": "jest --config tests/e2e/jest.config.js fullRealApiJourney.test.ts toolApprovals.test.ts"
  },
  "files": [
    "dist",
    "README.md"
  ],
  "keywords": [
    "mcp",
    "model-context-protocol",
    "juli",
    "nylas",
    "email",
    "ai",
    "assistant",
    "inbox",
    "gmail",
    "outlook",
    "natural-language",
    "email-management"
  ],
  "dependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "google-auth-library": "^9.14.2",
    "node-fetch": "^3.3.2",
    "nylas": "^7.8.0",
    "openai": "^5.10.2",
    "sanitize-html": "^2.16.0",
    "turndown": "^7.1.1",
    "zod": "^3.25.76",
    "zod-to-json-schema": "^3.24.6"
  },
  "devDependencies": {
    "@jest/globals": "^30.0.5",
    "@types/axios": "^0.14.4",
    "@types/jest": "^30.0.0",
    "@types/node": "^20.4.2",
    "@types/prompts": "^2.4.9",
    "@types/supertest": "^6.0.3",
    "axios": "^1.11.0",
    "jest": "^30.0.5",
    "nodemon": "^3.0.1",
    "prompts": "^2.4.2",
    "supertest": "^7.1.4",
    "ts-jest": "^29.4.0",
    "tsx": "^4.20.3",
    "typescript": "^5.2.2"
  }
}
</file>

<file path="src/tools/manageEmail.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI.js';
// ApprovalManager removed - using stateless approval flow
import {
  ManageEmailParams,
  Email,
  EmailIntent,
  GeneratedEmail,
  ApprovalRequiredResponse
} from '../types/index.js';
export class ManageEmailTool {
  private senderInfo: { email?: string; name?: string } | null = null;
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI,
    private userContext?: { userName?: string; userEmail?: string }
  ) {
    // Initialize sender info from user context if available
    if (userContext?.userName || userContext?.userEmail) {
      this.senderInfo = {
        email: userContext.userEmail || 'sender@email.com',
        name: userContext.userName || (userContext.userEmail ? userContext.userEmail.split('@')[0] : 'Sender')
      };
      console.log('📧 Sender info from context:', this.senderInfo);
    }
  }
  async execute(params: ManageEmailParams): Promise<any> {
    console.log('[manage_email] execute called with action:', params.action, 'require_approval:', params.require_approval);
    // Check if this is an approved action execution
    if (params.approved && params.action_data) {
      return this.executeApprovedAction(params);
    }
    // Get sender info if not cached (skip if already set from context)
    if (!this.senderInfo) {
      await this.fetchSenderInfo();
    }
    try {
      // Process the natural language query
      const context = await this.getContext(params);
      // Fast-path: if the query already contains one or more email addresses and we're not executing immediately,
      // avoid an AI call and synthesize an intent directly.
      const emailMatches = Array.from(params.query.matchAll(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/ig)).map(m => m[0]);
      console.log('[manage_email] detected emails in query:', emailMatches);
      const hasDirectEmails = emailMatches.length > 0;
      if (hasDirectEmails) {
        console.log('🛣️  Fast-path: detected direct email addresses in query → skipping AI intent extraction');
      }
      const intent: EmailIntent = hasDirectEmails ? {
        intent: params.action,
        recipients: emailMatches,
        subject: '',
        key_points: [params.query],
        urgency: 'normal',
        tone: 'professional'
      } as any : await this.emailAI.understandQuery(params.query, context);
      console.log('[manage_email] intent prepared. recipients:', intent.recipients);
      // Generate email content based on intent
      const emailContent = await this.generateContent(intent, params, context);
      console.log('[manage_email] generated content recipients:', emailContent.to);
      // Handle different actions
      switch (params.action) {
        case 'send':
        case 'reply':
        case 'forward':
          if (params.require_approval !== false) {
            return this.createStatelessApprovalRequest(emailContent, params, intent);
          } else {
            return this.sendEmail(emailContent);
          }
        case 'draft':
          return this.createDraft(emailContent);
        default:
          throw new Error(`Unknown action: ${params.action}`);
      }
    } catch (error: any) {
      // Check if it's a contact resolution error
      if (error.message && error.message.includes('Could not find email addresses for:')) {
        // Return a user-friendly error response
        return {
          success: false,
          error: 'contact_not_found',
          message: error.message,
          suggestions: [
            'Use the full email address (e.g., sarah@example.com)',
            'Check if the contact exists in your address book',
            'Try a more specific name if multiple people share the same first name'
          ]
        };
      }
      // Re-throw other errors
      throw error;
    }
  }
  private async getContext(params: ManageEmailParams): Promise<any> {
    if (params.action === 'reply' || params.action === 'forward') {
      let originalMessage: Email | null = null;
      if (params.context_message_id) {
        // Fetch the specific message
        const message = await this.nylas.messages.find({
          identifier: this.grantId,
          messageId: params.context_message_id
        });
        originalMessage = message.data as Email;
      } else if (params.action === 'reply') {
        // Try to find the most recent relevant message
        originalMessage = await this.findRelevantMessage(params.query);
      }
      if (originalMessage && params.action === 'reply') {
        return {
          senderEmail: originalMessage.from[0]?.email,
          originalMessage
        };
      } else if (originalMessage && params.action === 'forward') {
        return { originalMessage };
      }
    }
    return undefined;
  }
  private async findRelevantMessage(query: string): Promise<Email | null> {
    // Extract possible sender names from query
    const senderMatch = query.match(/(?:reply to|respond to)\s+(\w+)/i);
    if (!senderMatch) return null;
    const senderName = senderMatch[1];
    try {
      // First, try to find contacts with this name
      const contacts = await this.lookupContactsByName(senderName);
      if (contacts.length > 0) {
        // Search for messages from the resolved email addresses
        for (const contact of contacts) {
          const messages = await this.nylas.messages.list({
            identifier: this.grantId,
            queryParams: {
              from: [contact.email],
              limit: 5
            }
          });
          if (messages.data.length > 0) {
            // Get full message details
            const fullMessage = await this.nylas.messages.find({
              identifier: this.grantId,
              messageId: messages.data[0].id
            });
            console.log(`✅ Found message from ${contact.name} (${contact.email})`);
            return fullMessage.data as Email;
          }
        }
      }
      // Fallback: Try searching by name in the message content
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: {
          searchQueryNative: `from:${senderName}`,
          limit: 5
        }
      });
      if (messages.data.length > 0) {
        // Get full message details
        const fullMessage = await this.nylas.messages.find({
          identifier: this.grantId,
          messageId: messages.data[0].id
        });
        return fullMessage.data as Email;
      }
    } catch (error) {
      console.error('Error finding relevant message:', error);
    }
    return null;
  }
  private async lookupContactByEmail(email: string): Promise<string | null> {
    try {
      // Search for contacts with the specific email address
      const contacts = await this.nylas.contacts.list({
        identifier: this.grantId,
        queryParams: {
          email: email  // Use Nylas API's email search parameter
        }
      });
      if (contacts.data.length > 0) {
        const matchingContact = contacts.data[0];
        // Build full name from available parts
        const nameParts = [
          matchingContact.givenName,
          matchingContact.middleName,
          matchingContact.surname
        ].filter(Boolean);
        if (nameParts.length > 0) {
          return nameParts.join(' ');
        }
        // Fallback to nickname if no formal name parts
        if (matchingContact.nickname) {
          return matchingContact.nickname;
        }
        // Fallback to display name
        if (matchingContact.displayName && matchingContact.displayName !== email) {
          return matchingContact.displayName;
        }
      }
      // If not found in address book, try inbox source
      const inboxContacts = await this.nylas.contacts.list({
        identifier: this.grantId,
        queryParams: {
          email: email,
          source: 'inbox' as any  // Search contacts from email interactions
        }
      });
      if (inboxContacts.data.length > 0) {
        const contact = inboxContacts.data[0];
        if (contact.displayName && contact.displayName !== email) {
          return contact.displayName;
        }
      }
    } catch (error) {
      console.error('Error looking up contact:', error);
    }
    return null;
  }
  private async lookupContactsByName(name: string): Promise<Array<{ email: string; name: string }>> {
    const results: Array<{ email: string; name: string }> = [];
    const searchName = name.toLowerCase().trim();
    try {
      // Search in all three sources: address_book, domain, and inbox
      const sources = ['address_book', 'domain', 'inbox'] as const;
      for (const source of sources) {
        try {
          // Fetch contacts from each source with a reasonable limit
          const contacts = await this.nylas.contacts.list({
            identifier: this.grantId,
            queryParams: {
              source: source as any,
              limit: 100  // Reasonable limit to avoid too many API calls
            }
          });
          // Search through each contact's name fields
          for (const contact of contacts.data) {
            const emails = contact.emails || [];
            if (emails.length === 0) continue;
            // Build possible name variations to search
            const nameVariations: string[] = [];
            // Full name from parts
            const nameParts = [
              contact.givenName,
              contact.middleName,
              contact.surname
            ].filter(Boolean);
            if (nameParts.length > 0) {
              nameVariations.push(nameParts.join(' '));
            }
            // Individual name parts
            if (contact.givenName) nameVariations.push(contact.givenName);
            if (contact.surname) nameVariations.push(contact.surname);
            if (contact.nickname) nameVariations.push(contact.nickname);
            if (contact.displayName) nameVariations.push(contact.displayName);
            // Check if any name variation matches our search
            const matches = nameVariations.some(variation =>
              variation.toLowerCase().includes(searchName) ||
              searchName.includes(variation.toLowerCase())
            );
            if (matches) {
              // Get the best display name for this contact
              const displayName = contact.displayName ||
                (nameParts.length > 0 ? nameParts.join(' ') : null) ||
                contact.nickname ||
                contact.givenName ||
                emails[0].email;
              // Add all email addresses for this contact
              for (const email of emails) {
                if (email.email) {
                  results.push({
                    email: email.email,
                    name: displayName
                  });
                }
              }
            }
          }
        } catch (error) {
          console.error(`Error fetching contacts from source ${source}:`, error);
          // Continue with other sources even if one fails
        }
      }
      // Remove duplicates based on email
      const uniqueResults = Array.from(
        new Map(results.map(item => [item.email, item])).values()
      );
      return uniqueResults;
    } catch (error) {
      console.error('Error looking up contacts by name:', error);
      return [];
    }
  }
  private async fetchSenderInfo(): Promise<void> {
    try {
      // Fetch grant information to get sender's email
      const grant = await this.nylas.grants.find({
        grantId: this.grantId
      });
      if (grant.data.email) {
        this.senderInfo = {
          email: grant.data.email,
          name: grant.data.email.split('@')[0] // Default to email prefix
        };
        // Try to get the actual name from contacts
        const senderName = await this.lookupContactByEmail(grant.data.email);
        if (senderName) {
          this.senderInfo.name = senderName;
        }
        console.log('📧 Sender info:', this.senderInfo);
      }
    } catch (error) {
      console.error('Error fetching sender info:', error);
      // Default sender info if we can't fetch it
      this.senderInfo = {
        email: 'sender@email.com',
        name: 'Sender'
      };
    }
  }
  private async generateContent(
    intent: EmailIntent,
    params: ManageEmailParams,
    context?: any
  ): Promise<GeneratedEmail> {
    const originalMessage = context?.originalMessage;
    // First, resolve any name-based recipients to email addresses
    const resolvedRecipients: string[] = [];
    const unresolvedNames: string[] = [];
    if (intent.recipients && intent.recipients.length > 0) {
      for (const recipient of intent.recipients) {
        // If full email is provided, accept it without contact lookups
        if (recipient.includes('@')) {
          resolvedRecipients.push(recipient);
          continue;
        }
        // Name-only: attempt contact resolution, but handle lack of scopes gracefully
        try {
          const contacts = await this.lookupContactsByName(recipient);
          if (contacts.length === 0) {
            unresolvedNames.push(recipient);
          } else if (contacts.length === 1) {
            resolvedRecipients.push(contacts[0].email);
            console.log(`✅ Resolved "${recipient}" to ${contacts[0].email}`);
          } else {
            resolvedRecipients.push(contacts[0].email);
            console.log(`⚠️ Multiple contacts found for "${recipient}", using ${contacts[0].email}`);
            console.log('Other matches:', contacts.slice(1).map(c => `${c.name} (${c.email})`).join(', '));
          }
        } catch (err: any) {
          // If contacts API is forbidden due to missing scopes, treat as unresolved
          if (err?.statusCode === 403 || /insufficient authentication scopes/i.test(err?.message || '')) {
            unresolvedNames.push(recipient);
          } else {
            throw err;
          }
        }
      }
    }
    // If we couldn't resolve some names, throw an error
    if (unresolvedNames.length > 0) {
      throw new Error(`Could not find email addresses for: ${unresolvedNames.join(', ')}. Please use full email addresses or ensure the contacts exist in your address book.`);
    }
    // Update intent with resolved email addresses
    intent.recipients = resolvedRecipients;
    // Fast-path: if we have concrete recipients and this is an approval/draft flow,
    // synthesize a reasonable email without invoking the AI to avoid external failures.
    if (params.require_approval !== false && intent.recipients.length > 0) {
      const synthetic: GeneratedEmail = {
        to: intent.recipients,
        cc: undefined,
        bcc: undefined,
        subject: intent.subject || 'Review email draft',
        body: `Hello,\n\n${intent.key_points?.join(' ') || 'Here is a proposed message.'}\n\nBest,\n${this.senderInfo?.name || 'Me'}`,
        tone_confirmation: undefined
      } as GeneratedEmail;
      // Add reply/forward context if applicable
      if (params.action === 'reply' && originalMessage) {
        (synthetic as any).in_reply_to = originalMessage.id;
        if (!synthetic.subject.startsWith('Re:')) {
          synthetic.subject = `Re: ${originalMessage.subject}`;
        }
      } else if (params.action === 'forward' && originalMessage) {
        if (!synthetic.subject.startsWith('Fwd:')) {
          synthetic.subject = `Fwd: ${originalMessage.subject}`;
        }
        synthetic.body += `\n\n--- Original Message ---\n${originalMessage.body || originalMessage.snippet}`;
      }
      return synthetic;
    }
    // Lookup contact names for recipients (to get proper display names)
    const recipientNames: { [email: string]: string } = {};
    if (intent.recipients && intent.recipients.length > 0) {
      await Promise.all(
        intent.recipients.map(async (email) => {
          const contactName = await this.lookupContactByEmail(email);
          if (contactName) {
            recipientNames[email] = contactName;
          }
        })
      );
    }
    let generatedEmail: GeneratedEmail;
    try {
      generatedEmail = await this.emailAI.generateEmailContent(
        intent,
        originalMessage,
        recipientNames,
        this.senderInfo
      );
    } catch (err: any) {
      console.error('AI content generation failed, using fallback:', err?.message || err);
      generatedEmail = {
        to: intent.recipients,
        subject: intent.subject || 'Draft email',
        body: `Hello,\n\n${intent.key_points?.join(' ') || 'Here is my message.'}\n\nBest,\n${this.senderInfo?.name || 'Me'}`,
        cc: undefined,
        bcc: undefined,
        tone_confirmation: undefined
      } as GeneratedEmail;
    }
    // Add reply/forward specific handling
    if (params.action === 'reply' && originalMessage) {
      generatedEmail.in_reply_to = originalMessage.id;
      if (!generatedEmail.subject.startsWith('Re:')) {
        generatedEmail.subject = `Re: ${originalMessage.subject}`;
      }
    } else if (params.action === 'forward' && originalMessage) {
      if (!generatedEmail.subject.startsWith('Fwd:')) {
        generatedEmail.subject = `Fwd: ${originalMessage.subject}`;
      }
      // Append original message to body
      generatedEmail.body += `\n\n--- Original Message ---\n${originalMessage.body || originalMessage.snippet}`;
    }
    return generatedEmail;
  }
  private async createStatelessApprovalRequest(
    emailContent: GeneratedEmail,
    params: ManageEmailParams,
    intent: EmailIntent
  ): Promise<ApprovalRequiredResponse> {
    return {
      needs_approval: true,
      action_type: 'send_email',
      action_data: {
        email_content: emailContent,
        original_params: {
          action: params.action,
          query: params.query,
          context_message_id: params.context_message_id
        },
        intent: intent
      },
      preview: {
        summary: `${params.action.charAt(0).toUpperCase() + params.action.slice(1)} email to ${emailContent.to.join(', ')}`,
        details: {
          to: emailContent.to,
          cc: emailContent.cc,
          bcc: emailContent.bcc,
          subject: emailContent.subject,
          body: emailContent.body,
          action: params.action,
          tone: intent.tone,
          urgency: intent.urgency
        },
        risks: this.assessEmailRisks(emailContent, params)
      }
    };
  }
  private assessEmailRisks(emailContent: GeneratedEmail, params: ManageEmailParams): string[] {
    const risks: string[] = [];
    // Check for multiple recipients
    const totalRecipients = emailContent.to.length +
      (emailContent.cc?.length || 0) +
      (emailContent.bcc?.length || 0);
    if (totalRecipients > 5) {
      risks.push(`Sending to ${totalRecipients} recipients`);
    }
    // Check for external domains
    const internalDomain = process.env.INTERNAL_EMAIL_DOMAIN;
    if (internalDomain) {
      const externalRecipients = emailContent.to.filter(email =>
        !email.endsWith(`@${internalDomain}`)
      );
      if (externalRecipients.length > 0) {
        risks.push('Contains external recipients');
      }
    }
    // Check for reply-all scenarios
    if (params.action === 'reply' && totalRecipients > 2) {
      risks.push('Reply-all to multiple recipients');
    }
    return risks;
  }
  private async executeApprovedAction(params: ManageEmailParams): Promise<any> {
    if (!params.action_data?.email_content) {
      throw new Error('Missing email content in approved action');
    }
    const { email_content } = params.action_data;
    try {
      const result = await this.sendEmail(email_content);
      return {
        ...result,
        approval_executed: true
      };
    } catch (error: any) {
      throw new Error(`Failed to execute approved email action: ${error.message}`);
    }
  }
  // Legacy approval request method removed
  private async sendEmail(emailContent: GeneratedEmail): Promise<any> {
    try {
      // Simple HTML: just replace newlines with <br> tags
      const htmlBody = emailContent.body
        .replace(/\n\n/g, '<br><br>')  // Double newline = paragraph break
        .replace(/\n/g, '<br>');        // Single newline = line break
      const message = await this.nylas.messages.send({
        identifier: this.grantId,
        requestBody: {
          to: emailContent.to.map(email => ({ email })),
          cc: emailContent.cc?.map(email => ({ email })),
          bcc: emailContent.bcc?.map(email => ({ email })),
          subject: emailContent.subject,
          body: htmlBody,
          replyToMessageId: emailContent.in_reply_to
        }
      });
      return {
        success: true,
        message_id: message.data.id,
        message: 'Email sent successfully'
      };
    } catch (error: any) {
      throw new Error(`Failed to send email: ${error.message}`);
    }
  }
  private async createDraft(emailContent: GeneratedEmail): Promise<any> {
    try {
      // Simple HTML: just replace newlines with <br> tags
      const htmlBody = emailContent.body
        .replace(/\n\n/g, '<br><br>')  // Double newline = paragraph break
        .replace(/\n/g, '<br>');        // Single newline = line break
      const draft = await this.nylas.drafts.create({
        identifier: this.grantId,
        requestBody: {
          to: emailContent.to.map(email => ({ email })),
          cc: emailContent.cc?.map(email => ({ email })),
          bcc: emailContent.bcc?.map(email => ({ email })),
          subject: emailContent.subject,
          body: htmlBody
        }
      });
      return {
        success: true,
        draft_id: draft.data.id,
        message: 'Draft created successfully'
      };
    } catch (error: any) {
      throw new Error(`Failed to create draft: ${error.message}`);
    }
  }
}
</file>

<file path="src/server.ts">
#!/usr/bin/env node
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import Nylas from 'nylas';
import { OAuth2Client } from 'google-auth-library';
// Import our components
import { EmailAI } from './ai/emailAI.js';
// ApprovalManager removed - using stateless approval flow
import { SetupManager } from './setup/setupManager.js';
import { ManageEmailTool } from './tools/manageEmail.js';
import { FindEmailsTool } from './tools/findEmails.js';
import { OrganizeInboxTool } from './tools/organizeInbox.js';
import { EmailInsightsTool } from './tools/emailInsights.js';
import { SmartFoldersTool } from './tools/smartFolders.js';
// Import types
import {
  ManageEmailParams,
  FindEmailsParams,
  OrganizeInboxParams,
  EmailInsightsParams,
  SmartFoldersParams,
  SetupResponse
} from './types/index.js';
// Zod schemas for our AI-powered tools
const ManageEmailSchema = z.object({
  action: z.enum(['send', 'reply', 'forward', 'draft']).describe('Choose send for new emails, reply to respond to someone, forward to share an email, or draft to save without sending'),
  query: z.string().describe('Describe what you want in the email. Be natural! Examples: "tell John I\'ll be late to the meeting", "thank Sarah for the proposal and ask about pricing", "forward this to the team with my thoughts"'),
  context_message_id: z.string().optional().describe('Email ID if replying/forwarding (I\'ll find it if you don\'t provide it)'),
  require_approval: z.boolean().optional().default(true).describe('Show preview before sending (default: true for safety)'),
  // Context injection fields from Juli
  user_name: z.string().optional().describe('User\'s name from context injection'),
  user_email: z.string().optional().describe('User\'s email from context injection'),
  // Stateless approval fields
  approved: z.boolean().optional().describe('Whether this is an approved action execution'),
  action_data: z.object({
    email_content: z.any(),
    original_params: z.any()
  }).optional().describe('Complete action data for approved execution')
}).describe('Compose emails naturally - just tell me what you want to say and I\'ll write a professional email. Works for new emails, replies, and forwards.');
const FindEmailsSchema = z.object({
  query: z.string().describe('Describe what emails you\'re looking for in plain English. Examples: "unread emails from my boss", "invoices from last month", "anything I need to respond to today", "emails about the Q3 project"'),
  analysis_type: z.enum(['full', 'summary', 'detailed', 'action_items', 'priority']).optional().default('summary')
    .describe('How much detail you want: summary (quick overview), full (complete emails), detailed (emails + importance analysis), action_items (emails + tasks to do), priority (emails sorted by importance)'),
  limit: z.number().optional().default(20).describe('How many emails to return (default: 20)')
}).describe('Search your emails naturally and get exactly what you need - from quick summaries to detailed analysis with action items.');
const OrganizeInboxSchema = z.object({
  instruction: z.string().describe('Tell me how you want to organize your emails. Examples: "archive all newsletters older than a week", "star important emails from clients", "clean up promotional emails", "organize by project", "file all receipts"'),
  scope: z.object({
    folder: z.string().optional().default('inbox').describe('Which folder to organize (default: inbox)'),
    date_range: z.string().optional().describe('Time range like "last week" or "older than 30 days"'),
    limit: z.number().optional().default(100).describe('Max emails to process at once')
  }).optional().describe('Scope of organization'),
  dry_run: z.boolean().optional().default(true).describe('Preview what will happen before making changes (default: true for safety)'),
  // New stateless approval fields
  approved: z.boolean().optional().describe('Whether this is an approved action execution'),
  action_data: z.object({
    organization_plan: z.any(),
    original_params: z.any()
  }).optional().describe('Complete action data for approved execution')
}).describe('Clean up and organize your inbox intelligently. Tell me what you want to do and I\'ll handle the details - always with a preview first.');
const EmailInsightsSchema = z.object({
  query: z.string()
    .describe('Natural language request for email insights. Examples: "summarize my emails today", "what emails need my response?", "show me email analytics for this week", "who am I communicating with most?", "what important emails did I get this week?"'),
  time_period: z.string().optional().default('today')
    .describe('Time period in natural language like "today", "this week", "last month"')
}).describe('Get AI-powered insights and summaries about your email patterns, important items, and what needs attention');
const SmartFoldersSchema = z.object({
  query: z.string().describe('Describe what you want to do with folders. Examples: "create a folder for urgent client emails", "set up folders for each project", "make a folder for receipts and invoices", "show me my folders"'),
  folder_name: z.string().optional().describe('Name for the folder (I\'ll suggest one if you don\'t specify)'),
  dry_run: z.boolean().optional().default(true).describe('Preview the folder rules before creating (default: true)'),
  // New stateless approval fields
  approved: z.boolean().optional().describe('Whether this is an approved action execution'),
  action_data: z.object({
    folder_plan: z.any(),
    original_params: z.any()
  }).optional().describe('Complete action data for approved execution')
}).describe('Create smart folders that automatically organize emails based on your rules. Just describe what should go in the folder and I\'ll set it up.');
// Middleware to extract credentials from headers
interface UserCredentials {
  nylasGrantId?: string;
}
function extractCredentials(headers: any): UserCredentials {
  const credentials: UserCredentials = {};
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase().startsWith('x-user-credential-')) {
      const credKey = key.toLowerCase()
        .replace('x-user-credential-', '')
        .replace(/-/g, '_')
        .toUpperCase();
      switch (credKey) {
        case 'NYLAS_GRANT_ID':
          credentials.nylasGrantId = value as string;
          break;
      }
    }
  }
  return credentials;
}
// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;
const SERVICE_VERSION = '2.0.0';
// Middleware
app.use(cors());
app.use(express.json());
// Request context
interface RequestContext {
  userId?: string;
  requestId?: string;
  credentials: UserCredentials;
}
// Middleware to create request context
app.use((req, res, next) => {
  const context: RequestContext = {
    userId: req.headers['x-platform-user-id'] as string,
    requestId: req.headers['x-platform-request-id'] as string,
    credentials: extractCredentials(req.headers)
  };
  res.locals.context = context;
  next();
});
// Logger for server
const logger = {
  log: console.log,
  error: console.error,
  warn: console.warn
};
// Helper to build a Hosted Auth URL (no redirect)
function buildHostedAuthUrl(params: {
  requestBase: string;
  scope?: string;
  prompt?: string;
  loginHint?: string;
  redirectUriOverride?: string;
}): string {
  if (!NYLAS_API_KEY || !NYLAS_CLIENT_ID) {
    throw new Error('NYLAS_API_KEY and NYLAS_CLIENT_ID must be set');
  }
  const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
  const redirect = params.redirectUriOverride || `${params.requestBase}/api/nylas-email/callback`;
  const rawScope = params.scope || '';
  const scope = rawScope
    ? rawScope.split(',').map((s) => s.trim()).filter(Boolean)
    : undefined;
  const authUrl = (nylas as any).auth.urlForOAuth2({
    clientId: NYLAS_CLIENT_ID,
    redirectUri: redirect,
    ...(params.loginHint ? { loginHint: params.loginHint } : {}),
    ...(params.prompt ? { prompt: params.prompt } : {}),
    ...(scope ? { scope } : {})
  });
  return authUrl;
}
// --- Nylas Hosted Auth routes ---
// Environment-driven configuration
const NYLAS_API_KEY = process.env.NYLAS_API_KEY;
const NYLAS_CLIENT_ID = process.env.NYLAS_CLIENT_ID;
const NYLAS_CALLBACK_URI = process.env.NYLAS_CALLBACK_URI;
const NYLAS_API_URI = process.env.NYLAS_API_URI; // optional (defaults to US)
// --- A2A (Agent-to-Agent) configuration ---
const A2A_AUDIENCE = process.env.A2A_AUDIENCE || '';
const A2A_DEV_SHARED_SECRET = process.env.A2A_DEV_SHARED_SECRET || '';
const A2A_TRUSTED_ISSUERS = ['https://accounts.google.com', 'accounts.google.com'];
const oidcClient = new OAuth2Client();
async function authenticateAgent(req: express.Request): Promise<{ sub?: string; email?: string } | null> {
  const authz = req.headers['authorization'] as string | undefined;
  // Primary: OIDC Bearer token
  if (authz && authz.toLowerCase().startsWith('bearer ')) {
    const idToken = authz.slice(7).trim();
    try {
      const ticket = await oidcClient.verifyIdToken({ idToken, audience: A2A_AUDIENCE || undefined });
      const payload = ticket.getPayload();
      if (payload && (!payload.iss || A2A_TRUSTED_ISSUERS.includes(String(payload.iss)))) {
        return { sub: payload.sub, email: (payload.email as string) };
      }
    } catch (err) {
      // fall through to dev secret
    }
  }
  // Dev fallback: shared secret header
  const devSecret = req.headers['x-a2a-dev-secret'] as string | undefined;
  if (A2A_DEV_SHARED_SECRET && devSecret && devSecret === A2A_DEV_SHARED_SECRET) {
    return { sub: 'dev-agent', email: 'dev@local' };
  }
  return null;
}
function buildA2ACapabilities() {
  return [
    {
      name: 'manage_email',
      description: ManageEmailSchema.description,
      input_schema: (() => {
        const schema = zodToJsonSchema(ManageEmailSchema) as any;
        if (schema.properties) {
          schema.properties.user_name = {
            ...schema.properties.user_name,
            'x-context-injection': 'user_name'
          };
          schema.properties.user_email = {
            ...schema.properties.user_email,
            'x-context-injection': 'user_email'
          };
        }
        return schema;
      })()
    },
    { name: 'find_emails', description: FindEmailsSchema.description, input_schema: zodToJsonSchema(FindEmailsSchema) },
    { name: 'organize_inbox', description: OrganizeInboxSchema.description, input_schema: zodToJsonSchema(OrganizeInboxSchema) },
    { name: 'email_insights', description: EmailInsightsSchema.description, input_schema: zodToJsonSchema(EmailInsightsSchema) },
    { name: 'smart_folders', description: SmartFoldersSchema.description, input_schema: zodToJsonSchema(SmartFoldersSchema) }
  ];
}
function buildAgentCard(req: express.Request) {
  const baseUrl = `${req.protocol}://${req.get('host')}`;
  const authSchemes: any[] = [
    {
      type: 'oidc',
      audience: A2A_AUDIENCE || baseUrl,
      issuers: A2A_TRUSTED_ISSUERS
    }
  ];
  if (A2A_DEV_SHARED_SECRET) {
    authSchemes.push({ type: 'shared_secret', header: 'X-A2A-Dev-Secret' });
  }
  const card: any = {
    agent_id: 'inbox-mcp',
    version: SERVICE_VERSION,
    description: 'Email agent that can compose, find, organize, and analyze email. Supports approval-first execution and agent-to-agent auth.',
    auth: authSchemes.length === 1 ? authSchemes[0] : { schemes: authSchemes },
    approvals: { modes: ['stateless_preview_then_approve'] },
    context_requirements: { credentials: ['EMAIL_ACCOUNT_GRANT'] },
    capabilities: buildA2ACapabilities(),
    rpc: { endpoint: '/a2a/rpc' },
    extensions: {
      'x-juli': {
        credentials_manifest: '/.well-known/a2a-credentials.json'
      }
    }
  };
  return card;
}
// GET /nylas/auth - Redirect user to Nylas Hosted Auth
// Optional query params:
//   login_hint: prefill user email
//   prompt: customize provider selection UI (e.g., detect,select_provider)
//   scope: comma-separated scopes list
//   redirect_uri: override callback (falls back to env)
app.get('/nylas/auth', (req, res) => {
  try {
    if (!NYLAS_API_KEY || !NYLAS_CLIENT_ID || (!NYLAS_CALLBACK_URI && !req.query.redirect_uri)) {
      return res.status(500).json({
        error: 'Server is not configured for Hosted Auth. Set NYLAS_API_KEY, NYLAS_CLIENT_ID, and NYLAS_CALLBACK_URI.'
      });
    }
    const requestBase = `${req.protocol}://${req.get('host')}`;
    const authUrl = buildHostedAuthUrl({
      requestBase,
      scope: (req.query.scope as string) || '',
      prompt: (req.query.prompt as string) || undefined,
      loginHint: (req.query.login_hint as string) || undefined,
      redirectUriOverride: (req.query.redirect_uri as string) || NYLAS_CALLBACK_URI
    });
    // Default to HTTP redirect; support JSON via ?return=json
    if (req.query.return === 'json') {
      return res.json({ url: authUrl });
    }
    res.redirect(authUrl);
  } catch (error: any) {
    logger.error('Error generating Hosted Auth URL:', error);
    res.status(500).json({ error: error.message || 'Failed to generate Hosted Auth URL' });
  }
});
// GET /setup/connect-url - Return Hosted Auth URL as JSON (no redirect)
app.get('/setup/connect-url', (req, res) => {
  try {
    const requestBase = `${req.protocol}://${req.get('host')}`;
    const url = buildHostedAuthUrl({
      requestBase,
      scope: (req.query.scope as string) || '',
      prompt: (req.query.prompt as string) || undefined,
      loginHint: (req.query.login_hint as string) || undefined,
      redirectUriOverride: (req.query.redirect_uri as string) || NYLAS_CALLBACK_URI
    });
    res.json({ url });
  } catch (error: any) {
    logger.error('Error building connect URL:', error);
    res.status(500).json({ error: error.message || 'Failed to build connect URL' });
  }
});
// GET /api/nylas-email/callback - OAuth callback to exchange code for grant_id
app.get('/api/nylas-email/callback', async (req, res) => {
  try {
    if (!NYLAS_API_KEY || !NYLAS_CLIENT_ID || !NYLAS_CALLBACK_URI) {
      return res.status(500).json({
        error: 'Server is not configured for Hosted Auth. Set NYLAS_API_KEY, NYLAS_CLIENT_ID, and NYLAS_CALLBACK_URI.'
      });
    }
    const code = req.query.code as string | undefined;
    if (!code) {
      return res.status(400).json({ error: 'Missing authorization code in callback' });
    }
    const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
    // Use the exact callback URL that the user hit to avoid mismatch
    const requestBase = `${req.protocol}://${req.get('host')}`;
    const effectiveRedirectUri = `${requestBase}${req.path}`;
    // Perform code exchange
    const response = await (nylas as any).auth.exchangeCodeForToken({
      clientSecret: NYLAS_API_KEY,
      clientId: NYLAS_CLIENT_ID,
      redirectUri: effectiveRedirectUri || NYLAS_CALLBACK_URI,
      code
    });
    // Normalized output
    const grantId = response?.grantId || response?.grant_id;
    const email = response?.email || response?.data?.email;
    if (!grantId) {
      return res.status(500).json({ error: 'No grant_id returned from Nylas' });
    }
    // Return the grant so the client can store and inject it on future requests
    res.json({
      success: true,
      grant_id: grantId,
      email,
      message: 'Connected successfully. Store grant_id and start calling the email tools.'
    });
  } catch (error: any) {
    logger.error('OAuth callback error:', error);
    res.status(500).json({ error: error.message || 'Failed to complete OAuth exchange' });
  }
});
// GET /mcp/tools - List available tools
/* Deprecated MCP endpoint removed: use A2A discovery and RPC */
/* app.get('/mcp/tools', (req, res) => {
  const context: RequestContext = res.locals.context;
  const hasCredentials = !!(NYLAS_API_KEY && context.credentials.nylasGrantId);
  // Instrumentation: log credential presence for troubleshooting
  try {
    const maskedGrant = context.credentials.nylasGrantId
      ? `${context.credentials.nylasGrantId.slice(0, 8)}…`
      : 'none';
    console.log(
      `[mcp/tools] env.NYLAS_API_KEY: ${NYLAS_API_KEY ? 'present' : 'missing'}, header.NYLAS_GRANT_ID: ${maskedGrant}, hasCredentials: ${hasCredentials}`
    );
  } catch (_) {
    // no-op
  }
  const tools = [];
  // Only include email tools if credentials are present
  if (hasCredentials) {
    tools.push(
      {
        name: "manage_email",
        description: ManageEmailSchema.description,
        inputSchema: (() => {
          const schema = zodToJsonSchema(ManageEmailSchema) as any;
          // Add context injection annotations for Juli
          if (schema.properties) {
            schema.properties.user_name = {
              ...schema.properties.user_name,
              'x-context-injection': 'user_name'
            };
            schema.properties.user_email = {
              ...schema.properties.user_email,
              'x-context-injection': 'user_email'
            };
          }
          return schema;
        })()
      },
      {
        name: "find_emails",
        description: FindEmailsSchema.description,
        inputSchema: zodToJsonSchema(FindEmailsSchema)
      },
      {
        name: "organize_inbox",
        description: OrganizeInboxSchema.description,
        inputSchema: zodToJsonSchema(OrganizeInboxSchema)
      },
      {
        name: "email_insights",
        description: EmailInsightsSchema.description,
        inputSchema: zodToJsonSchema(EmailInsightsSchema)
      },
      {
        name: "smart_folders",
        description: SmartFoldersSchema.description,
        inputSchema: zodToJsonSchema(SmartFoldersSchema)
      }
    );
  }
  res.json({ tools });
}); */
// POST /mcp/tools/:toolName - Execute a tool
/* Deprecated MCP endpoint removed: use /a2a/rpc */
/* app.post('/mcp/tools/:toolName', async (req, res) => {
  const { toolName } = req.params;
  const { arguments: args } = req.body;
  const context: RequestContext = res.locals.context;
  // Instrumentation: log tool execution with credential presence
  try {
    const maskedGrant = context.credentials.nylasGrantId
      ? `${context.credentials.nylasGrantId.slice(0, 8)}…`
      : 'none';
    console.log(
      `Executing ${toolName} | env.NYLAS_API_KEY: ${NYLAS_API_KEY ? 'present' : 'missing'}, header.NYLAS_GRANT_ID: ${maskedGrant}, user: ${context.userId || 'unknown'}, reqId: ${context.requestId || 'n/a'}`
    );
  } catch (_) {
    // no-op
  }
  try {
    let result: any;
    switch (toolName) {
      case 'manage_email': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = ManageEmailSchema.parse(args) as ManageEmailParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new ManageEmailTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI,
          { userName: params.user_name, userEmail: params.user_email }
        );
        result = await tool.execute(params);
        break;
      }
      case 'find_emails': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = FindEmailsSchema.parse(args) as FindEmailsParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new FindEmailsTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      case 'organize_inbox': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = OrganizeInboxSchema.parse(args) as OrganizeInboxParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new OrganizeInboxTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      case 'email_insights': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = EmailInsightsSchema.parse(args) as EmailInsightsParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new EmailInsightsTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      case 'smart_folders': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = SmartFoldersSchema.parse(args) as SmartFoldersParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new SmartFoldersTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      default:
        return res.status(404).json({ error: `Unknown tool: ${toolName}` });
    }
    res.json({ result });
  } catch (error: any) {
    console.error(`Error executing ${toolName}:`, error);
    let errorMessage = error.message;
    let statusCode = 500;
    if (error instanceof z.ZodError) {
      errorMessage = `Input validation error: ${error.errors.map(e =>
        `${e.path.join('.')}: ${e.message}`
      ).join(', ')}`;
      statusCode = 400;
    } else if (error.message.includes('Missing') || error.message.includes('not connected')) {
      statusCode = 401;
    }
    res.status(statusCode).json({
      error: errorMessage,
      code: error.code || 'TOOL_EXECUTION_ERROR'
    });
  }
}); */
// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'inbox-mcp',
    version: SERVICE_VERSION,
    transport: 'http'
  });
});
// --- A2A routes ---
app.get('/.well-known/a2a.json', (req, res) => {
  res.json(buildAgentCard(req));
});
function buildCredentialsManifest() {
  return {
    credentials: [
      {
        key: 'EMAIL_ACCOUNT_GRANT',
        display_name: 'Email Account Grant',
        sensitive: true,
        notes: 'Opaque user grant for mailbox access; inject on every execute/approve call.',
        flows: [
          {
            type: 'hosted_auth',
            connect_url: '/setup/connect-url',
            callback: '/api/nylas-email/callback',
            provider_scopes: {
              google: [
                'openid',
                'https://www.googleapis.com/auth/userinfo.email',
                'https://www.googleapis.com/auth/userinfo.profile',
                'https://www.googleapis.com/auth/gmail.modify',
                'https://www.googleapis.com/auth/contacts',
                'https://www.googleapis.com/auth/contacts.readonly',
                'https://www.googleapis.com/auth/contacts.other.readonly'
              ],
              microsoft: [
                'Mail.ReadWrite',
                'Mail.Send',
                'Contacts.Read',
                'Contacts.Read.Shared'
              ]
            }
          }
        ]
      }
    ]
  };
}
app.get('/.well-known/a2a-credentials.json', (_req, res) => {
  res.json(buildCredentialsManifest());
});
// Removed REST A2A endpoints; JSON-RPC is the canonical transport.
// --- A2A JSON-RPC 2.0 endpoint (alignment with A2A JSON-RPC transport) ---
// Supported methods:
// - agent.card
// - agent.handshake
// - tool.execute
// - tool.approve
app.post('/a2a/rpc', async (req, res) => {
  const agent = await authenticateAgent(req);
  if (!agent) return res.status(401).json({ jsonrpc: '2.0', id: null, error: { code: 401, message: 'unauthorized_agent' } });
  const handleSingle = async (rpcReq: any) => {
    const id = rpcReq.id ?? null;
    const versionOk = rpcReq.jsonrpc === '2.0';
    const method = rpcReq.method as string;
    const params = rpcReq.params || {};
    if (!versionOk || !method) {
      return { jsonrpc: '2.0', id, error: { code: -32600, message: 'Invalid Request' } };
    }
    try {
      switch (method) {
        case 'agent.card': {
          return { jsonrpc: '2.0', id, result: buildAgentCard(req) };
        }
        case 'agent.handshake': {
          return { jsonrpc: '2.0', id, result: { agent: { sub: agent.sub, email: agent.email }, card: buildAgentCard(req), server_time: new Date().toISOString() } };
        }
        case 'tool.execute': {
          const { tool, arguments: args, user_context, request_id } = params;
          const nylasGrantId = user_context?.credentials?.EMAIL_ACCOUNT_GRANT || user_context?.credentials?.NYLAS_GRANT_ID || user_context?.credentials?.nylas_grant_id;
          if (!NYLAS_API_KEY || !nylasGrantId) {
            return { jsonrpc: '2.0', id, error: { code: 401, message: 'missing_credentials', data: { hint: '/.well-known/a2a-credentials.json' } } };
          }
          const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
          const emailAI = new EmailAI();
          let result: any;
          switch (tool) {
            case 'manage_email': {
              const typed = ManageEmailSchema.parse(args) as ManageEmailParams;
              const exec = new ManageEmailTool(nylas, nylasGrantId, emailAI, { userName: typed.user_name, userEmail: typed.user_email });
              result = await exec.execute(typed);
              break;
            }
            case 'find_emails': {
              const typed = FindEmailsSchema.parse(args) as FindEmailsParams;
              const exec = new FindEmailsTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            case 'organize_inbox': {
              const typed = OrganizeInboxSchema.parse(args) as OrganizeInboxParams;
              const exec = new OrganizeInboxTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            case 'email_insights': {
              const typed = EmailInsightsSchema.parse(args) as EmailInsightsParams;
              const exec = new EmailInsightsTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            case 'smart_folders': {
              const typed = SmartFoldersSchema.parse(args) as SmartFoldersParams;
              const exec = new SmartFoldersTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            default:
              return { jsonrpc: '2.0', id, error: { code: 404, message: 'unknown_tool', data: { tool } } };
          }
          return { jsonrpc: '2.0', id, result: { request_id, result } };
        }
        case 'tool.approve': {
          const { tool, original_arguments, action_data, user_context, request_id } = params;
          const nylasGrantId = user_context?.credentials?.EMAIL_ACCOUNT_GRANT || user_context?.credentials?.NYLAS_GRANT_ID || user_context?.credentials?.nylas_grant_id;
          if (!NYLAS_API_KEY || !nylasGrantId) {
            return { jsonrpc: '2.0', id, error: { code: 401, message: 'missing_credentials', data: { hint: '/.well-known/a2a-credentials.json' } } };
          }
          if (tool !== 'manage_email') {
            return { jsonrpc: '2.0', id, error: { code: 400, message: 'approval_not_supported_for_tool', data: { tool } } };
          }
          const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
          const emailAI = new EmailAI();
          const typed = ManageEmailSchema.parse({ ...(original_arguments || {}), approved: true, action_data }) as ManageEmailParams;
          const exec = new ManageEmailTool(nylas, nylasGrantId, emailAI, { userName: typed.user_name, userEmail: typed.user_email });
          const result = await exec.execute(typed);
          return { jsonrpc: '2.0', id, result: { request_id, result } };
        }
        default:
          return { jsonrpc: '2.0', id, error: { code: -32601, message: 'Method not found' } };
      }
    } catch (err: any) {
      if (err instanceof z.ZodError) {
        return { jsonrpc: '2.0', id, error: { code: -32602, message: 'Invalid params', data: err.errors } };
      }
      return { jsonrpc: '2.0', id, error: { code: -32000, message: err?.message || 'Internal error' } };
    }
  };
  const body = req.body;
  if (Array.isArray(body)) {
    const results = await Promise.all(body.map(handleSingle));
    return res.json(results);
  } else {
    const result = await handleSingle(body);
    return res.json(result);
  }
});
// GET /mcp/needs-setup - Check if setup is required
app.get('/setup/status', (req, res) => {
  const context: RequestContext = res.locals.context;
  const hasCredentials = !!(NYLAS_API_KEY && context.credentials.nylasGrantId);
  const requestBase = `${req.protocol}://${req.get('host')}`;
  const defaultConnectUrl = `${requestBase}/setup/connect-url`;
  res.json({
    needs_setup: !hasCredentials,
    has_credentials: hasCredentials,
    setup_url: '/setup/instructions',
    connect_url: defaultConnectUrl
  });
});
// Setup endpoints - separate from MCP tools
app.post('/setup/validate', async (req, res) => {
  try {
    const { nylas_api_key, nylas_grant_id } = req.body;
    if (!nylas_api_key || !nylas_grant_id) {
      return res.status(400).json({
        success: false,
        error: 'Missing required credentials: nylas_api_key and nylas_grant_id'
      });
    }
    // Validate credentials using SetupManager
    const setupManager = new SetupManager();
    const result = await setupManager.validateCredentials({
      nylas_api_key,
      nylas_grant_id
    });
    res.json(result);
  } catch (error: any) {
    logger.error('Setup validation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
app.get('/setup/instructions', (req, res) => {
  res.json({
    type: 'setup_instructions',
    steps: [
      {
        step: 1,
        title: "Create Your Free Nylas Account",
        description: "Nylas provides 5 free email connections - perfect for personal use!",
        action: {
          type: "link",
          label: "Open Nylas Signup",
          url: "https://dashboard-v3.nylas.com/register?utm_source=juli"
        }
      },
      {
        step: 2,
        title: "Get Your API Key",
        description: "After signing in, find your API key in the dashboard",
        details: "Look for 'API Keys' in the left sidebar. The key starts with 'nyk_'"
      },
      {
        step: 3,
        title: "Connect Your Email Account",
        description: "Add your email account to Nylas",
        details: [
          "Click 'Grants' in the sidebar",
          "Click 'Add Test Grant' button",
          "Choose your email provider",
          "Authorize Nylas to access your email",
          "Copy the Grant ID that appears"
        ]
      }
    ],
    next_action: {
      description: "Once you have both credentials, validate them",
      endpoint: "POST /setup/validate",
      body: {
        nylas_api_key: "your_key_here",
        nylas_grant_id: "your_grant_id_here"
      }
    },
    documentation: "https://developer.nylas.com/docs/v3/"
  });
});
// Start server
app.listen(PORT, () => {
  console.log(`Inbox MCP HTTP server running on port ${PORT}`);
  console.log(`Available endpoints:`);
  console.log(`  GET  /health - Health check`);
  console.log(`  GET  /setup/status - Check if setup is required`);
  console.log(`  GET  /setup/instructions - Get setup instructions`);
  console.log(`  POST /setup/validate - Validate Nylas credentials`);
});
</file>

<file path="tests/e2e/utils/config.ts">
/**
 * Configuration for E2E tests
 * Provides test credentials and server configuration
 */
export interface E2EConfig {
  server: {
    url: string;
    port: number;
  };
  nylas?: {
    nylasGrantId: string;
  };
  testTimeout: number;
  logging: {
    verbose: boolean;        // Detailed logging for all operations
    logApiCalls: boolean;    // Log all API requests/responses
    logTimings: boolean;     // Log operation timings
    saveResponses: boolean;  // Save API responses to files
  };
  testData: {
    testEmailPrefix: string; // e.g., "[E2E-TEST]"
    cleanupAfterTest: boolean;
    testRecipientEmail: string; // Your test email
  };
}
// Load configuration from environment variables or use defaults
export const E2E_CONFIG: E2EConfig = {
  server: {
    url: process.env.SERVER_URL || 'http://localhost',
    port: parseInt(process.env.PORT || '3000', 10)
  },
  nylas: process.env.NYLAS_GRANT_ID ? {
    nylasGrantId: process.env.NYLAS_GRANT_ID
  } : undefined,
  testTimeout: parseInt(process.env.TEST_TIMEOUT || '30000', 10),
  logging: {
    verbose: process.env.VERBOSE === 'true' || process.env.LOG_LEVEL === 'verbose',
    logApiCalls: process.env.LOG_API_CALLS === 'true',
    logTimings: process.env.LOG_TIMINGS === 'true',
    saveResponses: process.env.SAVE_RESPONSES === 'true'
  },
  testData: {
    testEmailPrefix: process.env.TEST_PREFIX || '[E2E-TEST]',
    cleanupAfterTest: process.env.CLEANUP !== 'false', // Default true
    testRecipientEmail: process.env.TEST_EMAIL_ADDRESS || ''
  }
};
// Helper to check if E2E tests should run
export function shouldRunE2ETests(): boolean {
  // E2E tests can run with or without Nylas credentials
  // Without credentials, only setup-related tests will work
  return process.env.RUN_E2E_TESTS === 'true' || process.env.CI === 'true';
}
// Helper to check if Nylas integration tests should run
export function hasNylasCredentials(): boolean {
  return !!E2E_CONFIG.nylas?.nylasGrantId;
}
</file>

<file path="tests/e2e/utils/httpClient.ts">
/**
 * HTTP client for E2E testing of the Inbox MCP server
 * Replaces the stdio-based MCP client with HTTP communication
 */
import axios, { AxiosInstance, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
import { logger } from './testLogger';
import * as fs from 'fs';
import * as path from 'path';
export interface HttpClientConfig {
  baseUrl: string;
  port: number;
  credentials?: {
    nylasGrantId?: string;
  };
  devAgentSecret?: string;
}
export interface ToolCallResponse {
  success: boolean;
  result?: any;
  error?: {
    code: number;
    message: string;
  };
  needs_approval?: boolean;
  action_type?: string;
  action_data?: any;
  preview?: any;
}
export class HttpTestClient {
  private client: AxiosInstance;
  private credentials?: {
    nylasGrantId?: string;
  };
  private devAgentSecret?: string;
  constructor(config: HttpClientConfig) {
    this.credentials = config.credentials;
    this.devAgentSecret = config.devAgentSecret ?? process.env.A2A_DEV_SHARED_SECRET ?? 'test-secret';
    this.client = axios.create({
      baseURL: `${config.baseUrl}:${config.port}`,
      timeout: 60000, // 60 seconds for AI operations
      headers: {
        'Content-Type': 'application/json'
      }
    });
    // Add request/response interceptors for logging
    this.setupInterceptors();
  }
  private setupInterceptors() {
    // Create log file for HTTP traffic
    const logDir = path.join(process.cwd(), 'tests', 'e2e', 'logs');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    const logFile = path.join(logDir, `http-traffic-${new Date().toISOString().replace(/[:.]/g, '-')}.log`);
    const appendToLog = (content: string) => {
      fs.appendFileSync(logFile, content + '\n');
    };
    // Log file location
    console.log(`\n📝 HTTP traffic log: ${logFile}\n`);
    let requestCounter = 0;
    // Request interceptor
    this.client.interceptors.request.use(
      (config: InternalAxiosRequestConfig) => {
        const method = config.method?.toUpperCase() || 'GET';
        const url = config.url || '';
        const requestId = ++requestCounter;
        const timestamp = new Date().toISOString();
        // Build request log
        let requestLog = `\n========== REQUEST #${requestId} ==========\n`;
        requestLog += `Timestamp: ${timestamp}\n`;
        requestLog += `${method} ${config.baseURL}${url} HTTP/1.1\n`;
        Object.entries(config.headers as any).forEach(([key, value]) => {
          requestLog += `${key}: ${value}\n`;
        });
        if (config.data) {
          requestLog += '\n' + JSON.stringify(config.data, null, 2) + '\n';
        }
        requestLog += '==================================\n';
        // Log to console (abbreviated)
        console.log(`\n--- HTTP REQUEST #${requestId} ---`);
        console.log(`${method} ${config.baseURL}${url}`);
        if (config.data) {
          console.log('Body:', JSON.stringify(config.data).substring(0, 100) + '...');
        }
        // Log to file (full)
        appendToLog(requestLog);
        // Add request ID for response matching
        (config as any).requestId = requestId;
        // Log the request
        logger.logApiCall(method, url, config.data);
        return config;
      },
      (error) => {
        logger.logError('Request failed', error);
        return Promise.reject(error);
      }
    );
    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        const requestId = (response.config as any).requestId || 'unknown';
        const timestamp = new Date().toISOString();
        // Build response log
        let responseLog = `\n========== RESPONSE #${requestId} ==========\n`;
        responseLog += `Timestamp: ${timestamp}\n`;
        responseLog += `HTTP/1.1 ${response.status} ${response.statusText}\n`;
        Object.entries(response.headers).forEach(([key, value]) => {
          responseLog += `${key}: ${value}\n`;
        });
        responseLog += '\n' + JSON.stringify(response.data, null, 2) + '\n';
        responseLog += '===================================\n';
        // Log to console (abbreviated)
        console.log(`\n--- HTTP RESPONSE #${requestId} ---`);
        console.log(`Status: ${response.status}`);
        if (response.data?.needs_approval) {
          console.log('Needs Approval:', response.data.needs_approval);
          console.log('Action Type:', response.data.action_type);
        } else {
          console.log('Body:', JSON.stringify(response.data).substring(0, 100) + '...');
        }
        // Log to file (full)
        appendToLog(responseLog);
        logger.logApiResponse(response.status, response.data, response.config.url);
        return response;
      },
      (error) => {
        const requestId = (error.config as any)?.requestId || 'unknown';
        const timestamp = new Date().toISOString();
        if (error.response) {
          // Build error response log
          let errorLog = `\n========== ERROR RESPONSE #${requestId} ==========\n`;
          errorLog += `Timestamp: ${timestamp}\n`;
          errorLog += `HTTP/1.1 ${error.response.status} ${error.response.statusText}\n`;
          Object.entries(error.response.headers).forEach(([key, value]) => {
            errorLog += `${key}: ${value}\n`;
          });
          errorLog += '\n' + JSON.stringify(error.response.data, null, 2) + '\n';
          errorLog += '======================================\n';
          // Log to console (abbreviated)
          console.log(`\n--- HTTP ERROR #${requestId} ---`);
          console.log(`Status: ${error.response.status}`);
          console.log('Error:', JSON.stringify(error.response.data).substring(0, 100) + '...');
          // Log to file (full)
          appendToLog(errorLog);
          logger.logApiResponse(error.response.status, error.response.data, error.config?.url);
        } else {
          logger.logError('Response error', error);
        }
        return Promise.reject(error);
      }
    );
  }
  async listTools(): Promise<any> {
    const headers = this.getCredentialHeaders();
    try {
      // Use A2A Agent Card discovery
      const response = await this.client.get('/.well-known/a2a.json', { headers });
      const card = response.data || {};
      const tools = Array.isArray(card.capabilities)
        ? card.capabilities.map((c: any) => ({ name: c.name, description: c.description }))
        : [];
      return { tools };
    } catch (error: any) {
      if (error.response) {
        return error.response.data;
      }
      throw error;
    }
  }
  async callTool(toolName: string, args: any): Promise<ToolCallResponse> {
    // JSON-RPC wrapper for A2A
    const headers = this.getCredentialHeaders();
    const id = Date.now().toString();
    const payload = {
      jsonrpc: '2.0',
      id,
      method: 'tool.execute',
      params: {
        tool: toolName,
        arguments: args,
        user_context: {
          credentials: {
            EMAIL_ACCOUNT_GRANT: this.credentials?.nylasGrantId
          }
        },
        request_id: id
      }
    };
    try {
      const response = await this.client.post(`/a2a/rpc`, payload, { headers });
      const data = response.data;
      if (data?.error) return data;
      return data?.result || data;
    } catch (error: any) {
      if (error.response) {
        return error.response.data;
      }
      throw error;
    }
  }
  // Generic JSON-RPC caller for flexibility in tests
  async callRpc(method: string, params: any = {}, id: string | number = Date.now()): Promise<any> {
    const headers = this.getCredentialHeaders();
    const payload = { jsonrpc: '2.0', id, method, params };
    try {
      const response = await this.client.post('/a2a/rpc', payload, { headers });
      return response.data;
    } catch (error: any) {
      if (error.response) return error.response.data;
      throw error;
    }
  }
  private getCredentialHeaders(): Record<string, string> {
    const headers: Record<string, string> = {};
    if (this.credentials?.nylasGrantId) {
      headers['X-User-Credential-NYLAS_GRANT_ID'] = this.credentials.nylasGrantId;
    }
    if (this.devAgentSecret) {
      headers['X-A2A-Dev-Secret'] = this.devAgentSecret;
    }
    return headers;
  }
  // Update credentials for testing different user scenarios
  updateCredentials(credentials: HttpClientConfig['credentials']) {
    this.credentials = credentials;
  }
  // Helper method to simulate approval flow
  async approveAction(toolName: string, originalArgs: any, actionData: any): Promise<ToolCallResponse> {
    return this.callTool(toolName, {
      ...originalArgs,
      approved: true,
      action_data: actionData
    });
  }
  // Generic GET method
  async get(path: string): Promise<any> {
    const headers = this.getCredentialHeaders();
    try {
      const response = await this.client.get(path, { headers });
      return response.data;
    } catch (error: any) {
      if (error.response) {
        return error.response.data;
      }
      throw error;
    }
  }
  // Generic POST method
  async post(path: string, data: any = {}): Promise<any> {
    const headers = this.getCredentialHeaders();
    try {
      const response = await this.client.post(path, data, { headers });
      return response.data;
    } catch (error: any) {
      if (error.response) {
        return error.response.data;
      }
      throw error;
    }
  }
  // Health check
  async healthCheck(): Promise<boolean> {
    try {
      const response = await this.client.get('/health');
      return response.status === 200;
    } catch {
      return false;
    }
  }
}
// Helper to start the server for testing
export async function startTestServer(): Promise<{ port: number; stop: () => Promise<void> }> {
  const { spawn } = require('child_process');
  const port = 3000 + Math.floor(Math.random() * 1000); // Random port to avoid conflicts
  return new Promise((resolve, reject) => {
    const env = { ...process.env, PORT: port.toString(), A2A_DEV_SHARED_SECRET: process.env.A2A_DEV_SHARED_SECRET || 'test-secret' };
    // Run from TypeScript source to ensure tests use latest code
    const serverProcess = spawn('npm', ['run', 'dev'], { env });
    let started = false;
    serverProcess.stdout.on('data', (data: Buffer) => {
      const output = data.toString();
      if (process.env.VERBOSE === 'true') {
        console.log('[Server]', output.trim());
      }
      if (output.includes('Inbox MCP HTTP server running') && !started) {
        started = true;
        resolve({
          port,
          stop: async () => {
            serverProcess.kill();
            await new Promise(r => setTimeout(r, 500)); // Wait for cleanup
          }
        });
      }
    });
    serverProcess.stderr.on('data', (data: Buffer) => {
      const error = data.toString();
      // Ignore deprecation warnings
      if (error.includes('DeprecationWarning') || error.includes('DEP0040')) {
        if (process.env.VERBOSE === 'true') {
          console.log('[Server Warning]', error.trim());
        }
        return;
      }
      if (process.env.VERBOSE === 'true' || !started) {
        console.error('[Server Error]', error.trim());
      }
      // Only reject for actual errors, not warnings
      if (!started && !error.includes('Warning')) {
        reject(new Error(`Server failed to start: ${error}`));
      }
    });
    // Timeout if server doesn't start
    setTimeout(() => {
      if (!started) {
        serverProcess.kill();
        reject(new Error('Server failed to start within timeout'));
      }
    }, 10000);
  });
}
// Create a test client with proper configuration
export function createTestClient(config?: Partial<HttpClientConfig>): HttpTestClient {
  return new HttpTestClient({
    baseUrl: 'http://localhost',
    port: 3000,
    ...config
  });
}
</file>

<file path="tests/e2e/fullRealApiJourney.test.ts">
/**
 * Full real API journey test for Inbox MCP
 * Tests complete user flow with real Nylas and OpenAI APIs
 */
import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach } from '@jest/globals';
import { HttpTestClient, startTestServer } from './utils/httpClient';
import { E2E_CONFIG, hasNylasCredentials } from './utils/config';
import { logger } from './utils/testLogger';
import * as dotenv from 'dotenv';
// Load environment variables from standard .env
dotenv.config();
// Skip tests if real APIs are not configured
const SKIP_REAL_API = !hasNylasCredentials() || !process.env.OPENAI_API_KEY || !process.env.TEST_EMAIL_ADDRESS;
const testSuite = SKIP_REAL_API ? describe.skip : describe;
testSuite('Full Real API Journey', () => {
  let client: HttpTestClient;
  let server: { port: number; stop: () => Promise<void> };
  let testEmailIds: string[] = [];
  beforeAll(async () => {
    logger.logSection('TEST SUITE INITIALIZATION');
    // Validate environment
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY is required for real API tests');
    }
    if (!E2E_CONFIG.nylas) {
      throw new Error('Nylas credentials are required (NYLAS_GRANT_ID)');
    }
    if (!E2E_CONFIG.testData.testRecipientEmail) {
      throw new Error('TEST_EMAIL_ADDRESS is required for sending test emails');
    }
    logger.logSuccess('Environment validated');
    logger.logData('Test Configuration', {
      hasNylasCredentials: hasNylasCredentials(),
      hasOpenAIKey: !!process.env.OPENAI_API_KEY,
      testEmailRecipient: E2E_CONFIG.testData.testRecipientEmail,
      testPrefix: E2E_CONFIG.testData.testEmailPrefix,
      cleanupEnabled: E2E_CONFIG.testData.cleanupAfterTest
    });
    // Start test server
    logger.logInfo('Starting test server...');
    server = await logger.timeOperation('server_startup', async () => {
      return await startTestServer();
    });
    // Create test client
    client = new HttpTestClient({
      baseUrl: 'http://localhost',
      port: server.port,
      credentials: {
        nylasGrantId: E2E_CONFIG.nylas.nylasGrantId
      }
    });
    logger.logSuccess(`Test server started on port ${server.port}`);
  }, 60000);
  afterAll(async () => {
    logger.logSection('TEST SUITE CLEANUP');
    if (E2E_CONFIG.testData.cleanupAfterTest && testEmailIds.length > 0) {
      logger.logInfo(`Cleaning up ${testEmailIds.length} test emails...`);
      // TODO: Implement cleanup logic
    }
    if (server) {
      await server.stop();
      logger.logSuccess('Test server stopped');
    }
    logger.logTestSummary(0, 0, 0); // Will be updated by Jest
  });
  beforeEach(() => {
    logger.startOperation('test_case');
  });
  afterEach(() => {
    logger.endOperation('test_case');
  });
  describe('Onboarding Flow', () => {
    test('should list tools with credentials', async () => {
      logger.logStep(1, 'List available tools with credentials');
      const response = await logger.timeOperation('list_tools', async () => {
        logger.logApiCall('GET', '/.well-known/a2a.json');
        const result = await client.listTools();
        logger.logApiResponse(200, result);
        return result;
      });
      expect(response.tools).toBeDefined();
      expect(response.tools.length).toBeGreaterThan(0);
      const toolNames = response.tools.map((t: any) => t.name);
      logger.logData('Available Tools', toolNames);
      // Should have all email tools available when credentials are present
      expect(toolNames).toContain('manage_email');
      expect(toolNames).toContain('find_emails');
      expect(toolNames).toContain('email_insights');
      expect(toolNames).toContain('organize_inbox');
      expect(toolNames).toContain('smart_folders');
      logger.logSuccess('All email tools available with credentials');
    });
    test.skip('should validate existing credentials - setup is separate endpoint', async () => {
      logger.logStep(2, 'Validate Nylas credentials');
      const response = await logger.timeOperation('validate_credentials', async () => {
        logger.logApiCall('POST', '/setup/validate', {
          nylas_api_key: 'server_env_key',
          nylas_grant_id: E2E_CONFIG.nylas!.nylasGrantId
        });
        const result = await client.post('/setup/validate', {
          nylas_api_key: 'server_env_key',
          nylas_grant_id: E2E_CONFIG.nylas!.nylasGrantId
        });
        logger.logApiResponse(200, result);
        return result;
      });
      expect(response.result).toBeDefined();
      // Handle expired or invalid credentials gracefully
      if (response.result.type !== 'setup_success') {
        logger.logError('Validation failed:', response.result);
        if (response.result.type === 'setup_error') {
          if (response.result.message.includes('Grant ID not found')) {
            logger.logWarning('Grant ID not found - it may have expired (test grants expire after 30 days)');
            logger.logInfo('To fix: Create a new test grant in your Nylas dashboard and update .env');
            return; // Skip the test
          } else if (response.result.message.includes('Invalid API key')) {
            logger.logWarning('API key is invalid - please check your Nylas dashboard');
            logger.logInfo('To fix: Verify your API key in the Nylas dashboard and update .env');
            return; // Skip the test
          }
        }
      }
      expect(response.result.type).toBe('setup_success');
      expect(response.result.credentials_validated).toBe(true);
      logger.logData('Validation Result', response.result);
      logger.logSuccess('Credentials validated successfully');
    });
  });
  describe('Email Operations with Real Inbox', () => {
    test('should find emails using natural language with AI analysis', async () => {
      logger.logStep(3, 'Find emails using natural language query');
      const query = 'emails from the last 24 hours';
      logger.logInfo(`Query: "${query}"`);
      const response = await logger.timeOperation('find_emails', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {
          query,
          analysis_type: 'full',
          limit: 10
        });
        const result = await client.callTool('find_emails', {
          query,
          analysis_type: 'full',
          limit: 10
        });
        logger.logApiResponse(200, result);
        return result;
      });
      expect(response.result).toBeDefined();
      expect(response.result.emails).toBeDefined();
      expect(Array.isArray(response.result.emails)).toBe(true);
      logger.logData('Found Emails Count', response.result.emails.length);
      if (response.result.emails.length > 0) {
        logger.logData('First Email', {
          from: response.result.emails[0].from,
          subject: response.result.emails[0].subject,
          date: response.result.emails[0].date
        });
      }
      if (response.result.summary) {
        logger.logData('AI Summary', response.result.summary);
      }
      logger.logSuccess(`Found ${response.result.emails.length} emails with AI analysis`);
    });
    test('should send email with approval flow', async () => {
      logger.logStep(4, 'Send email with natural language and approval');
      const query = `send a test email to ${E2E_CONFIG.testData.testRecipientEmail} saying this is an automated test from Inbox MCP`;
      logger.logInfo(`Query: "${query}"`);
      // Step 1: Initial request that should require approval
      logger.logInfo('Step 4a: Initial email request');
      const initialResponse = await logger.timeOperation('initial_email_request', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {
          action: 'send',
          query,
          require_approval: true
        });
        const result = await client.callTool('manage_email', {
          action: 'send',
          query,
          require_approval: true
        });
        logger.logApiResponse(200, result);
        return result;
      });
      expect(initialResponse.result).toBeDefined();
      expect(initialResponse.result.needs_approval).toBe(true);
      expect(initialResponse.result.action_type).toBe('send_email');
      expect(initialResponse.result.action_data).toBeDefined();
      expect(initialResponse.result.preview).toBeDefined();
      logger.logData('Approval Preview', initialResponse.result.preview);
      logger.logSuccess('Email generated and requires approval');
      // Step 2: Approve and send the email
      logger.logInfo('Step 4b: Approve and send email');
      const approvalResponse = await logger.timeOperation('approve_email_send', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {
          ...initialResponse.result.action_data.original_params,
          approved: true,
          action_data: initialResponse.result.action_data
        });
        const result = await client.approveAction(
          'manage_email',
          initialResponse.result.action_data.original_params,
          initialResponse.result.action_data
        );
        logger.logApiResponse(200, result);
        return result;
      });
      expect(approvalResponse.result).toBeDefined();
      expect(approvalResponse.result.success).toBe(true);
      expect(approvalResponse.result.message_id).toBeDefined();
      expect(approvalResponse.result.approval_executed).toBe(true);
      // Track for cleanup
      if (approvalResponse.result.message_id) {
        testEmailIds.push(approvalResponse.result.message_id);
      }
      logger.logData('Send Result', {
        message_id: approvalResponse.result.message_id,
        success: approvalResponse.result.success
      });
      logger.logSuccess('Email sent successfully after approval');
    });
  });
  describe('AI-Powered Features', () => {
    test('should generate email insights', async () => {
      logger.logStep(5, 'Generate AI-powered email insights');
      const response = await logger.timeOperation('email_insights', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {
          query: 'summarize my emails today',
          time_period: 'today'
        });
        const result = await client.callTool('email_insights', {
          query: 'summarize my emails today',
          time_period: 'today'
        });
        logger.logApiResponse(200, result);
        return result;
      });
      expect(response.result).toBeDefined();
      expect(response.result.insights).toBeDefined();
      logger.logData('Insights', response.result.insights);
      logger.logSuccess('Generated email insights using AI');
    });
    test('should analyze inbox organization with dry run', async () => {
      logger.logStep(6, 'Analyze inbox organization (dry run)');
      const response = await logger.timeOperation('organize_analysis', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {
          instruction: 'organize my emails by importance and archive old newsletters',
          dry_run: true
        });
        const result = await client.callTool('organize_inbox', {
          instruction: 'organize my emails by importance and archive old newsletters',
          dry_run: true
        });
        logger.logApiResponse(200, result);
        return result;
      });
      expect(response.result).toBeDefined();
      if (response.result.organization_plan) {
        logger.logData('Organization Plan', response.result.organization_plan);
        logger.logInfo(`Would affect ${response.result.total_actions || 0} emails`);
      }
      logger.logSuccess('Generated inbox organization plan');
    });
  });
  describe('Error Handling', () => {
    test('should handle missing credentials gracefully', async () => {
      logger.logStep(7, 'Test missing credentials error handling');
      // Create client without credentials
      const noCredClient = new HttpTestClient({
        baseUrl: 'http://localhost',
        port: server.port
      });
      const response = await logger.timeOperation('missing_credentials_test', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {
          action: 'send',
          query: 'test email'
        });
        const result = await noCredClient.callTool('manage_email', {
          action: 'send',
          query: 'test email'
        });
        logger.logApiResponse(401, result);
        return result;
      });
      expect(response).toBeDefined();
      const err = (response as any).error || {};
      expect(err).toBeDefined();
      expect(err.code).toBe(401);
      expect((err.message || '').toLowerCase()).toContain('missing_credentials');
      logger.logWarning('Correctly handled missing credentials');
    });
    test('should handle invalid tool gracefully', async () => {
      logger.logStep(8, 'Test invalid tool error handling');
      const response = await logger.timeOperation('invalid_tool_test', async () => {
        logger.logApiCall('POST', '/a2a/rpc', {});
        const result = await client.callTool('invalid_tool', {});
        logger.logApiResponse(404, result);
        return result;
      });
      expect(response).toBeDefined();
      const err2 = (response as any).error || {};
      expect(err2).toBeDefined();
      expect(err2.code).toBe(404);
      expect((err2.message || '').toLowerCase()).toContain('unknown_tool');
      logger.logWarning('Correctly handled invalid tool');
    });
  });
});
</file>

<file path="tests/e2e/onboardingFlow.test.ts">
/**
 * Onboarding flow test for new users
 * Tests the complete setup experience without existing credentials
 */
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { HttpTestClient, startTestServer } from './utils/httpClient';
import { E2E_CONFIG } from './utils/config';
import { logger } from './utils/testLogger';
import * as dotenv from 'dotenv';
// Load environment variables
dotenv.config();
describe('Onboarding Flow - New User Experience', () => {
  let client: HttpTestClient;
  let server: { port: number; stop: () => Promise<void> };
  beforeAll(async () => {
    logger.logSection('ONBOARDING TEST INITIALIZATION');
    // Start server
    server = await startTestServer();
    // Create client WITHOUT credentials to simulate new user
    client = new HttpTestClient({
      baseUrl: E2E_CONFIG.server.url,
      port: server.port
      // No credentials provided
    });
    logger.logSuccess(`Test server started on port ${server.port}`);
  }, 30000);
  afterAll(async () => {
    if (server) {
      await server.stop();
    }
  });
  describe('Initial Connection - No Credentials', () => {
    test.skip('should list only setup tool when no credentials provided', async () => {
      // SKIPPED: Setup is now a separate endpoint, not a tool
      logger.logStep(1, 'List tools without credentials');
      const response = await client.listTools();
      expect(response.tools).toBeDefined();
      expect(response.tools.length).toBeGreaterThan(0);
      const toolNames = response.tools.map((t: any) => t.name);
      logger.logData('Available Tools', toolNames);
      // Should have setup tool
      expect(toolNames).toContain('setup');
      // Should NOT have email tools without credentials
      expect(toolNames).not.toContain('manage_email');
      expect(toolNames).not.toContain('find_emails');
      logger.logSuccess('Only setup tool available - correct behavior');
    });
    test('should fail gracefully when trying to use email tools without setup', async () => {
      logger.logStep(2, 'Try to use email tool without credentials');
      const response = await client.callTool('manage_email', {
        action: 'send',
        query: 'test email'
      });
      // Expect JSON-RPC error for missing credentials
      expect(response).toBeDefined();
      const err = (response as any).error || response;
      expect(err).toBeDefined();
      const message = err.message || err.error || '';
      // Accept either structured JSON-RPC { error: { code, message } } or direct error message
      expect(message).toBeTruthy();
      // Prefer canonical message
      if (err?.message) {
        expect(err.message).toMatch(/missing_credentials|Missing Nylas credentials/i);
      }
      logger.logSuccess('Correctly rejected email operation without credentials');
    });
  });
  describe.skip('Setup Tool - Guided Onboarding', () => {
    // SKIPPED: Setup is now a separate endpoint, not a tool
    test('should provide setup instructions', async () => {
      logger.logStep(3, 'Get setup instructions');
      const response = await client.callTool('setup', {
        action: 'start'
      });
      expect(response.result).toBeDefined();
      expect(response.result.type).toBe('setup_instructions');
      expect(response.result.steps).toBeDefined();
      expect(Array.isArray(response.result.steps)).toBe(true);
      expect(response.result.steps.length).toBeGreaterThan(0);
      logger.logData('Setup Steps', response.result.steps.map((s: any) => ({
        step: s.step,
        title: s.title
      })));
      // Verify instructions structure
      const firstStep = response.result.steps[0];
      expect(firstStep.title).toBeDefined();
      expect(firstStep.description).toBeDefined();
      expect(firstStep.actions).toBeDefined();
      logger.logSuccess('Received comprehensive setup instructions');
    });
    test('should validate credential format', async () => {
      logger.logStep(4, 'Test credential validation with invalid format');
      // Test with invalid API key format
      const response = await client.callTool('setup', {
        action: 'validate',
        credentials: {
          nylas_api_key: 'invalid-key-format',
          nylas_grant_id: '12345678-1234-1234-1234-123456789012'
        }
      });
      expect(response.result).toBeDefined();
      expect(response.result.type).toBe('validation_error');
      expect(response.result.message).toContain('API key should start with');
      logger.logSuccess('Correctly validated API key format');
    });
    test('should validate grant ID format', async () => {
      logger.logStep(5, 'Test grant ID validation');
      const response = await client.callTool('setup', {
        action: 'validate',
        credentials: {
          nylas_api_key: 'nyk_valid_format_key',
          nylas_grant_id: 'not-a-uuid'
        }
      });
      expect(response.result).toBeDefined();
      expect(response.result.type).toBe('validation_error');
      expect(response.result.message).toContain('valid UUID');
      logger.logSuccess('Correctly validated grant ID format');
    });
    // Only run this test if we have real credentials to test with
    if ((E2E_CONFIG as any).nylas) {
      test('should successfully validate real credentials', async () => {
        logger.logStep(6, 'Validate real credentials');
        // Debug: Log what credentials we're using
        logger.logData('Testing with credentials', {
          grantId: (E2E_CONFIG as any).nylas.nylasGrantId
        });
        const response = await client.post('/setup/validate', {
          nylas_api_key: 'server_env_key',
          nylas_grant_id: (E2E_CONFIG as any).nylas.nylasGrantId
        });
        expect(response.result).toBeDefined();
        // Log the actual response for debugging
        if (response.result.type !== 'setup_success') {
          logger.logError('Validation failed:', response.result);
          // Handle expired or invalid credentials gracefully
          if (response.result.type === 'setup_error') {
            if (response.result.message.includes('Grant ID not found')) {
              logger.logWarning('Grant ID not found - it may have expired (test grants expire after 30 days)');
              logger.logInfo('To fix: Create a new test grant in your Nylas dashboard and update .env');
              return; // Skip the test
            } else if (response.result.message.includes('Invalid API key')) {
              logger.logWarning('API key is invalid - please check your Nylas dashboard');
              logger.logInfo('To fix: Verify your API key in the Nylas dashboard and update .env');
              return; // Skip the test
            }
          }
        }
        expect(response.type).toBeDefined();
        if (response.result.email) {
          logger.logData('Connected Email', response.result.email);
        }
        logger.logSuccess('Real credentials validated successfully');
      });
    }
  });
  describe('Post-Setup Experience', () => {
    test('should have all tools available after adding credentials', async () => {
      logger.logStep(7, 'Verify tools available after setup');
      // Skip if no real credentials
      if (!E2E_CONFIG.nylas) {
        logger.logWarning('Skipping - no real credentials available');
        return;
      }
      // Create new client with credentials
      const authenticatedClient = new HttpTestClient({
        baseUrl: E2E_CONFIG.server.url,
        port: server.port,
        credentials: {
          nylasGrantId: E2E_CONFIG.nylas.nylasGrantId
        }
      });
      const response = await authenticatedClient.listTools();
      const toolNames = response.tools.map((t: any) => t.name);
      // Should now have all email tools
      expect(toolNames).toContain('manage_email');
      expect(toolNames).toContain('find_emails');
      expect(toolNames).toContain('email_insights');
      expect(toolNames).toContain('organize_inbox');
      expect(toolNames).toContain('smart_folders');
      logger.logSuccess('All email tools now available after setup');
    });
  });
  describe('Error Scenarios', () => {
    test('should handle network errors gracefully', async () => {
      logger.logStep(8, 'Test network error handling');
      // Create client pointing to wrong port
      const badClient = new HttpTestClient({
        baseUrl: E2E_CONFIG.server.url,
        port: 99999 // Invalid port
      });
      try {
        await badClient.listTools();
        expect(true).toBe(false); // Should not reach here
      } catch (error: any) {
        expect(error).toBeDefined();
        logger.logSuccess('Network error handled correctly');
      }
    });
    test.skip('should provide helpful error for missing credentials', async () => {
      // SKIPPED: Setup is now a separate endpoint, not a tool
      logger.logStep(9, 'Test missing credential fields');
      const response = await client.callTool('setup', {
        action: 'validate',
        credentials: {
          // Missing both fields
        }
      });
      expect(response.result).toBeDefined();
      expect(response.result.type).toBe('validation_error');
      expect(response.result.missing_fields).toBeDefined();
      expect(response.result.missing_fields).toContain('nylas_api_key');
      expect(response.result.missing_fields).toContain('nylas_grant_id');
      logger.logSuccess('Correctly identified missing fields');
    });
  });
});
</file>

<file path="tests/e2e/run-e2e-tests.ts">
#!/usr/bin/env node
/**
 * E2E test runner with environment validation
 * Ensures all required APIs and configurations are present
 */
import * as dotenv from 'dotenv';
import { spawn } from 'child_process';
import { logger } from './utils/testLogger';
// Load standard environment
dotenv.config();
// Environment validation
interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}
function validateEnvironment(): ValidationResult {
  const result: ValidationResult = {
    valid: true,
    errors: [],
    warnings: []
  };
  // Check OpenAI API key
  if (!process.env.OPENAI_API_KEY) {
    result.errors.push('OPENAI_API_KEY is not set. Required for AI features.');
    result.valid = false;
  } else if (process.env.OPENAI_API_KEY.length < 20) {
    result.errors.push('OPENAI_API_KEY appears to be invalid (too short).');
    result.valid = false;
  }
  // Check Nylas credentials (grant only; API key is server env)
  if (!process.env.NYLAS_GRANT_ID) {
    result.warnings.push('Nylas grant not found. Only setup tests will run.');
    result.warnings.push('Set NYLAS_GRANT_ID to run full tests.');
  } else {
    // Basic UUID validation for grant ID
    const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    if (!uuidRegex.test(process.env.NYLAS_GRANT_ID)) {
      result.errors.push('NYLAS_GRANT_ID should be a valid UUID');
      result.valid = false;
    }
  }
  // Check test email
  if (!process.env.TEST_EMAIL_ADDRESS) {
    result.warnings.push('TEST_EMAIL_ADDRESS not set. Email sending tests will use fallback.');
  } else {
    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(process.env.TEST_EMAIL_ADDRESS)) {
      result.errors.push('TEST_EMAIL_ADDRESS is not a valid email format');
      result.valid = false;
    }
  }
  // Check optional settings
  if (process.env.VERBOSE === 'true') {
    result.warnings.push('Verbose logging is enabled. Output will be detailed.');
  }
  if (process.env.SAVE_RESPONSES === 'true') {
    result.warnings.push('Response saving is enabled. Check test-responses/ directory.');
  }
  return result;
}
function printEnvironmentSummary() {
  logger.logSection('E2E Test Environment Summary');
  console.log('API Keys:');
  console.log(`  ✓ OpenAI API Key: ${process.env.OPENAI_API_KEY ? 'Set' : '✗ Missing'}`);
  console.log('\nNylas Configuration:');
  console.log(`  ${process.env.NYLAS_GRANT_ID ? '✓' : '✗'} Grant ID: ${process.env.NYLAS_GRANT_ID ? 'Set' : 'Missing'
    }`);
  console.log('\nTest Configuration:');
  console.log(`  Test Email: ${process.env.TEST_EMAIL_ADDRESS || 'Not set'}`);
  console.log(`  Test Prefix: ${process.env.TEST_PREFIX || '[E2E-TEST]'}`);
  console.log(`  Cleanup After Test: ${process.env.CLEANUP !== 'false' ? 'Yes' : 'No'}`);
  console.log('\nLogging Configuration:');
  console.log(`  Verbose: ${process.env.VERBOSE === 'true' ? 'Yes' : 'No'}`);
  console.log(`  Log API Calls: ${process.env.LOG_API_CALLS === 'true' ? 'Yes' : 'No'}`);
  console.log(`  Log Timings: ${process.env.LOG_TIMINGS === 'true' ? 'Yes' : 'No'}`);
  console.log(`  Save Responses: ${process.env.SAVE_RESPONSES === 'true' ? 'Yes' : 'No'}`);
}
function runTests(testPattern?: string): Promise<number> {
  return new Promise((resolve) => {
    const args = ['test:e2e'];
    if (testPattern) {
      args.push('--', testPattern);
    }
    const child = spawn('npm', ['run', ...args], {
      stdio: 'inherit',
      env: {
        ...process.env,
        RUN_E2E_TESTS: 'true'
      }
    });
    child.on('exit', (code) => {
      resolve(code || 0);
    });
  });
}
async function main() {
  logger.logSection('Inbox MCP E2E Test Runner');
  // Validate environment
  const validation = validateEnvironment();
  // Show environment summary
  printEnvironmentSummary();
  // Display validation results
  if (validation.errors.length > 0) {
    logger.logSection('Environment Validation Errors');
    validation.errors.forEach(error => logger.logError(error));
  }
  if (validation.warnings.length > 0) {
    logger.logSection('Environment Warnings');
    validation.warnings.forEach(warning => logger.logWarning(warning));
  }
  if (!validation.valid) {
    logger.logError('\nEnvironment validation failed. Please fix the errors above.');
    logger.logInfo('Copy .env.test.example to .env.test and fill in your credentials.');
    process.exit(1);
  }
  // Check for test pattern argument
  const testPattern = process.argv[2];
  logger.logSection('Running E2E Tests');
  if (testPattern) {
    logger.logInfo(`Running tests matching pattern: ${testPattern}`);
  } else {
    logger.logInfo('Running all E2E tests...');
  }
  try {
    const exitCode = await runTests(testPattern);
    if (exitCode === 0) {
      logger.logSuccess('\nAll tests passed! 🎉');
    } else {
      logger.logError(`\nTests failed with exit code ${exitCode}`);
    }
    process.exit(exitCode);
  } catch (error) {
    logger.logError('Failed to run tests', error);
    process.exit(1);
  }
}
// Handle uncaught errors
process.on('unhandledRejection', (error) => {
  logger.logError('Unhandled rejection:', error);
  process.exit(1);
});
// Run the test runner
main();
</file>

<file path="tests/e2e/setup.test.ts">
import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import { HttpTestClient, startTestServer, createTestClient } from './utils/httpClient';
import { E2E_CONFIG, hasNylasCredentials } from './utils/config';
import Nylas from 'nylas';
describe('Setup and Onboarding E2E Tests', () => {
  let server: { port: number; stop: () => Promise<void> };
  let client: HttpTestClient;
  beforeAll(async () => {
    if (process.env.USE_EXISTING_SERVER !== 'true') {
      server = await startTestServer();
      E2E_CONFIG.server.port = server.port;
    }
    client = createTestClient({
      port: E2E_CONFIG.server.port,
      credentials: E2E_CONFIG.nylas
    });
  });
  afterAll(async () => {
    if (server) {
      await server.stop();
    }
  });
  describe('Initial Setup Flow', () => {
    it('should indicate setup is needed when not configured', async () => {
      // Create a client without credentials
      const setupClient = createTestClient({
        port: E2E_CONFIG.server.port
        // No credentials provided
      });
      // Check if setup is needed
      const needsSetupResponse = await setupClient.get('/setup/status');
      expect(needsSetupResponse.needs_setup).toBe(true);
      expect(needsSetupResponse.has_credentials).toBe(false);
      expect(needsSetupResponse.setup_url).toBe('/setup/instructions');
    });
    it('should provide detailed setup instructions', async () => {
      const setupClient = createTestClient({
        port: E2E_CONFIG.server.port
      });
      // Get setup instructions
      const response = await setupClient.get('/setup/instructions');
      expect(response.type).toBe('setup_instructions');
      expect(response.steps).toHaveLength(3);
      // Verify step structure
      const firstStep = response.steps[0];
      expect(firstStep.title).toContain('Nylas Account');
      expect(firstStep.action).toBeDefined();
      // Verify next action
      expect(response.next_action).toBeDefined();
      expect(response.next_action.endpoint).toBe('POST /setup/validate');
    });
    it('should validate credential format', async () => {
      const setupClient = createTestClient({
        port: E2E_CONFIG.server.port
      });
      // Test invalid API key format
      const invalidResponse = await setupClient.post('/setup/validate', {
        nylas_api_key: 'invalid_key',
        nylas_grant_id: '12345678-1234-1234-1234-123456789012'
      });
      expect(invalidResponse.type).toBe('validation_error');
      expect(invalidResponse.message).toContain('API key should start with');
    });
    it('should handle missing credentials', async () => {
      const setupClient = createTestClient({
        port: E2E_CONFIG.server.port
      });
      // Test missing credentials
      const response = await setupClient.post('/setup/validate', {});
      expect(response.success).toBe(false);
      expect(response.error).toContain('Missing required credentials');
    });
  });
  describe('Credential Validation', () => {
    it('should validate credentials if provided', async () => {
      if (!hasNylasCredentials()) {
        console.log('Skipping credential validation - no Nylas credentials provided');
        return;
      }
      const response = await client.post('/setup/validate', {
        nylas_api_key: 'server_env_key',
        nylas_grant_id: E2E_CONFIG.nylas!.nylasGrantId
      });
      if (response.type === 'setup_success') {
        expect(response.credentials_validated).toBe(true);
        expect(response.message).toContain('Successfully connected');
      } else {
        // If credentials are invalid, should get appropriate error
        expect(['setup_error', 'validation_error']).toContain(response.type);
      }
    });
  });
  describe('Tool Availability Based on Setup', () => {
    it('should show all tools when properly configured', async () => {
      if (!hasNylasCredentials()) {
        console.log('Skipping tool availability test - no Nylas credentials provided');
        return;
      }
      const response = await client.listTools();
      expect(response.tools).toBeDefined();
      expect(response.tools.length).toBeGreaterThan(0);
      // Should have email tools available
      const emailTools = ['manage_email', 'find_emails', 'organize_inbox', 'email_insights', 'smart_folders'];
      emailTools.forEach(toolName => {
        const tool = response.tools.find((t: any) => t.name === toolName);
        expect(tool).toBeDefined();
      });
    });
    it('should advertise capabilities but block execution without credentials', async () => {
      const unconfiguredClient = createTestClient({
        port: E2E_CONFIG.server.port
        // No credentials
      });
      const response = await unconfiguredClient.listTools();
      expect(response.tools).toBeDefined();
      expect(response.tools.length).toBeGreaterThan(0); // Capabilities are always advertised via Agent Card
      // Attempt to execute without credentials should return JSON-RPC missing_credentials
      const execResponse = await unconfiguredClient.callTool('find_emails', { query: 'anything' });
      const err = (execResponse as any).error || {};
      expect(err).toBeDefined();
      expect(err.code === 401 || /missing_credentials/i.test(err.message || '')).toBe(true);
    });
  });
});
</file>

<file path="tests/e2e/setup.ts">
import dotenv from 'dotenv';
// Load environment variables from standard .env
dotenv.config();
// Only require OpenAI API key - Nylas credentials are optional
const requiredVars = ['OPENAI_API_KEY'];
const optionalVars = ['NYLAS_GRANT_ID', 'TEST_EMAIL_ADDRESS'];
const missing = requiredVars.filter(v => !process.env[v]);
if (missing.length > 0) {
  console.error('Missing required environment variables:', missing);
  console.error('Please add them to your .env file');
  process.exit(1);
}
// Log optional variables status
const missingOptional = optionalVars.filter(v => !process.env[v]);
if (missingOptional.length > 0) {
  console.log('Note: Some optional variables are not set:', missingOptional);
  console.log('Some tests will be skipped');
}
// Set longer timeout for E2E tests
jest.setTimeout(60000);
// Global test helpers
global.testHelpers = {
  waitForUser: async (message: string) => {
    if (process.env.CI === 'true') {
      console.log(`CI Mode: Skipping user interaction - ${message}`);
      return;
    }
    console.log(`\n${message}\nPress Enter to continue...`);
    await new Promise(resolve => {
      process.stdin.once('data', resolve);
    });
  }
};
</file>

<file path="tests/e2e/toolApprovals.test.ts">
import { HttpTestClient, createTestClient, startTestServer } from './utils/httpClient';
import { TestLogger } from './utils/testLogger';
import { E2E_CONFIG } from './config';
import { hasNylasCredentials } from './utils/config';
const SKIP = !hasNylasCredentials() || !process.env.OPENAI_API_KEY;
const suite = SKIP ? describe.skip : describe;
suite('Tool Approval Flows', () => {
  let client: HttpTestClient;
  let server: { port: number; stop: () => Promise<void> };
  const logger = new TestLogger();
  // Track created resources for cleanup
  const testEmailIds: string[] = [];
  const testFolderIds: string[] = [];
  beforeAll(async () => {
    logger.logSection('TEST SUITE INITIALIZATION');
    // Validate environment
    const hasCredentials = !!E2E_CONFIG.nylas.grantId;
    if (!hasCredentials) return; // suite is skipped when missing
    // Start test server
    logger.logInfo('Starting test server...');
    server = await startTestServer();
    // Create test client with credentials
    client = createTestClient({
      port: server.port,
      credentials: {
        nylasGrantId: E2E_CONFIG.nylas.grantId
      }
    });
    logger.logSuccess(`Test server started on port ${server.port}`);
  }, 30000);
  afterAll(async () => {
    logger.logSection('CLEANUP');
    // Cleanup test emails
    if (testEmailIds.length > 0 && E2E_CONFIG.testData.cleanupAfterTests) {
      logger.logInfo(`Cleaning up ${testEmailIds.length} test emails...`);
      // Note: Nylas doesn't have a direct delete API, emails would be cleaned via inbox rules
    }
    // Stop server
    if (server) {
      await server.stop();
      logger.logSuccess('Test server stopped');
    }
  });
  describe('manage_email approval flow', () => {
    test('should require approval for sending email', async () => {
      logger.logStep(1, 'Test manage_email approval flow');
      if (!E2E_CONFIG.nylas.testEmail) {
        logger.logWarning('Skipping - TEST_EMAIL_ADDRESS not set');
        return;
      }
      // Step 1: Initial request that should require approval
      const initialResponse = await client.callTool('manage_email', {
        action: 'send',
        query: `Send an email to ${E2E_CONFIG.nylas.testEmail} with subject "${E2E_CONFIG.testData.emailPrefix} Approval Test" saying "This is a test of the approval system"`
      });
      // Verify approval is required
      expect(initialResponse.result.needs_approval).toBe(true);
      expect(initialResponse.result.action_type).toBe('send_email');
      expect(initialResponse.result.action_data).toBeDefined();
      expect(initialResponse.result.preview).toBeDefined();
      expect(initialResponse.result.preview.summary).toContain(E2E_CONFIG.nylas.testEmail);
      logger.logSuccess('Email send requires approval as expected');
      logger.logData('Approval Preview', initialResponse.result.preview, 2);
      // Step 2: Execute with approval
      const approvalResponse = await client.approveAction(
        'manage_email',
        initialResponse.result.action_data.original_params,
        initialResponse.result.action_data
      );
      expect(approvalResponse.result.success).toBe(true);
      expect(approvalResponse.result.message_id).toBeDefined();
      if (approvalResponse.result?.message_id) {
        testEmailIds.push(approvalResponse.result.message_id);
      }
      logger.logSuccess('Email sent successfully after approval');
    }, 60000);
    test('should skip approval when require_approval is false', async () => {
      logger.logStep(2, 'Test manage_email without approval');
      if (!E2E_CONFIG.nylas.testEmail) {
        logger.logWarning('Skipping - TEST_EMAIL_ADDRESS not set');
        return;
      }
      const response = await client.callTool('manage_email', {
        action: 'send',
        query: `Send an email to ${E2E_CONFIG.nylas.testEmail} with subject "${E2E_CONFIG.testData.emailPrefix} No Approval Test"`,
        require_approval: false
      });
      // Should send directly without approval
      expect(response.result.needs_approval).toBeUndefined();
      expect(response.result.success).toBe(true);
      expect(response.result.message_id).toBeDefined();
      if (response.result?.message_id) {
        testEmailIds.push(response.result.message_id);
      }
      logger.logSuccess('Email sent directly without approval');
    }, 60000);
  });
  describe('organize_inbox approval flow', () => {
    test('should require approval for inbox organization', async () => {
      logger.logStep(3, 'Test organize_inbox approval flow');
      // Step 1: Initial request with dry_run=false should require approval
      const initialResponse = await client.callTool('organize_inbox', {
        instruction: 'Archive all emails older than 30 days that are not starred',
        scope: {
          folder: 'inbox',
          limit: 10
        },
        dry_run: false
      });
      // Verify response - may not need approval if no actions to take
      if (initialResponse.result.needs_approval) {
        expect(initialResponse.result.action_type).toBe('organize_inbox');
        expect(initialResponse.result.action_data).toBeDefined();
        expect(initialResponse.result.preview).toBeDefined();
        expect(initialResponse.result.preview.summary).toBeDefined();
      } else {
        // No emails matched the criteria
        expect(initialResponse.result.total_actions).toBe(0);
      }
      if (initialResponse.result.needs_approval) {
        logger.logSuccess('Inbox organization requires approval as expected');
        logger.logData('Organization Preview', initialResponse.result.preview, 2);
      } else {
        logger.logInfo('No emails matched organization criteria');
      }
      // Note: We won't execute the approval in tests to avoid modifying real inbox
      logger.logInfo('Skipping actual execution to preserve inbox state');
    }, 60000);
    test('should return preview only when dry_run is true', async () => {
      logger.logStep(4, 'Test organize_inbox dry run');
      const response = await client.callTool('organize_inbox', {
        instruction: 'Move all newsletters to a Newsletter folder',
        scope: {
          folder: 'inbox',
          limit: 20
        },
        dry_run: true
      });
      // Should return preview without requiring approval
      expect(response.result.needs_approval).toBeUndefined();
      expect(response.result).toBeDefined();
      expect(response.result.preview_actions).toBeDefined();
      expect(response.result.total_actions).toBeDefined();
      logger.logSuccess('Dry run returned preview without approval');
      logger.logData('Dry Run Results', {
        total_actions: response.result.total_actions || 0,
        summary: response.result.summary
      }, 2);
    }, 60000);
  });
  describe('smart_folders approval flow', () => {
    test('should require approval for applying smart folder rules', async () => {
      logger.logStep(5, 'Test smart_folders approval flow');
      // First create a smart folder rule with unique name
      const uniqueFolderName = `${E2E_CONFIG.testData.emailPrefix} Test Smart Folder ${Date.now()}`;
      const createResponse = await client.callTool('smart_folders', {
        query: 'Create a folder for important client emails from domains like @important-client.com',
        folder_name: uniqueFolderName
      });
      // Handle both success and conflict cases
      if (createResponse.error) {
        // If folder already exists, that's okay for this test
        logger.logInfo(`Folder creation failed (may already exist): ${createResponse.error}`);
        // Try to list existing folders instead
        const listResponse = await client.callTool('smart_folders', {
          query: 'show me all my smart folders'
        });
        expect(listResponse.result.smart_folders).toBeDefined();
      } else {
        expect(createResponse.result.success).toBe(true);
        expect(createResponse.result.folder_id).toBeDefined();
        if (createResponse.result?.folder_id) {
          testFolderIds.push(createResponse.result.folder_id);
        }
      }
      // Step 2: Apply the folder with dry_run=false should require approval
      const applyResponse = await client.callTool('smart_folders', {
        query: `Apply the "${uniqueFolderName}" rules`,
        dry_run: false
      });
      // Handle both cases: approval required (emails to move) or no emails to move
      if (applyResponse.result.needs_approval) {
        // Case 1: There are emails to move, approval required
        expect(applyResponse.result.action_type).toBe('apply_smart_folder');
        expect(applyResponse.result.action_data).toBeDefined();
        expect(applyResponse.result.preview).toBeDefined();
        logger.logSuccess('Smart folder application requires approval as expected');
        logger.logData('Smart Folder Preview', applyResponse.result.preview, 2);
      } else if (applyResponse.result.success && applyResponse.result.preview) {
        // Case 2: No emails match the criteria, so no approval needed
        expect(applyResponse.result.preview.total_count).toBe(0);
        logger.logInfo('No emails matched smart folder criteria, approval not required');
        logger.logData('Smart Folder Preview', applyResponse.result.preview, 2);
      } else {
        // Unexpected response
        throw new Error(`Unexpected response: ${JSON.stringify(applyResponse)}`);
      }
      // Note: We won't execute the approval in tests to avoid moving real emails
      logger.logInfo('Test completed - preserving inbox state');
    }, 60000);
    test('should return preview when listing smart folders', async () => {
      logger.logStep(6, 'Test smart_folders list action');
      const response = await client.callTool('smart_folders', {
        query: 'show me all my smart folders'
      });
      // List action should not require approval
      expect(response.result.needs_approval).toBeUndefined();
      expect(response.result.smart_folders).toBeDefined();
      expect(Array.isArray(response.result.smart_folders)).toBe(true);
      logger.logSuccess('Listed smart folders without approval');
      logger.logData('Smart Folders', {
        count: response.result.smart_folders.length,
        folders: response.result.smart_folders.map((f: any) => f.name)
      }, 2);
    }, 60000);
  });
  describe('Approval edge cases', () => {
    test('should handle approval with missing action_data', async () => {
      logger.logStep(7, 'Test approval with invalid data');
      const response = await client.callTool('manage_email', {
        action: 'send',
        query: 'test',
        approved: true,
        // Missing action_data
      });
      // When approved is true but action_data is missing, it processes as a new request
      // and returns needs_approval instead of executing
      expect(response.result).toBeDefined();
      expect(response.result.needs_approval).toBe(true);
      expect(response.result.action_type).toBe('send_email');
      logger.logSuccess('Properly handled missing action_data by requiring approval');
    });
    test('should handle approval with minimal but valid action_data', async () => {
      logger.logStep(8, 'Test approval with minimal action_data');
      if (!E2E_CONFIG.nylas.testEmail) {
        logger.logWarning('Skipping - TEST_EMAIL_ADDRESS not set');
        return;
      }
      // Test with minimal but valid action_data
      const response = await client.callTool('manage_email', {
        action: 'send',
        query: 'test',
        approved: true,
        action_data: {
          email_content: {
            to: [E2E_CONFIG.nylas.testEmail],
            subject: `${E2E_CONFIG.testData.emailPrefix} Minimal Test`,
            body: 'Test email with minimal data'
          },
          original_params: {
            action: 'send',
            query: 'test'
          }
        }
      });
      // With valid action_data, the email should be sent successfully
      expect(response.result?.success).toBe(true);
      expect(response.result?.message_id).toBeDefined();
      if (response.result?.message_id) {
        testEmailIds.push(response.result.message_id);
      }
      logger.logSuccess('Successfully handled approval with minimal data');
    });
  });
});
</file>

<file path="CLAUDE.md">
## Development Guidelines
- Make sure you are using proper Nylas documentation and properly using this SDK and researching before making any changes to code
</file>

<file path="docs/CLAUDE.md">
# AI Email Assistant MCP - Transformation Guide

## CRITICAL UPDATE: HTTP-Only Multi-User Architecture (2025-01-26)

### Major Architectural Changes - COMPLETE REMOVAL OF STDIO

We are converting Inbox MCP from stdio-based single-user to HTTP-only multi-user architecture:

1. **Transport Layer**: 
   - **REMOVED**: All stdio transport, MCP SDK stdio dependencies
   - **ADDED**: Express HTTP server with stateless request/response
   - **Endpoints**: Discovery via `/.well-known/a2a.json`; RPC via `POST /a2a/rpc` (methods: `agent.card`, `tool.execute`, `tool.approve`)

2. **Multi-User Support**:
   - Single HTTP server instance handles ALL users
   - User credentials injected per-request via HTTP headers
   - Headers: `X-User-Credential-NYLAS_GRANT_ID`
   - No process spawning, no per-user instances

3. **Credential Management**:
   - **NO LOCAL STORAGE**: No user credential storage on the server
   - Juli stores only the user `grant_id` and injects it per request
   - Nylas API key is a server environment variable
   - SetupManager may validate but does not store credentials
   - **OpenAI API Key**: MCP server provider's responsibility (from environment)

4. **Stateless Architecture**:
   - No global state or cached clients
   - Create Nylas client per-request with injected credentials
   - Complete user isolation through stateless design
   - Stateless approvals - no server-side storage needed

5. **Tool Execution Flow**:
   ```
   User → Juli → HTTP Request with credentials → Inbox MCP
                                                    ↓
                                            Create Nylas client
                                                    ↓
                                              Execute tool
                                                    ↓
                                              Return result
   ```

This makes Inbox MCP a simple, scalable HTTP API that Juli calls with per-request credential injection.

## Development Methodology: Test-Driven Development

ALWAYS REFERENCE THE function_calling.md FILE WHEN DOING STUFF WITH OPENAI DO NOT GUESS RESARCH.

### Red-Green-Refactor Cycle

This transformation should be built using strict TDD principles:

1. **🔴 Red**: Write a failing test for the next small functionality
2. **🟢 Green**: Write the minimum code to make the test pass
3. **🔄 Refactor**: Clean up the code while keeping tests green

### Test-First Approach for Each Component

```typescript
// Example: Testing the manage_email tool

// 1. RED - Write the test first
describe('manage_email tool', () => {
  it('should parse natural language email request', async () => {
    const result = await mcp.handleManageEmail({
      action: 'send',
      query: 'reply to Sarah thanking her for the proposal'
    });
    
    expect(result.type).toBe('approval_required');
    expect(result.preview.details.to).toContain('sarah@example.com');
    expect(result.preview.details.subject).toMatch(/proposal/i);
  });
});

// 2. GREEN - Implement just enough to pass
async handleManageEmail(params) {
  const intent = await this.emailAI.understandQuery(params.query);
  // Minimal implementation
}

// 3. REFACTOR - Clean up and optimize
async handleManageEmail(params) {
  const intent = await this.emailAI.understandQuery(params.query);
  const emailContent = await this.generateEmailContent(intent);
  return this.createApprovalRequest(emailContent);
}
```

### Testing Strategy

1. **Unit Tests**: Each AI function, approval flow, and tool handler
2. **Integration Tests**: MCP protocol compliance, Nylas API interaction
3. **End-to-End Tests**: Complete user flows from natural language to email sent
4. **Mock Everything**: Use mocked Nylas responses and OpenAI calls for fast tests

## Overview

Transform the Inbox MCP into an intelligent email assistant microservice that operates as an "email expert" within the larger Juli AI system. This guide outlines a complete reimagining with AI-first design and seamless approval workflows.

## Core Philosophy

**Think like an AI Email Expert**: Every tool should feel natural when the user says things like "reply to John about the meeting" or "summarize what needs my attention today". The AI handles all the complexity.

## Smart Approval Protocol

### The Problem with Traditional Approvals
Traditional approval flows break the natural conversation. We need something seamless.

### The Solution: Stateless Approval Protocol (Updated 2025-01-26)

**IMPORTANT UPDATE**: We've moved to a fully stateless approval system that doesn't require any server-side storage.

**What Juli Handles:**
- Detecting needs_approval responses
- Rendering approval UI with action preview
- Collecting user decision (approve/deny/modify)
- Retrying the call with complete action data
- No approval tokens or IDs needed

**What MCP Handles:**
- Deciding when approval is needed
- Returning complete action data with preview
- Executing pre-approved actions directly
- No storage of pending approvals

When an action requires approval, the MCP server returns all necessary data for Juli to execute it later:

```typescript
interface ApprovalRequiredResponse {
  needs_approval: true;
  action_type: 'send_email' | 'organize_inbox' | 'apply_smart_folder';
  action_data: any; // Complete data needed to execute the action
  preview: {
    summary: string;
    details: any; // Action-specific details
    risks?: string[]; // Optional warnings
  };
  suggested_modifications?: any;
}
```

Juli's orchestrator intercepts these responses and shows a native approval UI. When approved, it calls the tool again with the complete action data:

```typescript
// First call
AI: manage_email({ action: "send", query: "reply to John about postponing the meeting" })
MCP: { 
  needs_approval: true,
  action_type: "send_email",
  action_data: { 
    email_content: { to: ["john@company.com"], subject: "Re: Meeting", body: "..." },
    original_params: { action: "send", query: "..." }
  },
  preview: { summary: "Email to john@company.com", ... }
}

// After user approves in Juli UI
AI: manage_email({ 
  action: "send", 
  query: "reply to John about postponing the meeting",
  approved: true,
  action_data: { 
    email_content: { to: ["john@company.com"], subject: "Re: Meeting", body: "..." },
    original_params: { action: "send", query: "..." }
  }
})
MCP: { success: true, message: "Email sent", message_id: "msg_123" }
```

**Benefits of Stateless Approach:**
- No server-side storage required
- Works perfectly with horizontal scaling
- Juli has full visibility of action data
- No cleanup timers or expiration handling
- Simpler architecture overall

## Authentication: Guided Self-Service Setup

### The Challenge
Nylas requires users to create an account, get an API key, and create a grant. This is friction we need to minimize with smart tooling.

### Responsibility Division

#### What Juli Handles:
- **Credential Storage**: Juli securely stores all credentials after validation
- **User Identity**: Juli provides the userId to the MCP server
- **UI Rendering**: Juli renders setup instructions and forms beautifully
- **Persistence**: Juli remembers which users have completed setup
- **Security**: Encryption, key management, and secure transmission

#### What the MCP Provider (You) Handle:
- **Setup Guidance**: Provide clear, structured setup instructions
- **Credential Validation**: Test that provided credentials actually work
- **Error Diagnostics**: Help users troubleshoot setup issues
- **Connection Testing**: Verify the email connection is functional
- **Graceful Degradation**: Handle missing credentials intelligently

### Solution: Intelligent Setup Tool with Verification
The MCP server provides a setup tool that returns structured data for Juli to render:

```typescript
{
  name: "setup_email_connection",
  description: "Set up your email connection with step-by-step guidance and automatic verification",
  parameters: {
    action: {
      type: "string",
      enum: ["get_instructions", "validate_credentials", "test_connection", "troubleshoot"],
      description: "What setup action to perform"
    },
    credentials: {
      type: "object",
      optional: true,
      properties: {
        nylas_api_key: { 
          type: "string",
          description: "Your Nylas API key from the dashboard"
        },
        nylas_grant_id: { 
          type: "string",
          description: "The grant ID after connecting your email" 
        }
      }
    },
    issue: {
      type: "string",
      optional: true,
      description: "Describe any issues you're having with setup"
    }
  }
}
```

### Detailed Setup Flow Implementation

```typescript
class IntelligentEmailSetup {
  private setupCache = new Map<string, SetupProgress>();
  
  async handleSetupEmailConnection(params: SetupParams, context: MCPContext): Promise<SetupResponse> {
    const userId = context.userId;
    
    switch (params.action) {
      case "get_instructions":
        return this.getDetailedInstructions(userId);
        
      case "validate_credentials":
        return this.validateAndStoreCredentials(params.credentials, userId);
        
      case "test_connection":
        return this.testEmailConnection(userId);
        
      case "troubleshoot":
        return this.troubleshootIssue(params.issue, userId);
    }
  }
  
  private async getDetailedInstructions(userId: string): Promise<InstructionResponse> {
    // Track setup progress
    this.setupCache.set(userId, { stage: 'instructions_viewed', timestamp: Date.now() });
    
    return {
      type: "setup_instructions",
      title: "Email Setup Guide",
      estimated_time: "5 minutes",
      steps: [
        {
          step: 1,
          title: "Create Your Free Nylas Account",
          description: "Nylas provides 5 free email connections - perfect for personal use!",
          actions: [
            {
              type: "link",
              label: "Open Nylas Signup",
              url: "https://dashboard-v3.nylas.com/register?utm_source=juli",
              description: "Opens in a new window"
            }
          ],
          tips: [
            "Use the same email you'll be connecting later",
            "No credit card required for free tier"
          ]
        },
        {
          step: 2,
          title: "Get Your API Key",
          description: "After signing in, find your API key in the dashboard",
          visual_guide: {
            description: "Look for 'API Keys' in the left sidebar",
            highlight_area: "sidebar > api_keys_section"
          },
          actions: [
            {
              type: "copy_field",
              label: "I'll paste my API key here",
              field: "nylas_api_key",
              validation: "regex:^nyk_[a-zA-Z0-9]+$"
            }
          ],
          tips: [
            "API key starts with 'nyk_'",
            "Keep this key secret - it's like a password!"
          ]
        },
        {
          step: 3,
          title: "Connect Your Email Account",
          description: "Add your email account to Nylas",
          substeps: [
            "Click 'Grants' in the sidebar",
            "Click 'Add Test Grant' button (top right)",
            "Choose your email provider (Gmail, Outlook, etc)",
            "Authorize Nylas to access your email",
            "Copy the Grant ID that appears"
          ],
          actions: [
            {
              type: "copy_field",
              label: "I'll paste my Grant ID here",
              field: "nylas_grant_id",
              validation: "regex:^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$"
            }
          ],
          common_issues: [
            {
              issue: "Can't find Grant ID",
              solution: "It's in the table under the 'ID' column after you connect"
            },
            {
              issue: "Authorization failed",
              solution: "Make sure to allow all requested permissions"
            }
          ]
        }
      ],
      next_step: {
        description: "Once you have both credentials, run:",
        command: "setup_email_connection",
        parameters: {
          action: "validate_credentials",
          credentials: {
            nylas_api_key: "your_key_here",
            nylas_grant_id: "your_grant_id_here"
          }
        }
      },
      help: {
        video_tutorial: "https://juli.ai/tutorials/email-setup",
        support_email: "support@juli.ai"
      }
    };
  }
  
  private async validateAndStoreCredentials(
    credentials: Credentials, 
    userId: string
  ): Promise<ValidationResponse> {
    // Input validation
    if (!credentials?.nylas_api_key || !credentials?.nylas_grant_id) {
      return {
        type: "validation_error",
        message: "Both API key and Grant ID are required",
        missing_fields: [
          !credentials?.nylas_api_key && "nylas_api_key",
          !credentials?.nylas_grant_id && "nylas_grant_id"
        ].filter(Boolean)
      };
    }
    
    // Format validation
    if (!credentials.nylas_api_key.startsWith('nyk_')) {
      return {
        type: "validation_error",
        message: "API key should start with 'nyk_'",
        field: "nylas_api_key",
        hint: "Check you copied the full API key from Nylas dashboard"
      };
    }
    
    // Test the credentials
    try {
      const testClient = new Nylas({ apiKey: credentials.nylas_api_key });
      
      // Try to fetch account info to verify grant
      const account = await testClient.grants.find({
        identifier: credentials.nylas_grant_id
      });
      
      // Get email address for confirmation
      const emailAddress = account.data.email || "your email";
      
      // Success! Return credentials for Juli to store
      return {
        type: "setup_success",
        message: `Successfully connected ${emailAddress}!`,
        credentials_validated: true,
        credentials_to_store: {
          nylas_api_key: credentials.nylas_api_key,
          nylas_grant_id: credentials.nylas_grant_id,
          email_address: emailAddress,
          provider: account.data.provider // gmail, outlook, etc
        },
        next_steps: [
          "Your email is now connected",
          "Try: 'find my unread emails' or 'summarize today's emails'"
        ]
      };
      
    } catch (error: any) {
      // Detailed error handling
      if (error.statusCode === 401) {
        return {
          type: "auth_error",
          message: "Invalid API key",
          suggestion: "Double-check your API key from the Nylas dashboard",
          retry_action: "setup_email_connection",
          retry_params: { action: "get_instructions" }
        };
      } else if (error.statusCode === 404) {
        return {
          type: "grant_error",
          message: "Grant ID not found",
          suggestion: "Make sure you completed the 'Add Test Grant' step",
          details: "The Grant ID should be from the same account as your API key"
        };
      } else {
        return {
          type: "connection_error",
          message: "Could not connect to Nylas",
          error_details: error.message,
          troubleshoot_action: "setup_email_connection",
          troubleshoot_params: { 
            action: "troubleshoot",
            issue: error.message 
          }
        };
      }
    }
  }
  
  private async testEmailConnection(userId: string): Promise<TestResponse> {
    // This would be called after Juli has stored the credentials
    try {
      // Fetch a few recent emails as a test
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: { limit: 5 }
      });
      
      return {
        type: "connection_test_success",
        message: "Email connection is working perfectly!",
        stats: {
          emails_accessible: true,
          recent_email_count: messages.data.length,
          oldest_email_date: messages.data[messages.data.length - 1]?.date
        },
        ready_to_use: true
      };
    } catch (error) {
      return {
        type: "connection_test_failed",
        message: "Connection test failed",
        error: error.message,
        suggestion: "Try re-validating your credentials"
      };
    }
  }
  
  private async troubleshootIssue(issue: string, userId: string): Promise<TroubleshootResponse> {
    // AI-powered troubleshooting
    const commonIssues = {
      "permission": {
        keywords: ["permission", "denied", "access"],
        solution: "Re-authorize your email in Nylas dashboard with all permissions enabled"
      },
      "grant_expired": {
        keywords: ["expired", "invalid grant"],
        solution: "Create a new test grant in Nylas dashboard - they expire after 30 days"
      },
      "rate_limit": {
        keywords: ["rate", "limit", "429"],
        solution: "You've hit the rate limit. Wait a few minutes and try again"
      }
    };
    
    // Find matching issue
    const matchedIssue = Object.entries(commonIssues).find(([key, data]) =>
      data.keywords.some(keyword => issue.toLowerCase().includes(keyword))
    );
    
    if (matchedIssue) {
      return {
        type: "troubleshoot_solution",
        identified_issue: matchedIssue[0],
        solution: matchedIssue[1].solution,
        steps_to_fix: this.getFixSteps(matchedIssue[0])
      };
    }
    
    // Generic troubleshooting
    return {
      type: "troubleshoot_generic",
      message: "Let's debug this together",
      diagnostic_steps: [
        "Verify your Nylas account is active",
        "Check if your API key is still valid",
        "Ensure your email grant hasn't expired",
        "Try creating a fresh test grant"
      ],
      contact_support: {
        juli_support: "support@juli.ai",
        nylas_docs: "https://developer.nylas.com/docs/v3/"
      }
    };
  }
}
```

### How Juli and MCP Work Together

#### 1. Initial Connection (No Credentials)
```typescript
// Juli attempts to connect to MCP
Juli → MCP: Connect with userId="user123", credentials=undefined

// MCP detects missing credentials
MCP → Juli: {
  type: "needs_configuration",
  service: "nylas_email",
  setup_required: true,
  tools_available: ["setup_email_connection"],
  message: "Email not connected. Run 'setup_email_connection' to begin."
}

// Juli shows this to user and suggests the setup tool
```

#### 2. During Setup
```typescript
// User runs setup tool
User → Juli: "setup_email_connection"
Juli → MCP: setup_email_connection({ action: "get_instructions" })

// MCP returns structured instructions
MCP → Juli: {
  type: "setup_instructions",
  // Structured data that Juli renders beautifully
}

// User provides credentials
User → Juli: [Enters credentials in Juli's UI]
Juli → MCP: setup_email_connection({ 
  action: "validate_credentials",
  credentials: { nylas_api_key: "...", nylas_grant_id: "..." }
})

// MCP validates and returns result
MCP → Juli: {
  type: "setup_success",
  credentials_validated: true,
  credentials_to_store: { ... } // Juli stores these securely
}
```

#### 3. Future Connections
```typescript
      // Juli provides stored credentials automatically (grant only)
      Juli → MCP: Connect with userId="user123", headers={
        'X-User-Credential-NYLAS_GRANT_ID': 'grant_id'
      }

// MCP initializes normally
MCP: Ready to handle email operations
```

### Developer Experience Benefits

#### For MCP Developers:
- **No Credential Management**: Juli handles all storage/encryption
- **Simple Validation**: Just test if credentials work, return result
- **Structured Responses**: Return data, Juli handles presentation
- **Focus on Logic**: Write email functionality, not auth infrastructure

#### For End Users:
- **One-Time Setup**: Credentials stored securely by Juli
- **Beautiful UI**: Juli renders instructions with proper formatting
- **Integrated Experience**: Feels native to Juli, not bolted-on
- **Smart Recovery**: Clear error messages and troubleshooting

### MCP Implementation Simplicity

```typescript
class AIEmailAssistantMCP extends McpServer {
  private nylas?: Nylas;
  private grantId?: string;
  
  constructor() {
    super({ 
      name: "ai-email-assistant", 
      version: "2.0.0",
      description: "AI-powered email expert"
    });
  }
  
  // Called by Juli on each connection
  async initialize(context: MCPContext) {
    if (!context.credentials?.nylas_api_key) {
      // Just tell Juli setup is needed
      return { needs_setup: true };
    }
    
    // Initialize with provided credentials
    this.nylas = new Nylas({ 
      apiKey: context.credentials.nylas_api_key 
    });
    this.grantId = context.credentials.nylas_grant_id;
  }
  
  // Tools are only registered if credentials exist
  registerTools() {
    if (!this.nylas) {
      // Only setup tool available
      this.registerTool("setup_email_connection", this.handleSetup);
      return;
    }
    
    // All email tools available
    this.registerTool("manage_email", this.handleManageEmail);
    this.registerTool("find_emails", this.handleFindEmails);
    // ... other tools
  }
}
```

## The 5 Essential Tools (AI-First Design)

### 1. `manage_email`
**The Swiss Army Knife of Email Actions**

```typescript
{
  name: "manage_email",
  description: "Send, reply, forward, or draft emails using natural language. Handles all email composition intelligently.",
  parameters: {
    action: {
      type: "string",
      enum: ["send", "reply", "forward", "draft"],
      description: "What to do with the email"
    },
    query: {
      type: "string", 
      description: "Natural language description of what you want. Examples: 'reply to Sarah thanking her for the proposal', 'forward the AWS alerts to the dev team with a summary', 'draft a follow-up to yesterday's meeting attendees'"
    },
    context_message_id: {
      type: "string",
      optional: true,
      description: "ID of email being replied to or forwarded (AI will find it if not provided)"
    },
    require_approval: {
      type: "boolean",
      default: true,
      description: "Whether to require approval before sending"
    }
  }
}
```

**How it works**: 
- AI analyzes the query to understand intent
- Finds relevant emails if replying/forwarding
- Generates appropriate content with proper tone
- Returns approval request with preview
- Sends after approval

### 2. `find_emails`
**Intelligent Email Search & Analysis**

```typescript
{
  name: "find_emails",
  description: "Find and analyze emails using natural language. Returns summaries and insights.",
  parameters: {
    query: {
      type: "string",
      description: "What you're looking for. Examples: 'unread emails from my manager', 'invoices from last month', 'important emails I haven't responded to', 'emails about the Q3 project'"
    },
    analysis_type: {
      type: "string",
      enum: ["summary", "detailed", "action_items", "priority"],
      default: "summary",
      description: "How to analyze the found emails"
    },
    limit: {
      type: "integer",
      default: 20,
      description: "Maximum emails to analyze"
    }
  }
}
```

**AI Features**:
- Natural language date parsing ("last week", "yesterday")
- Importance detection using GPT-4
- Automatic categorization
- Thread grouping
- Action item extraction

### 3. `organize_inbox`
**Bulk Intelligent Email Management**

```typescript
{
  name: "organize_inbox",
  description: "Organize, clean up, or triage emails in bulk using AI-powered rules",
  parameters: {
    instruction: {
      type: "string",
      description: "What you want to do. Examples: 'archive all newsletters older than a week', 'star emails that need responses', 'move receipts to a folder', 'clean up promotional emails keeping only important ones'"
    },
    scope: {
      type: "object",
      properties: {
        folder: { type: "string", default: "inbox" },
        date_range: { type: "string", optional: true },
        limit: { type: "integer", default: 100 }
      }
    },
    dry_run: {
      type: "boolean",
      default: true,
      description: "Preview what would happen without making changes"
    }
  }
}
```

**AI Capabilities**:
- Understands complex organizational rules
- Identifies email patterns (newsletters, receipts, notifications)
- Smart importance scoring
- Bulk operations with safety checks

### 4. `email_insights`
**Intelligent Email Analytics & Insights**

```typescript
{
  name: "email_insights",
  description: "Get AI-powered insights about your email patterns, important items, and what needs attention",
  parameters: {
    insight_type: {
      type: "string",
      enum: ["daily_summary", "important_items", "response_needed", "analytics", "relationships"],
      description: "Type of insight to generate"
    },
    time_period: {
      type: "string",
      default: "today",
      description: "Time period to analyze (natural language like 'this week', 'last month')"
    },
    focus_area: {
      type: "string",
      optional: true,
      description: "Specific area to focus on (e.g., 'project X', 'client communications')"
    }
  }
}
```

**Insights Provided**:
- Daily summaries with priority items
- Response time analytics
- Communication patterns
- Important relationships
- Trending topics
- Workload analysis

### 5. `smart_folders`
**AI-Powered Dynamic Folder Management**

```typescript
{
  name: "smart_folders",
  description: "Create or manage intelligent folders that automatically organize emails based on AI understanding",
  parameters: {
    action: {
      type: "string",
      enum: ["create", "update", "apply", "list"],
      description: "Operation to perform"
    },
    rule: {
      type: "string",
      description: "Natural language rule. Examples: 'create a folder for urgent client emails', 'organize by project automatically', 'separate personal from work emails'"
    },
    folder_name: {
      type: "string",
      optional: true,
      description: "Name for the folder (AI suggests if not provided)"
    }
  }
}
```

**Smart Features**:
- AI understands intent and creates rules
- Dynamic categorization
- Auto-organization based on patterns
- Learns from user corrections

## Implementation Architecture

### Credential Flow (Hosted Auth)

```typescript
// MCP server receives credentials from Juli
interface MCPContext {
  userId: string;
  credentials?: { nylas_grant_id?: string };
}

class AIEmailAssistantMCP extends McpServer {
  private nylas?: Nylas;
  private emailAI: EmailAI;
  
  async initialize(context: MCPContext) {
    if (!process.env.NYLAS_API_KEY || !context.credentials?.nylas_grant_id) {
      return this.setupNeededResponse();
    }
    this.nylas = new Nylas({ apiKey: process.env.NYLAS_API_KEY });
    this.grantId = context.credentials.nylas_grant_id;
  }
  
  private setupNeededResponse() {
    return {
      type: "needs_configuration",
      connect_url: "/setup/connect-url",
      message: "Email not connected. Open connect_url to authenticate.",
      documentation_url: "/docs/email-setup"
    };
  }
}
```

### OpenAI Integration Layer

```typescript
class EmailAI {
  private openai: OpenAI;
  
  async understandQuery(query: string, context?: EmailContext): Promise<EmailIntent> {
    // Use GPT-4 to understand natural language email requests
    const response = await this.openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: `You are an email assistant. Analyze the user's request and extract:
          - Intent (send, reply, forward, find, organize)
          - Recipients (if applicable)
          - Key topics or context
          - Urgency level
          - Required email content points`
        },
        {
          role: "user",
          content: query
        }
      ],
      response_format: { type: "json_object" }
    });
    
    return JSON.parse(response.choices[0].message.content);
  }
  
  async generateEmailContent(intent: EmailIntent, context?: Email): Promise<GeneratedEmail> {
    // Generate professional email content based on intent
  }
  
  async analyzeImportance(emails: Email[]): Promise<ImportanceScore[]> {
    // Batch analyze emails for importance/priority
  }
}
```

## User Experience Examples

### Natural Conversations

**User**: "Reply to Sarah's email about the budget proposal thanking her and asking for more details on Q3 projections"

**AI Email Assistant**:
1. Finds Sarah's most recent email about budget
2. Generates a professional reply
3. Shows preview for approval
4. Sends after confirmation

**User**: "Find all important emails I haven't responded to this week"

**AI Email Assistant**:
1. Searches for emails from this week
2. Analyzes importance using AI
3. Filters for those without replies
4. Returns organized summary with action items

**User**: "Clean up my inbox but keep anything that looks important"

**AI Email Assistant**:
1. Analyzes all inbox emails
2. Scores importance using GPT-4
3. Shows cleanup plan (dry run)
4. Executes after approval

## Security & Privacy

### Data Protection
- Email content never stored by MCP server
- All processing in-memory only
- Credentials passed securely from Juli
- No logging of email content
- PII automatically masked in any logs

### Access Control
- Credentials scoped per user
- Automatic token refresh handled by Juli
- Rate limiting per operation
- Audit logging for actions (not content)

## Monitoring & Analytics

### Key Metrics
- Email processing latency
- AI response quality scores
- Approval/rejection rates
- User satisfaction metrics
- Error rates by operation type

### Observability
```typescript
interface EmailOperationTrace {
  operation_id: string;
  user_id: string;
  tool: string;
  ai_processing_time: number;
  nylas_api_time: number;
  total_time: number;
  approval_required: boolean;
  outcome: "success" | "failed" | "cancelled";
}
```

## Future Enhancements

1. **Voice Integration**: "Hey Juli, read me my important emails"
2. **Smart Scheduling**: AI-powered meeting scheduling via email
3. **Email Templates**: Learning from user's writing style
4. **Team Features**: Shared inboxes and delegation
5. **Advanced Analytics**: Communication insights and optimization

## Implementation Priorities

### Phase 1: Core Infrastructure (Week 1)
- Credential handling from Juli
- Basic tool registration
- OpenAI integration setup

### Phase 2: Essential Tools (Week 2)
- `manage_email` with approval flow
- `find_emails` with AI analysis
- `email_insights` basic implementation

### Phase 3: Advanced Features (Week 3)
- `organize_inbox` with safety checks
- `smart_folders` implementation
- Enhanced AI capabilities

### Phase 4: Polish & Testing (Week 4)
- Comprehensive testing
- Performance optimization
- User experience refinement

## Developer Experience Summary

### What You (MCP Developer) Are Responsible For:

1. **Core Functionality**
   - Email operations (send, search, organize)
   - AI integration for natural language understanding
   - Business logic and email intelligence

2. **Setup Assistance**
   - Providing clear setup instructions
   - Validating credentials work correctly
   - Helpful error messages for troubleshooting

3. **Approval Logic**
   - Deciding when approval is needed
   - Generating meaningful previews
   - Temporarily storing pending actions

4. **Graceful Handling**
   - Detecting missing credentials
   - Returning structured responses
   - Clear error states

### What Juli Handles For You:

1. **All Infrastructure**
   - Credential storage and encryption
   - User authentication and identity
   - Session management
   - Security and compliance

2. **User Interface**
   - Beautiful rendering of your responses
   - Forms for credential input
   - Approval dialogs
   - Error display

3. **Developer Quality of Life**
   - Automatic credential injection
   - Retry logic for failed calls
   - Rate limiting
   - Analytics and monitoring

### The Developer Journey:

```typescript
// 1. Simple MCP server setup
class EmailAssistant extends McpServer {
  name = "ai-email-assistant";
  
  // 2. Check for credentials
  initialize(context) {
    if (!context.credentials) {
      return { needs_setup: true };
    }
    // Initialize your service
  }
  
  // 3. Implement your tools
  async handleManageEmail(params) {
    // Your email logic here
    if (needsApproval) {
      return { 
        type: "approval_required",
        preview: generatedEmail 
      };
    }
    // Send email
  }
}

// That's it! Juli handles the rest.
```

### Why This Architecture?

**For Developers:**
- Focus on your domain expertise (email AI)
- No auth infrastructure to build
- Clear boundaries of responsibility
- Structured data exchange

**For Users:**
- Consistent experience across all Juli tools
- One-time setup per service
- Beautiful, integrated UI
- Seamless approvals

**For Juli:**
- Maintain security standards
- Provide consistent UX
- Enable rapid tool development
- Scale to many services

## Conclusion

This transformation creates a truly intelligent email assistant that:
- Understands natural language perfectly
- Handles approvals seamlessly
- Provides genuine AI-powered insights
- Integrates smoothly with Juli's credential management
- Feels like a natural extension of Juli's AI capabilities

The key is thinking "AI-first" - users should just say what they want naturally, and the system handles all complexity behind the scenes. As a developer, you focus on making the best email AI possible, while Juli handles all the platform concerns. This separation of concerns creates the best experience for everyone involved.
</file>

<file path="docs/MCP_DEVELOPER_GUIDE.md">
# MCP Developer Guide for Juli Platform

A comprehensive guide to building Model Context Protocol (MCP) servers for Juli - the AI platform used by thousands of users worldwide.

## Table of Contents
- [Overview](#overview)
- [Juli Authentication System](#juli-authentication-system)
- [MCP Protocol Specification](#mcp-protocol-specification)
- [Building Your MCP Server](#building-your-mcp-server)
- [Tool Design Best Practices](#tool-design-best-practices)
- [Testing and Deployment](#testing-and-deployment)

## Overview

### What is Juli?

Juli is an AI platform that orchestrates multiple AI models and tools to help users accomplish complex tasks. MCP servers extend Juli's capabilities by providing specialized tools that integrate with external services.

### What is MCP?

Model Context Protocol (MCP) is a standardized way for AI systems to interact with external tools and services. It defines:
- How tools are discovered and described
- How requests and responses are formatted
- How authentication and context are handled
- How approvals and safety checks work

### Why Build for Juli?

- **Reach thousands of users** - Juli's growing user base needs quality tools
- **Monetization** - Premium MCP servers can generate revenue
- **Simple integration** - Juli handles all the complex infrastructure
- **Focus on your expertise** - Build tools in domains you know best

## Juli Authentication System

### How Juli Handles Credentials

Juli implements a secure, user-friendly authentication system that makes using MCP servers seamless:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│                 │     │                 │     │                 │
│   Juli Client   │────▶│  Juli Platform  │────▶│   MCP Server    │
│                 │     │                 │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                       │                         │
        │                       │                         │
    User provides           Stores & manages         Receives creds
    credentials once        credentials              per request
```

### Setup Flow (Hosted Auth)

Important: Users authenticate via Nylas Hosted Auth. The server keeps `NYLAS_API_KEY` in env and returns a `grant_id`. MCP servers are stateless and never store per-user credentials.

When a user first installs your MCP:

```typescript
// 1) Juli checks if setup is needed
GET /setup/status
Response: { "needs_setup": true, "connect_url": "/setup/connect-url" }

// 2) Juli fetches the Hosted Auth URL
GET /setup/connect-url?redirect_uri=https://yourapp.com/api/nylas-email/callback
Response: { "url": "https://api.us.nylas.com/v3/connect/auth?..." }

// 3) User completes provider login; callback returns the grant
GET /api/nylas-email/callback?code=...
Response: { "success": true, "grant_id": "...", "email": "user@example.com" }

// 4) Juli stores only the grant_id
// 5) Every future request includes:
Headers: { "X-User-Credential-NYLAS_GRANT_ID": "..." }
```

### Agent-to-Agent (A2A)

For inter-agent integrations, use JSON‑RPC A2A:

- Discovery: `GET /.well-known/a2a.json` (Agent Card)
- RPC endpoint: `POST /a2a/rpc` (JSON‑RPC 2.0)
- Methods:
  - `agent.card` → Agent Card
  - `agent.handshake` → `{ agent, card, server_time }`
  - `tool.execute` → params `{ tool, arguments, user_context, request_id }`
  - `tool.approve` → params `{ tool, original_arguments, action_data, user_context, request_id }`

Auth:
- Use the Agent Card `auth` scheme(s). OIDC ID token in `Authorization: Bearer <id_token>` (audience per card). Dev: optional `X-A2A-Dev-Secret`.

The server remains stateless; only `NYLAS_API_KEY` is in env. User grant is injected per-request.

### Credential acquisition (optional manifest)

Agents may publish `GET /.well-known/a2a-credentials.json` describing how Brain can obtain credentials it must inject. Example:

```json
{
  "credentials": [
    {
      "key": "EMAIL_ACCOUNT_GRANT",
      "display_name": "Email Account Grant",
      "sensitive": true,
      "flows": [
        {
          "type": "hosted_auth",
          "connect_url": "/setup/connect-url",
          "callback": "/api/nylas-email/callback",
          "provider_scopes": {
            "google": [
              "openid",
              "https://www.googleapis.com/auth/userinfo.email",
              "https://www.googleapis.com/auth/userinfo.profile",
              "https://www.googleapis.com/auth/gmail.modify",
              "https://www.googleapis.com/auth/contacts",
              "https://www.googleapis.com/auth/contacts.readonly",
              "https://www.googleapis.com/auth/contacts.other.readonly"
            ],
            "microsoft": ["Mail.ReadWrite","Mail.Send","Contacts.Read","Contacts.Read.Shared"]
          }
        }
      ]
    }
  ]
}
```

### Request Format

All tool execution requests follow this format:

```typescript
POST /a2a/rpc (JSON-RPC 2.0)
Headers: {
  "Content-Type": "application/json",
  "X-Request-ID": "unique-request-id",
  "X-User-ID": "juli-user-id",
  "X-User-Credential-NYLAS_GRANT_ID": "uuid"
}
Body: {
  // Tool-specific parameters
  "param1": "value1",
  "param2": "value2"
}
```

### Response Format

#### Success Response
```typescript
{
  "success": true,
  "data": {}
}
```

#### Error Response
```typescript
{
  "error": "User-friendly error message",
  "error_code": "RATE_LIMIT_EXCEEDED"
}
```

#### Needs Setup Response
```typescript
{
  "needs_setup": true,
  "message": "Please complete setup to use this tool",
  "connect_url": "/setup/connect-url"
}
```

### Tool Discovery Format

```typescript
GET /.well-known/a2a.json
Response: {
  "tools": [
    {
      "name": "tool_name",
      "description": "Clear description of what this tool does",
      "inputSchema": {
        "type": "object",
        "properties": {
          "param1": {
            "type": "string",
            "description": "What this parameter does"
          },
          "param2": {
            "type": "number",
            "description": "Another parameter",
            "minimum": 0,
            "maximum": 100
          }
        },
        "required": ["param1"]
      }
    }
  ]
}
```

### Context Injection

Juli can automatically inject user context into tool calls:

```typescript
// In your tool schema
"inputSchema": {
  "type": "object",
  "properties": {
    "message": {
      "type": "string",
      "description": "Message to send"
    },
    "user_name": {
      "type": "string",
      "description": "User's name",
      "x-context-injection": "user_name"  // Juli auto-fills
    },
    "user_timezone": {
      "type": "string",
      "description": "User's timezone",
      "x-context-injection": "user_timezone"
    }
  }
}
```

Available context fields:
- `user_name` - User's display name
- `user_email` - User's email address
- `user_timezone` - User's timezone (e.g., "America/New_York")
- `current_date` - Current date in user's timezone
- `current_time` - Current time in user's timezone

## Building Your MCP Server

### Critical Design Principle: Stateless Credential Handling

MCP servers are stateless regarding user credentials. Extract credentials from headers per request and never store them.

```typescript
function handleRequest(req) {
  const credentials = extractCredentials(req.headers);
  const client = new ServiceClient(process.env.NYLAS_API_KEY);
  return client.doWork(credentials.nylas_grant_id);
}
```

**Why Stateless?**
- **Security**: No credential leaks if server is compromised
- **Scalability**: Servers can be scaled horizontally without session affinity
- **Reliability**: Server restarts don't affect users
- **Multi-tenancy**: One server instance serves all users safely

### Server Architecture

```typescript
import express from 'express';
import { z } from 'zod';

class MCPServer {
  private app: express.Application;
  private tools: Map<string, Tool>;
  
  constructor() {
    this.app = express();
    this.tools = new Map();
    this.setupMiddleware();
    this.setupRoutes();
  }
  
  private setupMiddleware() {
    this.app.use(express.json());
    this.app.use(this.logRequests);
    this.app.use(this.extractCredentials);
  }
  
  private extractCredentials(req, res, next) {
    req.credentials = {};
    
    // Extract all X-User-Credential-* headers
    Object.keys(req.headers).forEach(header => {
      if (header.startsWith('x-user-credential-')) {
        const credName = header.replace('x-user-credential-', '');
        req.credentials[credName] = req.headers[header];
      }
    });
    
    next();
  }
  
  private setupRoutes() {
    this.app.get('/health', (req, res) => {
      res.json({ status: 'healthy', version: '1.0.0' });
    });
    
    this.app.get('/setup/status', (req, res) => {
      const needsSetup = !this.hasRequiredCredentials(req.credentials);
      res.json({
        needs_setup: needsSetup,
        auth_type: 'api_key',
        service_name: 'Your Service',
        setup_tool: 'setup_service'
      });
    });
    
    // Removed. Use A2A Agent Card.
      const tools = Array.from(this.tools.values()).map(tool => ({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.getSchema()
      }));
      res.json({ tools });
    });
    
    // Removed. Use /a2a/rpc JSON-RPC methods.
      try {
        const { toolName } = req.params;
        const tool = this.tools.get(toolName);
        
        if (!tool) {
          return res.status(404).json({
            error: `Tool '${toolName}' not found`
          });
        }
        
        // Check credentials
        if (!this.hasRequiredCredentials(req.credentials)) {
          return res.json({
            needs_setup: true,
            message: 'Please complete setup first',
            setup_tool: 'setup_service'
          });
        }
        
        // Validate input
        const validatedInput = tool.validateInput(req.body);
        
        // Execute tool
        const result = await tool.execute(validatedInput, req.credentials);
        
        res.json(result);
      } catch (error) {
        console.error(`Error in tool ${req.params.toolName}:`, error);
        res.status(500).json({
          error: 'An error occurred processing your request',
          error_code: 'INTERNAL_ERROR'
        });
      }
    });
  }
}
```

### Tool Implementation Pattern

```typescript
abstract class Tool {
  constructor(
    public name: string,
    public description: string
  ) {}
  
  abstract getSchema(): object;
  abstract validateInput(input: any): any;
  abstract execute(input: any, credentials: any): Promise<any>;
}

class ExampleTool extends Tool {
  constructor() {
    super(
      'example_tool',
      'Does something useful with natural language'
    );
  }
  
  getSchema() {
    return {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Natural language description of what you want'
        },
        options: {
          type: 'object',
          properties: {
            include_details: {
              type: 'boolean',
              default: false
            }
          }
        }
      },
      required: ['query']
    };
  }
  
  validateInput(input: any) {
    // Use zod or another validator
    const schema = z.object({
      query: z.string().min(1),
      options: z.object({
        include_details: z.boolean().optional()
      }).optional()
    });
    
    return schema.parse(input);
  }
  
  async execute(input: any, credentials: any) {
    // Create service client with credentials
    const client = new YourServiceClient({
      apiKey: credentials.api_key
    });
    
    try {
      // Process natural language
      const intent = await this.understandQuery(input.query);
      
      // Execute action
      const result = await client.doSomething(intent);
      
      return {
        success: true,
        data: result
      };
    } catch (error) {
      if (error.code === 'RATE_LIMIT') {
        return {
          error: 'Rate limit exceeded. Please try again later.',
          error_code: 'RATE_LIMIT_EXCEEDED',
          details: {
            retry_after: 60
          }
        };
      }
      throw error;
    }
  }
}
```

### Stateless Design Principles

1. **No Session State**
   ```typescript
   // ❌ Bad: Storing user state
   const userSessions = new Map();
   
   // ✅ Good: Everything in request
   function handleRequest(req) {
     const credentials = req.credentials;
     const client = createClient(credentials);
     return client.doWork();
   }
   ```

2. **Request-Scoped Clients**
   ```typescript
   // ❌ Bad: Global client
   const client = new ServiceClient(process.env.API_KEY);
   
   // ✅ Good: Per-request client
   function handleRequest(req) {
     const client = new ServiceClient(req.credentials.api_key);
     return client.doWork();
   }
   ```

3. **Horizontal Scaling Ready**
   ```typescript
   // Your server should work with multiple instances
   // No in-memory caches for user data
   // No local file storage for user content
   // Use external services for persistence if needed
   ```

## Tool Design Best Practices

### 1. Natural Language First

```typescript
// ❌ Bad: Technical parameters
{
  name: "execute_query",
  parameters: {
    sql: "SELECT * FROM users WHERE...",
    database: "production",
    timeout: 30000
  }
}

// ✅ Good: Natural language
{
  name: "find_data",
  parameters: {
    query: "Show me active users from last week",
    include_details: true
  }
}
```

### 2. Progressive Disclosure

```typescript
// Start simple
{
  name: "analyze_data",
  parameters: {
    query: "What are my top selling products?"
  }
}

// Allow advanced options
{
  name: "analyze_data",
  parameters: {
    query: "What are my top selling products?",
    options: {
      time_range: "last_quarter",
      group_by: "category",
      include_trends: true
    }
  }
}
```

### 3. Clear Descriptions

```typescript
{
  name: "manage_email",
  description: "Send, reply, forward, or draft emails using natural language. Handles all email composition intelligently.",
  inputSchema: {
    type: "object",
    properties: {
      action: {
        type: "string",
        enum: ["send", "reply", "forward", "draft"],
        description: "What to do with the email"
      },
      query: {
        type: "string",
        description: "Natural language description. Examples: 'reply to Sarah thanking her for the proposal', 'forward the AWS alerts to the dev team with a summary'"
      }
    }
  }
}
```

### 4. Error Messages Users Understand

```typescript
// ❌ Bad: Technical errors
{
  error: "Connection timeout: ETIMEDOUT 192.168.1.1:5432"
}

// ✅ Good: User-friendly errors
{
  error: "Unable to connect to your database. Please check if your database is online and accessible.",
  error_code: "DATABASE_UNAVAILABLE",
  details: {
    suggestion: "Try again in a few moments or contact your database administrator"
  }
}
```

### 5. Approval Flow for Sensitive Actions

```typescript
async function deleteData(params, credentials) {
  // Calculate impact
  const itemsToDelete = await findItems(params.filter);
  
  // Request approval for large deletions
  if (itemsToDelete.length > 10) {
    return {
      needs_approval: true,
      action_type: 'bulk_delete',
      action_data: {
        filter: params.filter,
        ids: itemsToDelete.map(i => i.id)
      },
      preview: {
        summary: `Delete ${itemsToDelete.length} items`,
        details: {
          oldest_item: itemsToDelete[0].created_at,
          newest_item: itemsToDelete[itemsToDelete.length - 1].created_at
        },
        risks: ['This action cannot be undone']
      }
    };
  }
  
  // Execute for small deletions
  await performDelete(itemsToDelete);
  return {
    success: true,
    message: `Deleted ${itemsToDelete.length} items`
  };
}
```

## Testing and Deployment

### Testing Your MCP

```typescript
// Test the full flow
describe('MCP Server', () => {
  it('should handle the complete setup flow', async () => {
    // 1. Check needs setup
    const needsSetup = await fetch('/setup/status');
    expect(needsSetup.body.needs_setup).toBe(true);
    
    // 2. Get instructions
    const instructions = await fetch('/setup/instructions');
    expect(instructions.body.steps).toHaveLength(3);
    
    // 3. Validate credentials
    const validation = await fetch('/setup/validate', {
      method: 'POST',
      body: {
        nylas_api_key: 'env_server_key',
        nylas_grant_id: 'user_grant_id'
      }
    });
    expect(validation.body.valid).toBe(true);
  });
  
  it('should execute tools with credentials', async () => {
    const response = await fetch('/a2a/rpc', {
      method: 'POST',
      headers: {
        'X-User-Credential-API_KEY': 'test-key'
      },
      body: {
        query: 'test query'
      }
    });
    
    expect(response.body.success).toBe(true);
  });
});
```

### Docker Deployment

```dockerfile
# Multi-stage build for efficiency
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production image
FROM node:20-alpine
RUN apk add --no-cache tini
WORKDIR /app

# Copy only production dependencies
COPY package*.json ./
RUN npm ci --production && npm cache clean --force

# Copy built app
COPY --from=builder /app/dist ./dist

# Run as non-root
USER node

# Use tini for proper signal handling
ENTRYPOINT ["/sbin/tini", "--"]
CMD ["node", "dist/server.js"]

EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"
```

### Production Checklist

- [ ] Comprehensive error handling
- [ ] Rate limiting implementation
- [ ] Request validation
- [ ] Secure credential handling
- [ ] Health check endpoint
- [ ] Structured logging
- [ ] Monitoring and metrics
- [ ] Graceful shutdown
- [ ] Documentation complete
- [ ] Security review passed

## Publishing to Juli

### Requirements

1. **Functional Requirements**
   - All tools must have clear descriptions
   - Natural language processing required
   - Proper error handling
   - Setup flow must be user-friendly

2. **Technical Requirements**
   - HTTP-only server (no WebSocket)
   - Stateless operation
   - Docker support recommended
   - Health check endpoint required

3. **Documentation Requirements**
   - README with clear examples
   - API documentation
   - Setup instructions
   - Troubleshooting guide

### Submission Process

1. Test thoroughly with multiple accounts
3. Submit via Juli Developer Portal
4. Respond to review feedback
5. Launch to thousands of users!

## Common Patterns

### Multi-Service Integration
```typescript
// When your MCP needs multiple API keys
headers: {
  'X-User-Credential-OPENAI_KEY': 'sk-...',
  'X-User-Credential-SERVICE_KEY': 'svc_...',
  'X-User-Credential-WORKSPACE': 'ws_123'
}
```

### Webhook Support
```typescript
// Register webhooks with callback URL
const callbackUrl = `https://juli-webhooks.com/mcp/${req.userId}/${toolName}`;
await client.registerWebhook(callbackUrl);
```

### Batch Operations
```typescript
// Process multiple items efficiently
{
  name: "bulk_process",
  parameters: {
    items: ["item1", "item2", "item3"],
    operation: "analyze"
  }
}
```

## Conclusion

Building MCP servers for Juli opens your tools to thousands of users who need specialized capabilities. Focus on:

1. **User Experience** - Natural language, clear errors, smooth setup
2. **Reliability** - Proper error handling, stateless design, monitoring
3. **Security** - Never store credentials, validate all input
4. **Performance** - Efficient operations, proper timeouts, scaling ready

Your MCP server will help Juli users be more productive and accomplish amazing things. Welcome to the Juli developer community!

## Resources

- [MCP Protocol Specification](https://modelcontextprotocol.io)
- [Juli Developer Portal](https://juli-ai.com/developers)
- [Support](ignacio@juli-ai.com)
</file>

<file path="docs/TOOLS_DOCUMENTATION.md">
# Inbox MCP Tools Documentation

Comprehensive documentation for all tools available in the Inbox MCP server, including the setup endpoint.

## Table of Contents
- [Authentication & Credentials](#authentication--credentials)
- [Setup Tool](#setup-tool)
- [manage_email](#manage_email)
- [find_emails](#find_emails)
- [organize_inbox](#organize_inbox)
- [email_insights](#email_insights)
- [smart_folders](#smart_folders)

---

## Authentication & Credentials

**Critical Information**: This MCP server is **stateless** and **never stores user credentials**.

### How Credentials Work

1. **Hosted Auth**: Users authenticate via Nylas Hosted Auth; server keeps API key in env
2. **Storage**: Juli securely stores only the user's `grant_id`
3. **Runtime**: For MCP, send `X-User-Credential-NYLAS_GRANT_ID`. For A2A, include `EMAIL_ACCOUNT_GRANT` (preferred) or `NYLAS_GRANT_ID` in `user_context.credentials`.

### Required Headers for All Tools (MCP)

Every request to email tools must include this header:

```http
X-User-Credential-NYLAS_GRANT_ID: your_grant_id_here
```

### A2A (JSON‑RPC)

- Discovery: `GET /.well-known/a2a.json` → Agent Card
- Credentials: `GET /.well-known/a2a-credentials.json`
- RPC: `POST /a2a/rpc` with methods `agent.card`, `agent.handshake`, `tool.execute`, `tool.approve`

Auth:
- Production: `Authorization: Bearer <OIDC_ID_TOKEN>` (audience from Agent Card)
- Dev: `X-A2A-Dev-Secret: <secret>` when enabled

### What Happens Without Credentials

If credentials are missing from headers, all email tools will return:

```json
{
  "error": "Missing Nylas credentials. Please connect your email account first."
}
```

---

## Connect your email (Hosted Auth)

Hosted Auth keeps the Nylas API key on the server and returns a per-user `grant_id`.

### 1) Detect if setup is needed

Request:
```bash
curl -s https://juli-ai.com/setup/status
```

Response when not connected:
```json
{
  "needs_setup": true,
  "has_credentials": false,
  "setup_url": "/setup/instructions",
  "connect_url": "/setup/connect-url"
}
```

### 2) Get the Hosted Auth URL

Request (prod):
```bash
curl -s "https://juli-ai.com/setup/connect-url?redirect_uri=https%3A%2F%2Fjuli-ai.com%2Fapi%2Fnylas-email%2Fcallback&scope=openid,https://www.googleapis.com/auth/userinfo.email,https://www.googleapis.com/auth/userinfo.profile,https://www.googleapis.com/auth/gmail.modify,https://www.googleapis.com/auth/calendar&prompt=detect,select_provider"
```

Response:
```json
{ "url": "https://api.us.nylas.com/v3/connect/auth?..." }
```

Open the `url` in a browser to complete provider login.

### 3) Callback returns your grant

After login, the server responds at the callback with:
```json
{ "success": true, "grant_id": "86a3c08f-...", "email": "user@example.com" }
```

### 4) Use the tools

Send the header on every request:
```http
X-User-Credential-NYLAS_GRANT_ID: <grant_id>
```

---

## manage_email

Send, reply, forward, or draft emails using natural language. The AI understands context and handles email composition intelligently.

### Parameters

```typescript
{
  action: "send" | "reply" | "forward" | "draft",
  query: string,                    // Natural language description
  context_message_id?: string,      // For replies/forwards
  require_approval?: boolean,       // Default: true
  
  // Context injection (auto-filled by Juli)
  user_name?: string,
  user_email?: string
}
```

### Examples

#### Send New Email
**Request**:
```json
{
  "action": "send",
  "query": "Email Sarah about postponing tomorrow's meeting to Friday at 2pm"
}
```

**Response** (Needs Approval):
```json
{
  "needs_approval": true,
  "action_type": "send_email",
  "action_data": {
    "email_content": {
      "to": ["sarah.johnson@company.com"],
      "subject": "Meeting Reschedule - Moving to Friday",
      "body": "Hi Sarah,\n\nI hope this email finds you well. I wanted to reach out about tomorrow's meeting.\n\nWould it be possible to reschedule our meeting to Friday at 2pm instead? Something urgent has come up that requires my attention tomorrow.\n\nPlease let me know if Friday at 2pm works for your schedule.\n\nBest regards,\nJohn"
    }
  },
  "preview": {
    "summary": "Send email to sarah.johnson@company.com",
    "details": {
      "recipient": "Sarah Johnson",
      "subject": "Meeting Reschedule - Moving to Friday",
      "word_count": 67
    }
  }
}
```

#### Reply to Email
**Request**:
```json
{
  "action": "reply",
  "query": "Thank her for the proposal and ask for clarification on the timeline",
  "context_message_id": "msg_abc123"
}
```

**Response**:
```json
{
  "needs_approval": true,
  "action_type": "send_email",
  "action_data": {
    "email_content": {
      "to": ["sender@example.com"],
      "subject": "Re: Project Proposal",
      "body": "Hi Jane,\n\nThank you for sending over the proposal. I've had a chance to review it and I'm impressed with the comprehensive approach.\n\nCould you please provide some clarification on the timeline? Specifically, I'd like to understand the key milestones and deliverable dates.\n\nLooking forward to your response.\n\nBest regards,\nJohn",
      "reply_to_message_id": "msg_abc123"
    }
  },
  "preview": {
    "summary": "Reply to Jane about Project Proposal",
    "details": {
      "in_reply_to": "Project Proposal",
      "thread_length": 3
    }
  }
}
```

#### Forward Email
**Request**:
```json
{
  "action": "forward",
  "query": "Forward this to the dev team with a note about prioritizing the security issues",
  "context_message_id": "msg_xyz789"
}
```

#### Draft Email
**Request**:
```json
{
  "action": "draft",
  "query": "Draft a follow-up email to all attendees from yesterday's meeting with action items"
}
```

**Response**:
```json
{
  "success": true,
  "draft_id": "draft_123",
  "message": "Draft saved successfully",
  "draft_preview": {
    "subject": "Follow-up: Yesterday's Meeting - Action Items",
    "recipients": ["attendee1@company.com", "attendee2@company.com"]
  }
}
```

---

## find_emails

Search and analyze emails using natural language queries. Returns intelligent summaries and insights.

### Parameters

```typescript
{
  query: string,                              // Natural language search
  analysis_type?: "summary" | "detailed" | "action_items" | "priority",
  limit?: number,                             // Max emails to analyze (default: 20)
  include_spam?: boolean,                     // Include spam folder (default: false)
  
  // Context injection
  user_timezone?: string
}
```

### Examples

#### Find Unread Important Emails
**Request**:
```json
{
  "query": "important unread emails from this week",
  "analysis_type": "priority"
}
```

**Response**:
```json
{
  "success": true,
  "total_found": 12,
  "analysis": {
    "high_priority": [
      {
        "id": "msg_123",
        "from": "boss@company.com",
        "subject": "Urgent: Budget Review Needed",
        "received": "2024-01-24T10:30:00Z",
        "importance_score": 0.95,
        "why_important": "From direct manager, marked urgent, mentions deadline"
      }
    ],
    "medium_priority": [
      {
        "id": "msg_456",
        "from": "client@example.com",
        "subject": "Re: Project Timeline",
        "importance_score": 0.75,
        "why_important": "Client response, ongoing project discussion"
      }
    ],
    "summary": "You have 3 high-priority emails requiring immediate attention"
  }
}
```

#### Find Emails with Action Items
**Request**:
```json
{
  "query": "emails that need my response",
  "analysis_type": "action_items"
}
```

**Response**:
```json
{
  "success": true,
  "total_found": 8,
  "action_items": [
    {
      "email_id": "msg_789",
      "from": "colleague@company.com",
      "subject": "Review needed: Q4 Report",
      "action_required": "Review and provide feedback on Q4 report",
      "deadline": "2024-01-26",
      "extracted_from": "Could you please review the attached Q4 report and provide your feedback by Friday?"
    }
  ]
}
```

#### Search with Natural Dates
**Request**:
```json
{
  "query": "invoices from last month",
  "analysis_type": "summary"
}
```

---

## organize_inbox

Perform bulk operations on emails using intelligent rules and natural language instructions.

### Parameters

```typescript
{
  instruction: string,                    // What to do
  scope?: {
    folder?: string,                      // Which folder (default: "inbox")
    date_range?: string,                  // Natural language date range
    limit?: number                        // Max emails to process
  },
  dry_run?: boolean,                      // Preview without executing (default: true)
  confirmed?: boolean                     // Execute the operation
}
```

### Examples

#### Archive Old Emails
**Request**:
```json
{
  "instruction": "Archive all emails older than 30 days except starred ones",
  "scope": {
    "folder": "inbox"
  },
  "dry_run": true
}
```

**Response** (Dry Run):
```json
{
  "preview": true,
  "operation": "archive",
  "would_affect": {
    "total": 156,
    "breakdown": {
      "newsletters": 89,
      "notifications": 45,
      "conversations": 22
    },
    "excluded": {
      "starred": 5,
      "important": 3
    }
  },
  "sample_emails": [
    {
      "subject": "Your Weekly Newsletter",
      "from": "newsletter@example.com",
      "date": "2023-12-15"
    }
  ],
  "to_execute": "Set 'confirmed': true to execute"
}
```

#### Clean Up Newsletters
**Request**:
```json
{
  "instruction": "Move all unread newsletters to a Newsletter folder",
  "confirmed": true
}
```

**Response**:
```json
{
  "success": true,
  "operation": "move",
  "processed": 34,
  "details": {
    "moved_to": "Newsletter",
    "folder_created": true,
    "time_saved": "Approximately 15 minutes of manual sorting"
  }
}
```

#### Smart Filtering
**Request**:
```json
{
  "instruction": "Delete promotional emails keeping only those from services I actually use",
  "dry_run": true
}
```

The AI will intelligently identify which services you use based on your email history.

---

## email_insights

Get AI-powered insights and analytics about your email patterns and important items.

### Parameters

```typescript
{
  insight_type: "daily_summary" | "important_items" | "response_needed" | 
                "analytics" | "relationships",
  time_period?: string,                   // Natural language (default: "today")
  focus_area?: string,                    // Specific topic/project/person
  
  // Context injection
  user_timezone?: string,
  current_date?: string
}
```

### Examples

#### Daily Summary
**Request**:
```json
{
  "insight_type": "daily_summary",
  "time_period": "today"
}
```

**Response**:
```json
{
  "success": true,
  "summary": {
    "date": "2024-01-24",
    "new_emails": 47,
    "important_count": 5,
    "urgent_items": [
      {
        "from": "manager@company.com",
        "subject": "Budget approval needed today",
        "action": "Requires approval by EOD"
      }
    ],
    "meetings_mentioned": [
      "Product Review - Tomorrow 2pm",
      "Client Call - Friday 10am"
    ],
    "key_topics": ["Q4 Report", "Budget Review", "Project Alpha"],
    "response_needed": 3,
    "can_archive": 31
  },
  "recommendation": "Focus on the budget approval first, then address the 3 emails needing responses"
}
```

#### Relationship Insights
**Request**:
```json
{
  "insight_type": "relationships",
  "time_period": "last month"
}
```

**Response**:
```json
{
  "success": true,
  "top_correspondents": [
    {
      "email": "sarah@company.com",
      "name": "Sarah Johnson",
      "interaction_count": 45,
      "your_average_response_time": "2.5 hours",
      "their_average_response_time": "1.2 hours",
      "topics": ["Project Alpha", "Budget Planning"],
      "relationship_type": "frequent_collaborator"
    }
  ],
  "communication_patterns": {
    "busiest_day": "Tuesday",
    "peak_hours": "9am-11am",
    "average_daily_emails": 67
  }
}
```

#### Response Analytics
**Request**:
```json
{
  "insight_type": "response_needed",
  "focus_area": "Project Alpha"
}
```

---

## smart_folders

Create and manage intelligent folders that automatically organize emails based on AI understanding.

### Parameters

```typescript
{
  action: "create" | "update" | "apply" | "list",
  rule?: string,                          // Natural language rule
  folder_name?: string,                   // Folder name (AI suggests if not provided)
  options?: {
    auto_apply?: boolean,                 // Apply to existing emails
    ongoing?: boolean                     // Apply to future emails
  }
}
```

### Examples

#### Create Smart Folder
**Request**:
```json
{
  "action": "create",
  "rule": "Important client emails that mention contracts or proposals",
  "folder_name": "Client Contracts"
}
```

**Response**:
```json
{
  "success": true,
  "folder_created": "Client Contracts",
  "rule_interpretation": {
    "conditions": [
      "From domain in known client list",
      "Contains keywords: contract, proposal, agreement, SOW",
      "Importance score > 0.7"
    ]
  },
  "would_match": 23,
  "sample_matches": [
    "Contract renewal - Acme Corp",
    "Proposal for Q1 Services"
  ]
}
```

#### Apply Smart Folder
**Request**:
```json
{
  "action": "apply",
  "folder_name": "Client Contracts",
  "options": {
    "auto_apply": true
  }
}
```

**Response**:
```json
{
  "success": true,
  "emails_organized": 23,
  "folder": "Client Contracts",
  "future_handling": "New matching emails will be automatically filed"
}
```

#### List Smart Folders
**Request**:
```json
{
  "action": "list"
}
```

**Response**:
```json
{
  "smart_folders": [
    {
      "name": "Client Contracts",
      "email_count": 23,
      "rule": "Important client emails with contracts/proposals",
      "auto_filing": true,
      "created": "2024-01-15"
    },
    {
      "name": "Team Updates",
      "email_count": 156,
      "rule": "Updates from team members about ongoing projects",
      "auto_filing": false
    }
  ]
}
```

---

## Error Responses

All tools return consistent error responses:

```json
{
  "error": "User-friendly error message",
  "error_code": "SPECIFIC_ERROR_CODE",
  "details": {
    "suggestion": "How to fix the issue",
    "retry_after": 60  // If rate limited
  }
}
```

Common error codes:
- `NEEDS_SETUP` - Credentials not configured
- `INVALID_CREDENTIALS` - Credentials validation failed
- `RATE_LIMIT_EXCEEDED` - Too many requests
- `EMAIL_NOT_FOUND` - Referenced email doesn't exist
- `INVALID_PARAMETER` - Parameter validation failed
- `AI_PROCESSING_ERROR` - AI couldn't understand request

## Best Practices

1. **Use Natural Language**: Users should speak naturally, not in technical terms
2. **Provide Context**: Include context when referencing previous emails
3. **Test Edge Cases**: Empty inboxes, invalid email addresses, network failures
4. **Handle Errors Gracefully**: Always return helpful error messages
5. **Respect Rate Limits**: Implement exponential backoff for retries
</file>

<file path="src/ai/emailAI.ts">
import OpenAI from 'openai';
import {
  EmailIntent,
  GeneratedEmail,
  EmailAnalysis,
  ActionItem,
  Email
} from '../types';
export class EmailAI {
  private openai: OpenAI;
  private debugMode: boolean;
  private defaultReasoningEffort: 'minimal' | 'low' | 'medium' | 'high';
  private defaultVerbosity: 'low' | 'medium' | 'high';
  constructor() {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY environment variable is required for EmailAI');
    }
    this.openai = new OpenAI({
      apiKey: apiKey
    });
    // Enable debug mode for tests
    this.debugMode = process.env.NODE_ENV === 'test' || process.env.DEBUG_AI === 'true';
    // Defaults optimized for latency unless overridden via env
    const reasoning = (process.env.OPENAI_REASONING_EFFORT || 'minimal').toLowerCase();
    const verbosity = (process.env.OPENAI_VERBOSITY || 'low').toLowerCase();
    this.defaultReasoningEffort = (['minimal', 'low', 'medium', 'high'].includes(reasoning) ? reasoning : 'minimal') as any;
    this.defaultVerbosity = (['low', 'medium', 'high'].includes(verbosity) ? verbosity : 'low') as any;
  }
  private buildGpt5Params(overrides?: { reasoning_effort?: 'minimal' | 'low' | 'medium' | 'high'; verbosity?: 'low' | 'medium' | 'high' }) {
    return {
      reasoning: { effort: overrides?.reasoning_effort || this.defaultReasoningEffort },
      text: { verbosity: overrides?.verbosity || this.defaultVerbosity }
    } as any;
  }
  private extractFirstToolCall(response: any): { name: string; arguments: string } | null {
    if (!response) return null;
    const out = (response as any).output;
    if (Array.isArray(out)) {
      // Direct tool/function call items (Responses API emits type 'function_call')
      const tc = out.find((o: any) => o?.type === 'tool_call' || o?.type === 'function_call');
      if (tc) {
        const name = tc.tool_name || tc.name;
        const args = tc.arguments || tc.arguments_text || (typeof tc.input === 'object' ? JSON.stringify(tc.input) : tc.input);
        if (name && args !== undefined) return { name, arguments: typeof args === 'string' ? args : JSON.stringify(args) };
      }
      // Tool use embedded in message content
      const msg = out.find((o: any) => o?.type === 'message');
      const content = msg?.content;
      if (Array.isArray(content)) {
        const toolUse = content.find((c: any) => c?.type === 'tool_use' && c?.name);
        if (toolUse) {
          const args = toolUse.input ?? {};
          return { name: toolUse.name, arguments: JSON.stringify(args) };
        }
      }
    }
    return null;
  }
  private extractText(response: any): string | undefined {
    if (!response) return undefined;
    if (typeof response.output_text === 'string') return response.output_text as string;
    const out = (response as any).output;
    if (Array.isArray(out)) {
      const msg = out.find((o: any) => o?.type === 'message');
      const parts = msg?.content;
      if (Array.isArray(parts)) {
        const texts = parts.filter((p: any) => p?.type === 'output_text' || p?.type === 'text').map((p: any) => p?.text || p?.content).filter(Boolean);
        if (texts.length > 0) return texts.join('\n');
      }
    }
    return undefined;
  }
  async understandSearchQuery(query: string): Promise<{
    intent: string;
    timeframe?: { start?: Date; end?: Date };
    senders?: string[];
    keywords?: string[];
    filters?: {
      unread?: boolean;
      starred?: boolean;
      hasAttachments?: boolean;
    };
  }> {
    const tools = [{
      type: "function" as const,
      name: "extract_search_params",
      description: "Extract email search parameters from natural language query",
      parameters: {
        type: "object",
        properties: {
          intent: {
            type: "string",
            description: "The search intent"
          },
          timeframe: {
            type: ["object", "null"],
            properties: {
              start: {
                type: ["string", "null"],
                description: "Start date/time (e.g., '2024-01-01', 'yesterday', '7 days ago')"
              },
              end: {
                type: ["string", "null"],
                description: "End date/time"
              }
            },
            required: ["start", "end"],
            additionalProperties: false,
            description: "Time range for the search"
          },
          senders: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "Sender name or email"
            },
            description: "List of senders to filter by"
          },
          keywords: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "Keyword to search for"
            },
            description: "Keywords to search in email content"
          },
          filters: {
            type: ["object", "null"],
            properties: {
              unread: {
                type: ["boolean", "null"],
                description: "Filter for unread emails"
              },
              starred: {
                type: ["boolean", "null"],
                description: "Filter for starred/important emails"
              },
              hasAttachments: {
                type: ["boolean", "null"],
                description: "Filter for emails with attachments"
              }
            },
            required: ["unread", "starred", "hasAttachments"],
            additionalProperties: false,
            description: "Boolean filters for email properties"
          }
        },
        required: ["intent", "timeframe", "senders", "keywords", "filters"],
        additionalProperties: false
      }
    }];
    const systemPrompt = `You are an email search assistant. Analyze the user's natural language query and extract structured search parameters.
Examples:
- "emails from John about the project" → senders: ["John"], keywords: ["project"]
- "unread emails from last week" → filters: { unread: true }, timeframe: { start: "7 days ago" }
- "important emails I haven't responded to" → filters: { starred: true }
- "emails with attachments from yesterday" → filters: { hasAttachments: true }, timeframe: { start: "yesterday", end: "today" }`;
    if (this.debugMode) {
      console.log('\n🤖 AI Search Query Understanding');
      console.log('📝 User Query:', query);
      console.log('🔧 Function Schema:', JSON.stringify((tools as any)[0].parameters, null, 2));
    }
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "extract_search_params" },
      ...this.buildGpt5Params()
    });
    if (this.debugMode) {
      console.log('📊 AI Response:', JSON.stringify(completion.choices[0].message, null, 2));
    }
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'extract_search_params') {
      throw new Error('Failed to understand search query');
    }
    const result = JSON.parse((toolCall as any).arguments || (toolCall as any).function?.arguments);
    // Clean up null values and parse dates if needed
    const searchParams: any = {
      intent: result.intent
    };
    if (result.timeframe && (result.timeframe.start || result.timeframe.end)) {
      searchParams.timeframe = {};
      if (result.timeframe.start) {
        searchParams.timeframe.start = this.parseTimeString(result.timeframe.start);
      }
      if (result.timeframe.end) {
        searchParams.timeframe.end = this.parseTimeString(result.timeframe.end);
      }
    }
    if (result.senders && result.senders.length > 0) {
      searchParams.senders = result.senders;
    }
    if (result.keywords && result.keywords.length > 0) {
      searchParams.keywords = result.keywords;
    }
    if (result.filters) {
      searchParams.filters = {};
      if (result.filters.unread !== null) searchParams.filters.unread = result.filters.unread;
      if (result.filters.starred !== null) searchParams.filters.starred = result.filters.starred;
      if (result.filters.hasAttachments !== null) searchParams.filters.hasAttachments = result.filters.hasAttachments;
    }
    return searchParams;
  }
  private parseTimeString(timeStr: string): Date {
    const now = new Date();
    const lowerStr = timeStr.toLowerCase();
    // Handle relative dates
    if (lowerStr === 'today') {
      return new Date(now.getFullYear(), now.getMonth(), now.getDate());
    } else if (lowerStr === 'yesterday') {
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      return new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
    } else if (lowerStr.includes('days ago')) {
      const days = parseInt(lowerStr.match(/(\d+)\s*days?\s*ago/)?.[1] || '0');
      const date = new Date(now);
      date.setDate(date.getDate() - days);
      return date;
    } else if (lowerStr.includes('hours ago')) {
      const hours = parseInt(lowerStr.match(/(\d+)\s*hours?\s*ago/)?.[1] || '0');
      const date = new Date(now);
      date.setHours(date.getHours() - hours);
      return date;
    } else if (lowerStr === 'last week') {
      const date = new Date(now);
      date.setDate(date.getDate() - 7);
      return date;
    } else if (lowerStr === 'last month') {
      const date = new Date(now);
      date.setMonth(date.getMonth() - 1);
      return date;
    }
    // Try to parse as a date string
    return new Date(timeStr);
  }
  async understandQuery(query: string, context?: any): Promise<EmailIntent> {
    const tools = [{
      type: "function" as const,
      name: "extract_email_intent",
      description: "Extract the intent, recipients, subject, key points, urgency and tone from a natural language email request",
      parameters: {
        type: "object",
        properties: {
          intent: {
            type: "string",
            enum: ["send", "reply", "forward", "find", "organize"],
            description: "The user's intent"
          },
          recipients: {
            type: "array",
            items: {
              type: "string",
              description: "Email address or contact name (e.g., 'john@example.com' or 'Sarah')"
            },
            description: "List of recipient email addresses or contact names to be resolved"
          },
          subject: {
            type: "string",
            description: "Suggested email subject line"
          },
          key_points: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Key points or topics to include"
          },
          urgency: {
            type: "string",
            enum: ["low", "normal", "high", "urgent"],
            description: "Urgency level of the email"
          },
          tone: {
            type: "string",
            enum: ["professional", "casual", "friendly", "formal", "grateful"],
            description: "Desired tone of the email"
          }
        },
        required: ["intent", "recipients", "subject", "key_points", "urgency", "tone"],
        additionalProperties: false
      }
    }];
    const systemPrompt = `You are an email assistant. Analyze the user's request and extract email intent information.
    IMPORTANT: Recipients can be specified as either:
    - Full email addresses (e.g., "john@example.com")
    - Contact names (e.g., "Sarah", "John Smith") which will be resolved later
    When the user mentions people by name only (like "email Sarah"), extract the name as-is in the recipients array.
    ${context?.senderEmail ? `Context: The user wants to reply to an email from ${context.senderEmail}` : ''}`;
    if (this.debugMode) {
      console.log('\n🤖 AI Email Intent Understanding');
      console.log('📝 User Query:', query);
      console.log('🔧 Function Schema:', JSON.stringify((tools as any)[0].parameters, null, 2));
    }
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "extract_email_intent" },
      ...this.buildGpt5Params()
    });
    if (this.debugMode) {
      try {
        console.log('🧪 Responses output (understandQuery):', JSON.stringify(completion, null, 2));
      } catch { }
    }
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'extract_email_intent') {
      throw new Error('Failed to extract email intent');
    }
    const result = JSON.parse(toolCall.arguments) as EmailIntent;
    // If context has sender email and intent is reply, ensure it's in recipients
    if (context?.senderEmail && result.intent === 'reply') {
      result.recipients = result.recipients || [];
      if (!result.recipients.includes(context.senderEmail)) {
        result.recipients.push(context.senderEmail);
      }
    }
    return result;
  }
  async generateEmailContent(intent: EmailIntent, contextEmail?: Email, recipientNames?: { [email: string]: string }, senderInfo?: { email?: string; name?: string } | null): Promise<GeneratedEmail> {
    const tools = [{
      type: "function" as const,
      name: "generate_email",
      description: "Generate a complete email with recipients, subject, and body",
      parameters: {
        type: "object",
        properties: {
          to: {
            type: "array",
            items: {
              type: "string",
              description: "Recipient email address"
            },
            description: "Primary recipients"
          },
          cc: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "CC recipient email address"
            },
            description: "CC recipients"
          },
          bcc: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "BCC recipient email address"
            },
            description: "BCC recipients"
          },
          subject: {
            type: "string",
            description: "Email subject line"
          },
          body: {
            type: "string",
            description: "Complete email body"
          },
          tone_confirmation: {
            type: ["string", "null"],
            description: "Confirmation of tone used"
          }
        },
        required: ["to", "subject", "body", "cc", "bcc", "tone_confirmation"],
        additionalProperties: false
      }
    }];
    // Build recipient context with names when available
    const recipientContext = intent.recipients?.map(email => {
      const name = recipientNames?.[email];
      return name ? `${name} (${email})` : email;
    }).join(', ') || 'to be determined';
    const senderContext = senderInfo?.name && senderInfo?.email
      ? `You are writing this email as ${senderInfo.name} (${senderInfo.email})`
      : 'You are writing a professional email';
    const systemPrompt = `You are a professional email writer. ${senderContext}
    Generate an email based on:
    - Recipients: ${recipientContext}
    - Subject suggestion: ${intent.subject || 'Create appropriate subject'}
    - Key points to cover: ${intent.key_points.join(', ')}
    - Tone: ${intent.tone}
    - Urgency: ${intent.urgency}
    ${contextEmail ? `This is in response to an email with subject: "${contextEmail.subject}"` : ''}
    RECIPIENT NAMES: ${recipientNames && Object.keys(recipientNames).length > 0
        ? Object.entries(recipientNames).map(([email, name]) => `${email} = ${name}`).join(', ')
        : 'No contact names found - use "Hello" as greeting'}
    FORMATTING REQUIREMENTS:
    - Use proper paragraph breaks with double line breaks (\\n\\n) between paragraphs
    - Start with an appropriate greeting: If recipient name is known, use "Dear [Name]", otherwise use "Hello"
    - Structure: Greeting\n\nOpening paragraph\n\nBody paragraphs (if needed)\n\nClosing paragraph\n\nSign-off
    - Ensure professional spacing and readability
    - Each distinct thought or topic should be its own paragraph
    - End with an appropriate sign-off (Best regards, Sincerely, etc.) followed by the sender's name: ${senderInfo?.name || '[Your Name]'}
    Write a complete, professional email that covers all key points naturally with proper formatting.`;
    if (this.debugMode) {
      try {
        console.log('🔧 Tools (generateEmailContent):', JSON.stringify(tools));
      } catch { }
    }
    let completion: any;
    try {
      completion = await (this.openai as any).responses.create({
        model: "gpt-5",
        input: [
          { role: "system", content: systemPrompt },
          { role: "user", content: "Generate the email content." }
        ],
        tools: tools,
        tool_choice: { type: "function", name: "generate_email" },
        ...this.buildGpt5Params({ verbosity: 'medium' })
      });
    } catch (err: any) {
      if (this.debugMode) {
        console.error('❌ OpenAI error (generateEmailContent):', err?.response?.data || err?.message || err);
      }
      throw err;
    }
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_email') {
      throw new Error('Failed to generate email content');
    }
    const result = JSON.parse(toolCall.arguments);
    // Debug log to see what the AI generated
    if (this.debugMode) {
      console.log('📧 Generated email body:', result.body);
      console.log('📧 Body includes \\n\\n:', result.body.includes('\\n\\n'));
    }
    // Convert null values to undefined for optional fields
    return {
      to: result.to,
      cc: result.cc || undefined,
      bcc: result.bcc || undefined,
      subject: result.subject,
      body: result.body,
      tone_confirmation: result.tone_confirmation || undefined
    };
  }
  async analyzeEmailImportance(emails: Email[]): Promise<EmailAnalysis[]> {
    const tools = [{
      type: "function" as const,
      name: "analyze_emails",
      description: "Analyze importance and categorize multiple emails",
      parameters: {
        type: "object",
        properties: {
          analyses: {
            type: "array",
            items: {
              type: "object",
              properties: {
                email_id: {
                  type: "string",
                  description: "ID of the email being analyzed"
                },
                importance_score: {
                  type: "number",
                  description: "Importance score from 0 to 1"
                },
                category: {
                  type: "string",
                  enum: ["urgent_alert", "client_email", "newsletter", "notification", "personal", "other"],
                  description: "Email category"
                },
                reason: {
                  type: "string",
                  description: "Reason for the importance rating"
                },
                action_required: {
                  type: "boolean",
                  description: "Whether action is required"
                },
                suggested_folder: {
                  type: ["string", "null"],
                  description: "Suggested folder for organization"
                }
              },
              required: ["email_id", "importance_score", "category", "reason", "action_required", "suggested_folder"],
              additionalProperties: false
            },
            description: "Analysis results for each email"
          }
        },
        required: ["analyses"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      id: e.id,
      subject: e.subject,
      from: e.from[0]?.email || 'unknown',
      snippet: e.snippet || ''
    }));
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: `Analyze emails for importance and categorization. Consider sender importance, urgency indicators, business impact, and time sensitivity.` },
        { role: "user", content: `Analyze these emails: ${JSON.stringify(emailSummaries)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "analyze_emails" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'analyze_emails') {
      throw new Error('Failed to analyze emails');
    }
    const result = JSON.parse(toolCall.arguments);
    return result.analyses.map((analysis: any) => ({
      ...analysis,
      suggested_folder: analysis.suggested_folder || undefined
    }));
  }
  async generateAggregatedSummary(emails: Email[]): Promise<string> {
    const tools = [{
      type: "function" as const,
      name: "generate_summary",
      description: "Generate a natural language summary of multiple emails",
      parameters: {
        type: "object",
        properties: {
          summary: {
            type: "string",
            description: "A comprehensive natural language summary of the emails"
          },
          key_topics: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Main topics discussed across the emails"
          },
          important_items: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Important items that need attention"
          },
          action_required: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Actions that need to be taken"
          }
        },
        required: ["summary", "key_topics", "important_items", "action_required"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      subject: e.subject,
      from: e.from[0]?.name || e.from[0]?.email || 'unknown',
      snippet: e.snippet || '',
      date: e.date ? new Date(e.date * 1000).toLocaleString() : 'unknown'
    }));
    const systemPrompt = `You are an email assistant. Analyze these emails and provide a natural language summary that captures:
    1. The overall themes and topics
    2. What's important or urgent
    3. What actions the user needs to take
    4. Any patterns or trends
    Write the summary as if you're a helpful assistant briefing someone about their inbox.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Summarize these emails: ${JSON.stringify(emailSummaries)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_summary" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_summary') {
      throw new Error('Failed to generate summary');
    }
    const result = JSON.parse(toolCall.arguments);
    // Combine the structured data into a natural summary
    let fullSummary = result.summary;
    if (result.important_items.length > 0) {
      fullSummary += ` Important: ${result.important_items.join(', ')}.`;
    }
    if (result.action_required.length > 0) {
      fullSummary += ` Action needed: ${result.action_required.join(', ')}.`;
    }
    return fullSummary;
  }
  async extractActionItems(email: Email): Promise<ActionItem[]> {
    const tools = [{
      type: "function" as const,
      name: "extract_action_items",
      description: "Extract action items from an email",
      parameters: {
        type: "object",
        properties: {
          action_items: {
            type: "array",
            items: {
              type: "object",
              properties: {
                task: {
                  type: "string",
                  description: "The action item or task"
                },
                deadline: {
                  type: ["string", "null"],
                  description: "Deadline if mentioned"
                },
                priority: {
                  type: "string",
                  enum: ["low", "medium", "high"],
                  description: "Priority level"
                }
              },
              required: ["task", "deadline", "priority"],
              additionalProperties: false
            },
            description: "List of action items found"
          }
        },
        required: ["action_items"],
        additionalProperties: false
      }
    }];
    const emailContent = {
      subject: email.subject,
      from: email.from[0]?.email || 'unknown',
      body: email.body || email.snippet || ''
    };
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: "Extract all actionable items from the email. Be thorough." },
        { role: "user", content: `Extract action items from: ${JSON.stringify(emailContent)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "extract_action_items" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'extract_action_items') {
      throw new Error('Failed to extract action items');
    }
    const result = JSON.parse(toolCall.arguments);
    return result.action_items.map((item: any) => ({
      ...item,
      deadline: item.deadline || undefined
    }));
  }
  async generateSmartFolderRules(folderDescription: string): Promise<{
    name: string;
    rules: string[];
    description: string;
  }> {
    const tools = [{
      type: "function" as const,
      name: "generate_folder_rules",
      description: "Generate smart folder rules based on description",
      parameters: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "Folder name"
          },
          rules: {
            type: "array",
            items: {
              type: "string",
              description: "A folder rule"
            },
            description: "List of rules for the folder"
          },
          description: {
            type: "string",
            description: "Folder description"
          }
        },
        required: ["name", "rules", "description"],
        additionalProperties: false
      }
    }];
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: "Generate smart folder rules based on the user description." },
        { role: "user", content: folderDescription }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_folder_rules" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_folder_rules') {
      throw new Error('Failed to generate folder rules');
    }
    return JSON.parse(toolCall.arguments);
  }
  async categorizeEmails(emails: Email[]): Promise<Map<string, string[]>> {
    const tools = [{
      type: "function" as const,
      name: "categorize_emails",
      description: "Categorize emails into logical groups",
      parameters: {
        type: "object",
        properties: {
          categories: {
            type: "array",
            items: {
              type: "object",
              properties: {
                email_id: {
                  type: "string",
                  description: "Email ID"
                },
                category: {
                  type: "string",
                  description: "Category name"
                }
              },
              required: ["email_id", "category"],
              additionalProperties: false
            },
            description: "Email categorizations"
          }
        },
        required: ["categories"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      id: e.id,
      subject: e.subject,
      from: e.from[0]?.email || 'unknown',
      snippet: e.snippet || ''
    }));
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: "Categorize emails into logical groups like: receipts, newsletters, work, personal, etc." },
        { role: "user", content: JSON.stringify(emailSummaries) }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "categorize_emails" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'categorize_emails') {
      throw new Error('Failed to categorize emails');
    }
    const result = JSON.parse(toolCall.arguments);
    // Group by category
    const categoryMap = new Map<string, string[]>();
    result.categories.forEach(({ email_id, category }: { email_id: string; category: string }) => {
      if (!categoryMap.has(category)) {
        categoryMap.set(category, []);
      }
      categoryMap.get(category)!.push(email_id);
    });
    return categoryMap;
  }
  async understandOrganizationIntent(query: string): Promise<{
    rules: Array<{
      condition: string;
      action: string;
      target: string | null;
    }>;
  }> {
    const tools = [{
      type: "function" as const,
      name: "understand_organization",
      description: "Understand email organization intent from natural language",
      parameters: {
        type: "object",
        properties: {
          rules: {
            type: "array",
            items: {
              type: "object",
              properties: {
                condition: {
                  type: "string",
                  description: "The condition to match emails (e.g., 'subject contains invoice', 'from newsletter@')"
                },
                action: {
                  type: "string",
                  description: "The action to take (e.g., 'move to folder', 'star', 'mark read')"
                },
                target: {
                  type: ["string", "null"],
                  description: "The target for the action (e.g., folder name, null for star/mark actions)"
                }
              },
              required: ["condition", "action", "target"],
              additionalProperties: false
            },
            description: "List of organization rules"
          }
        },
        required: ["rules"],
        additionalProperties: false
      }
    }];
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: "You are an email assistant that understands organization intents. Convert natural language into email organization rules." },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "understand_organization" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || !toolCall.arguments) {
      throw new Error('Failed to understand organization intent');
    }
    const result = JSON.parse(toolCall.arguments);
    return {
      rules: result.rules.map((rule: any) => ({
        condition: rule.condition,
        action: rule.action,
        target: rule.target || null
      }))
    };
  }
  async generateDailyInsights(emails: Email[], analysis: EmailAnalysis[]): Promise<{
    executive_summary: string;
    key_highlights: string[];
    action_priorities: string[];
    patterns: string[];
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      name: "generate_daily_insights",
      description: "Generate actionable insights from daily email activity",
      parameters: {
        type: "object",
        properties: {
          executive_summary: {
            type: "string",
            description: "A concise executive summary of the day's email activity with actionable insights"
          },
          key_highlights: {
            type: "array",
            items: {
              type: "string"
            },
            description: "3-5 key highlights from today's emails"
          },
          action_priorities: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Prioritized list of actions the user should take"
          },
          patterns: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Communication patterns or trends observed"
          },
          recommendations: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Strategic recommendations for email management"
          }
        },
        required: ["executive_summary", "key_highlights", "action_priorities", "patterns", "recommendations"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      subject: e.subject,
      from: e.from[0]?.name || e.from[0]?.email || 'unknown',
      snippet: e.snippet || '',
      unread: e.unread,
      importance: analysis.find(a => a.email_id === e.id)?.importance_score || 0.5
    }));
    const systemPrompt = `You are an executive email assistant providing daily insights. Analyze the day's emails and provide:
    1. An executive summary that highlights what matters most
    2. Key highlights that need attention
    3. Prioritized actions the user should take
    4. Communication patterns (who's reaching out, about what)
    5. Strategic recommendations for better email management
    Focus on actionable insights, not just statistics. Help the user understand what's important and what to do about it.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these emails from today: ${JSON.stringify(emailSummaries.slice(0, 50))}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_daily_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_daily_insights') {
      throw new Error('Failed to generate daily insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async understandInsightsQuery(query: string): Promise<{
    insight_type: 'daily_summary' | 'weekly_summary' | 'important_items' | 'response_needed' | 'analytics' | 'relationships';
    time_period?: string;
    focus_area?: string;
  }> {
    const tools = [{
      type: "function" as const,
      name: "understand_insights_request",
      description: "Understand what kind of email insights the user wants",
      parameters: {
        type: "object",
        properties: {
          insight_type: {
            type: "string",
            enum: ["daily_summary", "weekly_summary", "important_items", "response_needed", "analytics", "relationships"],
            description: "The type of insight requested"
          },
          time_period: {
            type: ["string", "null"],
            description: "Time period for the insights (e.g., 'today', 'this week', 'last month')"
          },
          focus_area: {
            type: ["string", "null"],
            description: "Specific area to focus on (e.g., 'project X', 'client emails')"
          }
        },
        required: ["insight_type", "time_period", "focus_area"],
        additionalProperties: false
      }
    }];
    const systemPrompt = `You are an email insights assistant. Analyze the user's request and determine what kind of email insights they want.
Examples:
- "summarize my emails today" → daily_summary
- "what emails need my response?" → response_needed
- "show me email analytics for this week" → analytics, time_period: "this week"
- "who am I communicating with most?" → relationships
- "what important emails did I get this week?" → important_items, time_period: "this week"
- "weekly summary" → weekly_summary`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "understand_insights_request" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'understand_insights_request') {
      throw new Error('Failed to understand insights request');
    }
    const result = JSON.parse(toolCall.arguments);
    return {
      insight_type: result.insight_type,
      time_period: result.time_period || undefined,
      focus_area: result.focus_area || undefined
    };
  }
  async generateWeeklyInsights(emails: Email[], analysis: EmailAnalysis[], emailsByDay: Record<string, Email[]>): Promise<{
    executive_summary: string;
    week_trend: string;
    key_themes: string[];
    productivity_insights: string[];
    important_conversations: string[];
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_weekly_insights",
        description: "Generate comprehensive weekly email insights with trends and patterns",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "A comprehensive executive summary of the week's email activity"
            },
            week_trend: {
              type: "string",
              description: "Description of how this week compared to typical patterns"
            },
            key_themes: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Main themes and topics from the week's emails"
            },
            productivity_insights: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Insights about email patterns and productivity"
            },
            important_conversations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Key conversations and threads from the week"
            },
            recommendations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Actionable recommendations for the upcoming week"
            }
          },
          required: ["executive_summary", "week_trend", "key_themes", "productivity_insights", "important_conversations", "recommendations"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    // Prepare data for AI analysis
    const dailyVolumes = Object.entries(emailsByDay).map(([day, emails]) => ({
      day,
      count: emails.length,
      unread: emails.filter(e => e.unread).length
    }));
    const emailSummaries = emails.slice(0, 100).map(e => ({
      subject: e.subject,
      from: e.from[0]?.name || e.from[0]?.email || 'unknown',
      date: new Date(e.date * 1000).toLocaleDateString(),
      unread: e.unread,
      importance: analysis.find(a => a.email_id === e.id)?.importance_score || 0.5
    }));
    const systemPrompt = `You are an executive email assistant providing weekly insights. Analyze the week's email activity and provide:
    1. An executive summary highlighting major themes, important items, and overall email health
    2. Week-over-week trends (busier/quieter than usual, unusual patterns)
    3. Key themes and topics that dominated the week
    4. Productivity insights (response patterns, email overload indicators, time management)
    5. Important conversations that need follow-up
    6. Strategic recommendations for the upcoming week
    Daily volumes: ${JSON.stringify(dailyVolumes)}
    Total emails: ${emails.length}
    Unread: ${emails.filter(e => e.unread).length}
    Focus on actionable insights and patterns that help improve email management.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these emails from the past week: ${JSON.stringify(emailSummaries)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_weekly_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_weekly_insights') {
      throw new Error('Failed to generate weekly insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateImportantItemsInsights(emails: Email[], analysis: EmailAnalysis[]): Promise<{
    executive_summary: string;
    priority_items: Array<{
      email_id: string;
      subject: string;
      from: string;
      importance_reason: string;
      action_required: string;
    }>;
    action_plan: string[];
    key_deadlines: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_important_items",
        description: "Generate insights about important emails requiring attention",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "A concise summary of what important items need attention"
            },
            priority_items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  email_id: {
                    type: "string",
                    description: "ID of the important email"
                  },
                  subject: {
                    type: "string",
                    description: "Email subject"
                  },
                  from: {
                    type: "string",
                    description: "Sender name or email"
                  },
                  importance_reason: {
                    type: "string",
                    description: "Why this email is important"
                  },
                  action_required: {
                    type: "string",
                    description: "What action needs to be taken"
                  }
                },
                required: ["email_id", "subject", "from", "importance_reason", "action_required"],
                additionalProperties: false
              },
              description: "List of important emails with details"
            },
            action_plan: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Prioritized list of actions to take"
            },
            key_deadlines: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Important deadlines extracted from emails"
            }
          },
          required: ["executive_summary", "priority_items", "action_plan", "key_deadlines"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    const importantEmails = analysis
      .filter(a => a.importance_score > 0.7)
      .map(a => {
        const email = emails.find(e => e.id === a.email_id);
        return {
          id: a.email_id,
          subject: email?.subject || 'Unknown',
          from: email?.from[0]?.name || email?.from[0]?.email || 'Unknown',
          snippet: email?.snippet || '',
          importance_score: a.importance_score,
          reason: a.reason,
          action_required: a.action_required
        };
      });
    const systemPrompt = `You are an executive email assistant analyzing important emails. Provide:
    1. A clear summary of what needs attention
    2. Detailed breakdown of each important item
    3. A prioritized action plan
    4. Key deadlines to remember
    Focus on actionable insights and help the user understand what to do next.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these important emails: ${JSON.stringify(importantEmails)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_important_items" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_important_items') {
      throw new Error('Failed to generate important items insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateResponseNeededInsights(emails: Email[], needsResponse: Email[]): Promise<{
    executive_summary: string;
    response_priorities: Array<{
      email_id: string;
      subject: string;
      from: string;
      urgency: 'high' | 'medium' | 'low';
      suggested_response: string;
      context: string;
    }>;
    response_strategy: string[];
    time_estimate: string;
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_response_insights",
        description: "Generate insights about emails needing responses",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "Summary of emails needing responses with urgency assessment"
            },
            response_priorities: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  email_id: {
                    type: "string",
                    description: "Email ID"
                  },
                  subject: {
                    type: "string",
                    description: "Email subject"
                  },
                  from: {
                    type: "string",
                    description: "Sender"
                  },
                  urgency: {
                    type: "string",
                    enum: ["high", "medium", "low"],
                    description: "Response urgency level"
                  },
                  suggested_response: {
                    type: "string",
                    description: "Brief suggestion for how to respond"
                  },
                  context: {
                    type: "string",
                    description: "Context about why this needs a response"
                  }
                },
                required: ["email_id", "subject", "from", "urgency", "suggested_response", "context"],
                additionalProperties: false
              },
              description: "Prioritized list of emails needing responses"
            },
            response_strategy: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Strategic recommendations for handling responses"
            },
            time_estimate: {
              type: "string",
              description: "Estimated time needed to respond to all emails"
            }
          },
          required: ["executive_summary", "response_priorities", "response_strategy", "time_estimate"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    const responseData = needsResponse.slice(0, 20).map(email => ({
      id: email.id,
      subject: email.subject,
      from: email.from[0]?.name || email.from[0]?.email || 'Unknown',
      snippet: email.snippet || '',
      date: new Date(email.date * 1000).toLocaleDateString()
    }));
    const systemPrompt = `You are an email response strategist. Analyze emails that need responses and provide:
    1. An executive summary with urgency levels
    2. Prioritized response recommendations
    3. Strategic advice for efficient response handling
    4. Time estimates for completing responses
    Help the user tackle their response backlog efficiently.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these emails needing responses: ${JSON.stringify(responseData)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_response_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_response_insights') {
      throw new Error('Failed to generate response insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateAnalyticsInsights(
    emails: Email[],
    timePeriod: string,
    senderStats: Map<string, number>,
    categories: Record<string, number>
  ): Promise<{
    executive_summary: string;
    volume_analysis: {
      trend: string;
      pattern: string;
      anomalies: string[];
    };
    sender_insights: {
      top_relationships: string[];
      communication_balance: string;
      new_contacts: string[];
    };
    productivity_metrics: {
      response_rate: string;
      peak_hours: string[];
      email_habits: string[];
    };
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_analytics",
        description: "Generate comprehensive email analytics insights",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "High-level summary of email patterns and insights"
            },
            volume_analysis: {
              type: "object",
              properties: {
                trend: {
                  type: "string",
                  description: "Overall volume trend description"
                },
                pattern: {
                  type: "string",
                  description: "Daily/weekly patterns observed"
                },
                anomalies: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Unusual patterns or spikes"
                }
              },
              required: ["trend", "pattern", "anomalies"],
              additionalProperties: false
            },
            sender_insights: {
              type: "object",
              properties: {
                top_relationships: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Most frequent email contacts"
                },
                communication_balance: {
                  type: "string",
                  description: "Analysis of communication patterns"
                },
                new_contacts: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "New contacts in this period"
                }
              },
              required: ["top_relationships", "communication_balance", "new_contacts"],
              additionalProperties: false
            },
            productivity_metrics: {
              type: "object",
              properties: {
                response_rate: {
                  type: "string",
                  description: "Email response rate analysis"
                },
                peak_hours: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Peak email activity hours"
                },
                email_habits: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Observed email habits and patterns"
                }
              },
              required: ["response_rate", "peak_hours", "email_habits"],
              additionalProperties: false
            },
            recommendations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Actionable recommendations for email management"
            }
          },
          required: ["executive_summary", "volume_analysis", "sender_insights", "productivity_metrics", "recommendations"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    // Prepare analytics data
    const topSenders = Array.from(senderStats.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([sender, count]) => ({ sender, count }));
    const hourlyDistribution = emails.reduce((acc, email) => {
      const hour = new Date(email.date * 1000).getHours();
      acc[hour] = (acc[hour] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);
    const analyticsData = {
      period: timePeriod,
      total_emails: emails.length,
      unread_count: emails.filter(e => e.unread).length,
      top_senders: topSenders,
      categories: categories,
      hourly_distribution: hourlyDistribution,
      daily_average: emails.length / (timePeriod === 'week' ? 7 : timePeriod === 'month' ? 30 : 1)
    };
    const systemPrompt = `You are an email analytics expert. Analyze email patterns and provide:
    1. Executive summary of key findings
    2. Volume trends and anomalies
    3. Sender relationship insights
    4. Productivity metrics and habits
    5. Actionable recommendations
    Focus on insights that help improve email productivity and communication effectiveness.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these email analytics: ${JSON.stringify(analyticsData)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_analytics" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_analytics') {
      throw new Error('Failed to generate analytics insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateRelationshipInsights(
    emails: Email[],
    contactStats: Map<string, { sent: number; received: number; importance: number }>
  ): Promise<{
    executive_summary: string;
    key_relationships: Array<{
      contact: string;
      relationship_type: string;
      communication_style: string;
      insights: string[];
    }>;
    communication_patterns: {
      balance_analysis: string;
      response_patterns: string[];
      collaboration_insights: string[];
    };
    network_insights: {
      growing_relationships: string[];
      neglected_contacts: string[];
      communication_health: string;
    };
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_relationship_insights",
        description: "Generate insights about email relationships and communication patterns",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "Summary of key relationship insights"
            },
            key_relationships: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  contact: {
                    type: "string",
                    description: "Contact email or name"
                  },
                  relationship_type: {
                    type: "string",
                    description: "Type of relationship (e.g., 'colleague', 'client', 'manager')"
                  },
                  communication_style: {
                    type: "string",
                    description: "Description of communication patterns"
                  },
                  insights: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "Specific insights about this relationship"
                  }
                },
                required: ["contact", "relationship_type", "communication_style", "insights"],
                additionalProperties: false
              },
              description: "Analysis of key email relationships"
            },
            communication_patterns: {
              type: "object",
              properties: {
                balance_analysis: {
                  type: "string",
                  description: "Analysis of communication balance"
                },
                response_patterns: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Patterns in email responses"
                },
                collaboration_insights: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Insights about collaboration patterns"
                }
              },
              required: ["balance_analysis", "response_patterns", "collaboration_insights"],
              additionalProperties: false
            },
            network_insights: {
              type: "object",
              properties: {
                growing_relationships: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Relationships that are growing stronger"
                },
                neglected_contacts: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Contacts that may need more attention"
                },
                communication_health: {
                  type: "string",
                  description: "Overall assessment of communication health"
                }
              },
              required: ["growing_relationships", "neglected_contacts", "communication_health"],
              additionalProperties: false
            },
            recommendations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Recommendations for improving relationships"
            }
          },
          required: ["executive_summary", "key_relationships", "communication_patterns", "network_insights", "recommendations"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    // Prepare relationship data
    const relationships = Array.from(contactStats.entries())
      .map(([contact, stats]) => ({
        contact,
        total_interactions: stats.sent + stats.received,
        balance: stats.sent / (stats.received || 1),
        avg_importance: stats.importance / (stats.received || 1),
        sent: stats.sent,
        received: stats.received
      }))
      .sort((a, b) => b.total_interactions - a.total_interactions)
      .slice(0, 20);
    const systemPrompt = `You are a relationship analyst specializing in email communication. Analyze communication patterns and provide:
    1. Key relationship insights
    2. Communication style analysis
    3. Network health assessment
    4. Actionable recommendations
    Focus on helping improve professional relationships and communication effectiveness.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these email relationships: ${JSON.stringify(relationships)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_relationship_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_relationship_insights') {
      throw new Error('Failed to generate relationship insights');
    }
    return JSON.parse(toolCall.arguments);
  }
}
</file>

<file path="tests/e2e/config.ts">
export const E2E_CONFIG = {
  // API Configuration
  nylas: {
    grantId: process.env.NYLAS_GRANT_ID!,
    testEmail: process.env.TEST_EMAIL_ADDRESS!
  },
  openai: {
    apiKey: process.env.OPENAI_API_KEY!,
    model: 'gpt-5-mini', // Cheaper model for tests
    graderModel: 'gpt-5-mini'
  },
  // Test Configuration
  timeouts: {
    default: 30000,
    approval: 60000,
    setup: 120000
  },
  // Grading Thresholds (0-100)
  grading: {
    passingScore: 70,
    excellentScore: 90,
    criteria: {
      queryUnderstanding: { weight: 0.3 },
      actionAccuracy: { weight: 0.3 },
      responseQuality: { weight: 0.2 },
      errorHandling: { weight: 0.2 }
    }
  },
  // Interactive Mode
  interactive: {
    enabled: process.env.CI !== 'true',
    approvalTimeout: 30000
  },
  // Test Data
  testData: {
    emailPrefix: '[E2E Test]',
    cleanupAfterTests: true
  }
};
</file>

<file path="README.md">
# Inbox MCP

An example MCP (Model Context Protocol) server for Juli that provides AI-powered email management. This is one of the default apps every Juli user gets when they sign up.

## What it does

- Send, reply, and manage emails with natural language
- Find and analyze emails intelligently  
- Organize your inbox with AI-powered rules
- Get insights and summaries about your email patterns

## For Juli Users

Inbox MCP is pre-installed with your Juli account. Click Connect in Juli, sign in to your email provider, and start using natural language commands like:
- "Reply to Sarah about the meeting"
- "Find important emails from this week"
- "Clean up my inbox"

Notes:
- You do not need a Nylas account. Authentication is handled via Nylas Hosted Auth.
- Juli stores only your grant_id and injects it automatically when calling the tools.

## For MCP Developers

This repository serves as a reference implementation for building MCP servers for Juli. It demonstrates:
- HTTP-based stateless architecture
- Juli's credential injection system
- Natural language tool design
- Approval flows for sensitive actions

See [docs/MCP_DEVELOPER_GUIDE.md](docs/MCP_DEVELOPER_GUIDE.md) for the complete guide.

### Agent Quickstart (A2A JSON‑RPC)

1) Discover
- GET `/.well-known/a2a.json` → Agent Card (auth, approvals, context, capabilities, rpc)

2) Authenticate (agent→agent)
- Send OIDC ID token: `Authorization: Bearer <ID_TOKEN>` (audience/issuers from the card)
- Optional dev-only header: `X-A2A-Dev-Secret`

3) Obtain user credential (EMAIL_ACCOUNT_GRANT)
- GET `/.well-known/a2a-credentials.json` → pick a flow (hosted_auth)
- Open `connect_url` in a browser, complete provider login, receive `grant_id` from callback
- Store `grant_id` as `EMAIL_ACCOUNT_GRANT`

4) Execute a tool
```bash
curl -sS -H "Authorization: Bearer $ID_TOKEN" \
  -H 'Content-Type: application/json' \
  -d '{
    "jsonrpc":"2.0","id":"1","method":"tool.execute",
    "params":{
      "tool":"manage_email",
      "arguments":{ "action":"send", "query":"email test@example.com about tomorrow" },
      "user_context":{ "credentials": { "EMAIL_ACCOUNT_GRANT":"<grant>" } },
      "request_id":"<uuid>"
    }
  }' http://localhost:3000/a2a/rpc
```

5) Approve when required
```bash
curl -sS -H "Authorization: Bearer $ID_TOKEN" -H 'Content-Type: application/json' \
  -d '{
    "jsonrpc":"2.0","id":"2","method":"tool.approve",
    "params":{
      "tool":"manage_email",
      "original_arguments":{ "action":"send", "query":"..." },
      "action_data":{ /* from preview */ },
      "user_context":{ "credentials": { "EMAIL_ACCOUNT_GRANT":"<grant>" } },
      "request_id":"<uuid>"
    }
  }' http://localhost:3000/a2a/rpc
```

## Quick Start

```bash
# Install dependencies
npm install

# Build and run
npm run build
npm start

# Or use Docker
docker-compose up
```

### Required environment variables

Set the following for the server (no user API keys are injected):

```
OPENAI_API_KEY=sk-...
NYLAS_API_KEY=nyk_...
NYLAS_CLIENT_ID=...
NYLAS_CALLBACK_URI=http://localhost:3000/api/nylas-email/callback
# Optional (defaults to US):
NYLAS_API_URI=https://api.us.nylas.com
```

### Connect your email (Hosted Auth)

1) Check if setup is needed
```
GET /setup/status
→ { "needs_setup": true, "connect_url": "/setup/connect-url" }
```

2) Get the Hosted Auth URL
```
GET /setup/connect-url?redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fapi%2Fnylas-email%2Fcallback
→ { "url": "https://api.us.nylas.com/v3/connect/auth?..." }
```
Open the returned URL and complete the provider login.

3) Callback returns your grant
```
GET /api/nylas-email/callback?code=...
→ { "success": true, "grant_id": "...", "email": "user@example.com" }
```
Juli stores the grant_id and injects it as `X-User-Credential-NYLAS_GRANT_ID` on every tool request.

## Documentation

- [MCP Developer Guide](docs/MCP_DEVELOPER_GUIDE.md) - Build MCP servers for Juli
- [Tools Documentation](docs/TOOLS_DOCUMENTATION.md) - All available tools
- [Approval System](docs/APPROVAL_SYSTEM_GUIDE.md) - How approvals work
- [Docker Guide](docs/DOCKER_GUIDE.md) - Deployment instructions

## License

MIT - See [LICENSE](LICENSE)
</file>

</files>
