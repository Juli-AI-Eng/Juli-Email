This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
A2A_HANDOFF.md
APPROVAL_SYSTEM_GUIDE.md
CLAUDE.md
DOCKER_GUIDE.md
MCP_DEVELOPER_GUIDE.md
TOOLS_DOCUMENTATION.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="A2A_HANDOFF.md">
# Juli Email A2A Integration Handoff

Audience: Juli Brain team

## Summary
- Use JSON-RPC A2A as the interface between Juli Brain and this agent.
- Keep connector model (server env: `NYLAS_API_KEY`, Brain injects `EMAIL_ACCOUNT_GRANT`).
- Authenticate Brain ‚Üí Email using OIDC ID tokens; dev shared secret optional.

Reference: A2A protocol overview and goals are outlined here: https://github.com/a2aproject/A2A

## Discovery
- GET `/.well-known/a2a.json` ‚Üí Agent Card with:
  - `agent_id`, `version`, `capabilities` (tools + JSON schemas)
  - `approvals.modes: ["stateless_preview_then_approve"]`
  - `auth`: single scheme or `{ schemes: [...] }`
  - `rpc: { endpoint: "/a2a/rpc" }`
  - `extensions.x-juli.credentials_manifest: "/.well-known/a2a-credentials.json"`

## Auth
- Production: Obtain Google OIDC ID token with audience = `A2A_AUDIENCE` (or server base URL). Send `Authorization: Bearer <id_token>`.
- Dev: send `X-A2A-Dev-Secret` when configured.

## Execute Flow (JSON-RPC)
- POST `/a2a/rpc` with:
```json
{ "jsonrpc":"2.0","id":"1","method":"tool.execute","params":{ "tool":"manage_email","arguments":{},"user_context":{"credentials":{"EMAIL_ACCOUNT_GRANT":"<uuid>"}},"request_id":"<uuid>" } }
```
- Responses:
  - Success: `{ "request_id": "...", "result": { ... } }`
  - Approval required: `{ "request_id": "...", "result": { "needs_approval": true, "action_type": "send_email", "action_data": { ... }, "preview": { ... } } }`
  - Error: `{ "request_id": "...", "error": "message" }`

## Approve Flow (JSON-RPC)
- POST `/a2a/rpc` with:
```json
{ "jsonrpc":"2.0","id":"2","method":"tool.approve","params":{ "tool":"manage_email","original_arguments":{},"action_data":{},"user_context":{"credentials":{"EMAIL_ACCOUNT_GRANT":"<uuid>"}},"request_id":"<uuid>" } }
```
- Response: `{ "request_id": "...", "result": { "success": true, "message_id": "..." } }`

## Required from Juli Brain
1) Agent auth
- Provision a Google service account able to mint OIDC ID tokens for audience = `A2A_AUDIENCE` (set to the Email base URL in env).
- Attach `Authorization: Bearer <id_token>` to all A2A requests.
- For local dev, support `X-A2A-Dev-Secret`.

2) Credential injection
- Keep storing `NYLAS_GRANT_ID` and include it in `user_context.credentials` on each A2A call.

3) Discovery
- On agent registration or periodically, read `/.well-known/a2a.json` to cache capabilities and input schemas.

4) Approval UX
- Handle `needs_approval` by surfacing preview and safeties; call `/a2a/approve` with the returned `action_data`.

5) Error handling & retries
- Respect 400/401/500 codes; retry idempotent calls; treat `request_id` as unique per call; prevent replay.

## Environment variables
- Server:
  - `NYLAS_API_KEY`, `NYLAS_CLIENT_ID`, `NYLAS_CALLBACK_URI`, `NYLAS_API_URI`
  - `A2A_AUDIENCE` (optional; defaults to server base URL)
  - `A2A_DEV_SHARED_SECRET` (dev only)
</file>

<file path="APPROVAL_SYSTEM_GUIDE.md">
# Juli Approval System Guide

Understanding how the approval system works between Juli and MCP servers for safe execution of sensitive actions.

## Overview

The approval system ensures users maintain control over potentially impactful actions. When an MCP server needs user confirmation before proceeding, it returns a special response that Juli intercepts and handles with a native UI.

## How It Works

### Flow Diagram

```
User Request ‚Üí MCP Server ‚Üí Needs Approval? ‚Üí Return Approval Request
                                ‚Üì                        ‚Üì
                              No                    Juli Shows UI
                                ‚Üì                        ‚Üì
                          Execute Action            User Decides
                                                         ‚Üì
                                                   Approve/Deny
                                                         ‚Üì
                                                  Retry with Decision
```

### The Stateless Approval Protocol

**Key Principle**: MCP servers don't store pending approvals. Instead, they return all data needed to execute the action, and Juli handles the approval UI and retry.

## Implementation

### 1. When to Require Approval

```typescript
function needsApproval(action: any): boolean {
  // Require approval for:
  // - Sending emails
  // - Deleting data
  // - Bulk operations
  // - Financial transactions
  // - Any irreversible actions
  
  return action.type === 'send' || 
         action.bulk_count > 10 ||
         action.involves_money ||
         action.is_destructive;
}
```

### 2. Approval Response Format

```typescript
interface ApprovalRequiredResponse {
  needs_approval: true;
  action_type: string;        // Type of action requiring approval
  action_data: any;          // Complete data needed to execute
  preview: {
    summary: string;         // One-line summary
    details: any;           // Detailed preview info
    risks?: string[];       // Optional warnings
  };
  suggested_modifications?: any;  // Optional suggestions
}
```

### 3. Real Example: Email Approval

```typescript
// User says: "reply to Sarah about the meeting"
async function handleManageEmail(params: any) {
  // AI generates the email
  const emailContent = await generateEmail(params.query);
  
  // Check if approval needed
  if (params.action === 'send' && !params.approved) {
    return {
      needs_approval: true,
      action_type: 'send_email',
      action_data: {
        email_content: {
          to: ['sarah@company.com'],
          subject: 'Re: Tomorrow\'s Meeting',
          body: 'Hi Sarah,\n\nThank you for...',
          thread_id: 'thread_123'
        },
        original_params: params
      },
      preview: {
        summary: 'Send email to sarah@company.com',
        details: {
          recipient: 'Sarah Johnson',
          subject: 'Re: Tomorrow\'s Meeting',
          word_count: 127,
          has_attachments: false
        }
      }
    };
  }
  
  // If approved, execute
  if (params.approved && params.action_data) {
    const result = await sendEmail(params.action_data.email_content);
    return {
      success: true,
      message: 'Email sent successfully',
      message_id: result.id
    };
  }
}
```

### 4. Bulk Operations Example

```typescript
// User says: "archive all newsletters older than a month"
async function handleOrganizeInbox(params: any) {
  // Find matching emails
  const emails = await findEmails({
    category: 'newsletter',
    older_than: '1 month'
  });
  
  // Require approval for bulk operations
  if (!params.confirmed) {
    return {
      needs_approval: true,
      action_type: 'bulk_archive',
      action_data: {
        email_ids: emails.map(e => e.id),
        operation: 'archive',
        filter_used: params.instruction
      },
      preview: {
        summary: `Archive ${emails.length} newsletters`,
        details: {
          count: emails.length,
          oldest_email: emails[0]?.date,
          newest_email: emails[emails.length-1]?.date,
          sample_subjects: emails.slice(0, 3).map(e => e.subject)
        },
        risks: emails.length > 100 ? 
          ['This will archive a large number of emails'] : 
          undefined
      }
    };
  }
  
  // Execute if confirmed
  if (params.confirmed && params.action_data) {
    await archiveEmails(params.action_data.email_ids);
    return {
      success: true,
      message: `Archived ${params.action_data.email_ids.length} emails`
    };
  }
}
```

## What Juli Handles

### 1. Approval UI

When Juli receives a `needs_approval` response, it:

```typescript
// Juli's internal handling
if (response.needs_approval) {
  // Show native approval dialog
  const userDecision = await showApprovalDialog({
    title: response.action_type,
    summary: response.preview.summary,
    details: response.preview.details,
    risks: response.preview.risks
  });
  
  if (userDecision.approved) {
    // Retry with approval
    const finalResponse = await callMCPTool(toolName, {
      ...originalParams,
      approved: true,
      action_data: response.action_data
    });
    return finalResponse;
  } else {
    // User denied
    return {
      cancelled: true,
      message: 'Action cancelled by user'
    };
  }
}
```

### 2. Approval UI Components

Juli renders a beautiful approval dialog with:
- Clear action summary
- Detailed preview (formatted based on action type)
- Risk warnings in red
- Approve/Deny buttons
- Optional "Modify" button for editable actions

### 3. Modification Flow

For editable actions (like emails), users can modify before approving:

```typescript
// MCP returns suggested modifications
{
  needs_approval: true,
  action_type: 'send_email',
  action_data: { ... },
  preview: { ... },
  suggested_modifications: {
    editable_fields: ['body', 'subject'],
    constraints: {
      body: { max_length: 10000 },
      subject: { max_length: 200 }
    }
  }
}

// Juli allows editing these fields in the approval dialog
```

## Best Practices

### 1. Clear Preview Information

```typescript
// ‚úÖ Good: Specific and actionable
preview: {
  summary: 'Send email to 3 team members about project update',
  details: {
    recipients: ['john@company.com', 'sarah@company.com', 'mike@company.com'],
    subject: 'Project Alpha: Status Update',
    mentions_deadline: true,
    attachments: 0
  }
}

// ‚ùå Bad: Vague
preview: {
  summary: 'Send email',
  details: { count: 3 }
}
```

### 2. Appropriate Risk Warnings

```typescript
risks: [
  // Only include real risks
  'This will permanently delete 42 records',
  'Email will be sent to all 1,847 subscribers',
  'This action cannot be undone'
]

// Don't include non-risks like:
// 'This will send an email' (obvious from action)
// 'Please review before approving' (redundant)
```

### 3. Granular Approval Control

```typescript
// Allow users to control approval preferences
interface ToolParams {
  require_approval?: boolean;  // Override default
  auto_approve_threshold?: number;  // For bulk operations
}

// Example: Don't require approval for small operations
if (emails.length <= 5 && !params.require_approval) {
  // Execute without approval
}
```

### 4. Stateless Design

```typescript
// ‚úÖ Good: Return all data needed
return {
  needs_approval: true,
  action_data: {
    email_content: fullEmailObject,
    thread_id: threadId,
    references: messageReferences
  }
};

// ‚ùå Bad: Storing state
const approvalId = generateId();
pendingApprovals.set(approvalId, emailData);
return {
  needs_approval: true,
  approval_id: approvalId  // Don't do this!
};
```

## Common Approval Scenarios

### 1. Communication Actions
- Sending emails
- Posting to social media
- Sending messages
- Making phone calls

### 2. Data Modifications
- Deleting records
- Bulk updates
- Archiving content
- Modifying sensitive data

### 3. Financial Operations
- Processing payments
- Issuing refunds
- Changing billing
- Subscription modifications

### 4. System Changes
- Deploying code
- Changing configurations
- Updating permissions
- Modifying integrations

## Testing Approvals

```typescript
describe('Approval Flow', () => {
  it('should require approval for sending emails', async () => {
    const response = await mcp.handleTool('manage_email', {
      action: 'send',
      query: 'email John about the meeting'
    });
    
    expect(response.needs_approval).toBe(true);
    expect(response.action_type).toBe('send_email');
    expect(response.action_data).toHaveProperty('email_content');
    expect(response.preview.summary).toContain('Send email');
  });
  
  it('should execute when approved', async () => {
    const approvalResponse = await mcp.handleTool('manage_email', {
      action: 'send',
      query: 'email John about the meeting'
    });
    
    const finalResponse = await mcp.handleTool('manage_email', {
      ...approvalResponse.action_data.original_params,
      approved: true,
      action_data: approvalResponse.action_data
    });
    
    expect(finalResponse.success).toBe(true);
    expect(finalResponse.message).toContain('sent');
  });
});
```

## Security Considerations

### 1. Action Data Validation

Always re-validate action data when executing approved actions:

```typescript
if (params.approved && params.action_data) {
  // Re-validate the action data
  if (!isValidEmailContent(params.action_data.email_content)) {
    return {
      error: 'Invalid email content in approval data'
    };
  }
  
  // Verify it matches what would be generated
  const expectedContent = await generateEmail(params.action_data.original_params);
  if (!contentMatches(expectedContent, params.action_data.email_content)) {
    return {
      error: 'Approval data does not match expected content'
    };
  }
}
```

### 2. Prevent Approval Bypass

```typescript
// Always check approval status for sensitive actions
if (action.type === 'send' && !params.approved) {
  // Force approval flow
  return { needs_approval: true, ... };
}

// Don't allow approval flag without action_data
if (params.approved && !params.action_data) {
  return {
    error: 'Approved flag requires action_data'
  };
}
```

## Summary

The Juli approval system provides:

1. **User Control** - Users always have final say on sensitive actions
2. **Transparency** - Clear previews of what will happen
3. **Flexibility** - Developers decide what needs approval
4. **Simplicity** - Stateless design makes implementation easy
5. **Security** - No way to bypass user approval for sensitive actions

By following this guide, your MCP server will integrate seamlessly with Juli's approval system, giving users confidence to use powerful tools while maintaining control over their data and actions.
</file>

<file path="CLAUDE.md">
# AI Email Assistant MCP - Transformation Guide

## CRITICAL UPDATE: HTTP-Only Multi-User Architecture (2025-01-26)

### Major Architectural Changes - COMPLETE REMOVAL OF STDIO

We are converting Inbox MCP from stdio-based single-user to HTTP-only multi-user architecture:

1. **Transport Layer**: 
   - **REMOVED**: All stdio transport, MCP SDK stdio dependencies
   - **ADDED**: Express HTTP server with stateless request/response
   - **Endpoints**: GET /mcp/tools, POST /mcp/tools/:toolName

2. **Multi-User Support**:
   - Single HTTP server instance handles ALL users
   - User credentials injected per-request via HTTP headers
   - Headers: `X-User-Credential-NYLAS_GRANT_ID`
   - No process spawning, no per-user instances

3. **Credential Management**:
   - **NO LOCAL STORAGE**: No user credential storage on the server
   - Juli stores only the user `grant_id` and injects it per request
   - Nylas API key is a server environment variable
   - SetupManager may validate but does not store credentials
   - **OpenAI API Key**: MCP server provider's responsibility (from environment)

4. **Stateless Architecture**:
   - No global state or cached clients
   - Create Nylas client per-request with injected credentials
   - Complete user isolation through stateless design
   - Stateless approvals - no server-side storage needed

5. **Tool Execution Flow**:
   ```
   User ‚Üí Juli ‚Üí HTTP Request with credentials ‚Üí Inbox MCP
                                                    ‚Üì
                                            Create Nylas client
                                                    ‚Üì
                                              Execute tool
                                                    ‚Üì
                                              Return result
   ```

This makes Inbox MCP a simple, scalable HTTP API that Juli calls with per-request credential injection.

## Development Methodology: Test-Driven Development

ALWAYS REFERENCE THE function_calling.md FILE WHEN DOING STUFF WITH OPENAI DO NOT GUESS RESARCH.

### Red-Green-Refactor Cycle

This transformation should be built using strict TDD principles:

1. **üî¥ Red**: Write a failing test for the next small functionality
2. **üü¢ Green**: Write the minimum code to make the test pass
3. **üîÑ Refactor**: Clean up the code while keeping tests green

### Test-First Approach for Each Component

```typescript
// Example: Testing the manage_email tool

// 1. RED - Write the test first
describe('manage_email tool', () => {
  it('should parse natural language email request', async () => {
    const result = await mcp.handleManageEmail({
      action: 'send',
      query: 'reply to Sarah thanking her for the proposal'
    });
    
    expect(result.type).toBe('approval_required');
    expect(result.preview.details.to).toContain('sarah@example.com');
    expect(result.preview.details.subject).toMatch(/proposal/i);
  });
});

// 2. GREEN - Implement just enough to pass
async handleManageEmail(params) {
  const intent = await this.emailAI.understandQuery(params.query);
  // Minimal implementation
}

// 3. REFACTOR - Clean up and optimize
async handleManageEmail(params) {
  const intent = await this.emailAI.understandQuery(params.query);
  const emailContent = await this.generateEmailContent(intent);
  return this.createApprovalRequest(emailContent);
}
```

### Testing Strategy

1. **Unit Tests**: Each AI function, approval flow, and tool handler
2. **Integration Tests**: MCP protocol compliance, Nylas API interaction
3. **End-to-End Tests**: Complete user flows from natural language to email sent
4. **Mock Everything**: Use mocked Nylas responses and OpenAI calls for fast tests

## Overview

Transform the Inbox MCP into an intelligent email assistant microservice that operates as an "email expert" within the larger Juli AI system. This guide outlines a complete reimagining with AI-first design and seamless approval workflows.

## Core Philosophy

**Think like an AI Email Expert**: Every tool should feel natural when the user says things like "reply to John about the meeting" or "summarize what needs my attention today". The AI handles all the complexity.

## Smart Approval Protocol

### The Problem with Traditional Approvals
Traditional approval flows break the natural conversation. We need something seamless.

### The Solution: Stateless Approval Protocol (Updated 2025-01-26)

**IMPORTANT UPDATE**: We've moved to a fully stateless approval system that doesn't require any server-side storage.

**What Juli Handles:**
- Detecting needs_approval responses
- Rendering approval UI with action preview
- Collecting user decision (approve/deny/modify)
- Retrying the call with complete action data
- No approval tokens or IDs needed

**What MCP Handles:**
- Deciding when approval is needed
- Returning complete action data with preview
- Executing pre-approved actions directly
- No storage of pending approvals

When an action requires approval, the MCP server returns all necessary data for Juli to execute it later:

```typescript
interface ApprovalRequiredResponse {
  needs_approval: true;
  action_type: 'send_email' | 'organize_inbox' | 'apply_smart_folder';
  action_data: any; // Complete data needed to execute the action
  preview: {
    summary: string;
    details: any; // Action-specific details
    risks?: string[]; // Optional warnings
  };
  suggested_modifications?: any;
}
```

Juli's orchestrator intercepts these responses and shows a native approval UI. When approved, it calls the tool again with the complete action data:

```typescript
// First call
AI: manage_email({ action: "send", query: "reply to John about postponing the meeting" })
MCP: { 
  needs_approval: true,
  action_type: "send_email",
  action_data: { 
    email_content: { to: ["john@company.com"], subject: "Re: Meeting", body: "..." },
    original_params: { action: "send", query: "..." }
  },
  preview: { summary: "Email to john@company.com", ... }
}

// After user approves in Juli UI
AI: manage_email({ 
  action: "send", 
  query: "reply to John about postponing the meeting",
  approved: true,
  action_data: { 
    email_content: { to: ["john@company.com"], subject: "Re: Meeting", body: "..." },
    original_params: { action: "send", query: "..." }
  }
})
MCP: { success: true, message: "Email sent", message_id: "msg_123" }
```

**Benefits of Stateless Approach:**
- No server-side storage required
- Works perfectly with horizontal scaling
- Juli has full visibility of action data
- No cleanup timers or expiration handling
- Simpler architecture overall

## Authentication: Guided Self-Service Setup

### The Challenge
Nylas requires users to create an account, get an API key, and create a grant. This is friction we need to minimize with smart tooling.

### Responsibility Division

#### What Juli Handles:
- **Credential Storage**: Juli securely stores all credentials after validation
- **User Identity**: Juli provides the userId to the MCP server
- **UI Rendering**: Juli renders setup instructions and forms beautifully
- **Persistence**: Juli remembers which users have completed setup
- **Security**: Encryption, key management, and secure transmission

#### What the MCP Provider (You) Handle:
- **Setup Guidance**: Provide clear, structured setup instructions
- **Credential Validation**: Test that provided credentials actually work
- **Error Diagnostics**: Help users troubleshoot setup issues
- **Connection Testing**: Verify the email connection is functional
- **Graceful Degradation**: Handle missing credentials intelligently

### Solution: Intelligent Setup Tool with Verification
The MCP server provides a setup tool that returns structured data for Juli to render:

```typescript
{
  name: "setup_email_connection",
  description: "Set up your email connection with step-by-step guidance and automatic verification",
  parameters: {
    action: {
      type: "string",
      enum: ["get_instructions", "validate_credentials", "test_connection", "troubleshoot"],
      description: "What setup action to perform"
    },
    credentials: {
      type: "object",
      optional: true,
      properties: {
        nylas_api_key: { 
          type: "string",
          description: "Your Nylas API key from the dashboard"
        },
        nylas_grant_id: { 
          type: "string",
          description: "The grant ID after connecting your email" 
        }
      }
    },
    issue: {
      type: "string",
      optional: true,
      description: "Describe any issues you're having with setup"
    }
  }
}
```

### Detailed Setup Flow Implementation

```typescript
class IntelligentEmailSetup {
  private setupCache = new Map<string, SetupProgress>();
  
  async handleSetupEmailConnection(params: SetupParams, context: MCPContext): Promise<SetupResponse> {
    const userId = context.userId;
    
    switch (params.action) {
      case "get_instructions":
        return this.getDetailedInstructions(userId);
        
      case "validate_credentials":
        return this.validateAndStoreCredentials(params.credentials, userId);
        
      case "test_connection":
        return this.testEmailConnection(userId);
        
      case "troubleshoot":
        return this.troubleshootIssue(params.issue, userId);
    }
  }
  
  private async getDetailedInstructions(userId: string): Promise<InstructionResponse> {
    // Track setup progress
    this.setupCache.set(userId, { stage: 'instructions_viewed', timestamp: Date.now() });
    
    return {
      type: "setup_instructions",
      title: "Email Setup Guide",
      estimated_time: "5 minutes",
      steps: [
        {
          step: 1,
          title: "Create Your Free Nylas Account",
          description: "Nylas provides 5 free email connections - perfect for personal use!",
          actions: [
            {
              type: "link",
              label: "Open Nylas Signup",
              url: "https://dashboard-v3.nylas.com/register?utm_source=juli",
              description: "Opens in a new window"
            }
          ],
          tips: [
            "Use the same email you'll be connecting later",
            "No credit card required for free tier"
          ]
        },
        {
          step: 2,
          title: "Get Your API Key",
          description: "After signing in, find your API key in the dashboard",
          visual_guide: {
            description: "Look for 'API Keys' in the left sidebar",
            highlight_area: "sidebar > api_keys_section"
          },
          actions: [
            {
              type: "copy_field",
              label: "I'll paste my API key here",
              field: "nylas_api_key",
              validation: "regex:^nyk_[a-zA-Z0-9]+$"
            }
          ],
          tips: [
            "API key starts with 'nyk_'",
            "Keep this key secret - it's like a password!"
          ]
        },
        {
          step: 3,
          title: "Connect Your Email Account",
          description: "Add your email account to Nylas",
          substeps: [
            "Click 'Grants' in the sidebar",
            "Click 'Add Test Grant' button (top right)",
            "Choose your email provider (Gmail, Outlook, etc)",
            "Authorize Nylas to access your email",
            "Copy the Grant ID that appears"
          ],
          actions: [
            {
              type: "copy_field",
              label: "I'll paste my Grant ID here",
              field: "nylas_grant_id",
              validation: "regex:^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$"
            }
          ],
          common_issues: [
            {
              issue: "Can't find Grant ID",
              solution: "It's in the table under the 'ID' column after you connect"
            },
            {
              issue: "Authorization failed",
              solution: "Make sure to allow all requested permissions"
            }
          ]
        }
      ],
      next_step: {
        description: "Once you have both credentials, run:",
        command: "setup_email_connection",
        parameters: {
          action: "validate_credentials",
          credentials: {
            nylas_api_key: "your_key_here",
            nylas_grant_id: "your_grant_id_here"
          }
        }
      },
      help: {
        video_tutorial: "https://juli.ai/tutorials/email-setup",
        support_email: "support@juli.ai"
      }
    };
  }
  
  private async validateAndStoreCredentials(
    credentials: Credentials, 
    userId: string
  ): Promise<ValidationResponse> {
    // Input validation
    if (!credentials?.nylas_api_key || !credentials?.nylas_grant_id) {
      return {
        type: "validation_error",
        message: "Both API key and Grant ID are required",
        missing_fields: [
          !credentials?.nylas_api_key && "nylas_api_key",
          !credentials?.nylas_grant_id && "nylas_grant_id"
        ].filter(Boolean)
      };
    }
    
    // Format validation
    if (!credentials.nylas_api_key.startsWith('nyk_')) {
      return {
        type: "validation_error",
        message: "API key should start with 'nyk_'",
        field: "nylas_api_key",
        hint: "Check you copied the full API key from Nylas dashboard"
      };
    }
    
    // Test the credentials
    try {
      const testClient = new Nylas({ apiKey: credentials.nylas_api_key });
      
      // Try to fetch account info to verify grant
      const account = await testClient.grants.find({
        identifier: credentials.nylas_grant_id
      });
      
      // Get email address for confirmation
      const emailAddress = account.data.email || "your email";
      
      // Success! Return credentials for Juli to store
      return {
        type: "setup_success",
        message: `Successfully connected ${emailAddress}!`,
        credentials_validated: true,
        credentials_to_store: {
          nylas_api_key: credentials.nylas_api_key,
          nylas_grant_id: credentials.nylas_grant_id,
          email_address: emailAddress,
          provider: account.data.provider // gmail, outlook, etc
        },
        next_steps: [
          "Your email is now connected",
          "Try: 'find my unread emails' or 'summarize today's emails'"
        ]
      };
      
    } catch (error: any) {
      // Detailed error handling
      if (error.statusCode === 401) {
        return {
          type: "auth_error",
          message: "Invalid API key",
          suggestion: "Double-check your API key from the Nylas dashboard",
          retry_action: "setup_email_connection",
          retry_params: { action: "get_instructions" }
        };
      } else if (error.statusCode === 404) {
        return {
          type: "grant_error",
          message: "Grant ID not found",
          suggestion: "Make sure you completed the 'Add Test Grant' step",
          details: "The Grant ID should be from the same account as your API key"
        };
      } else {
        return {
          type: "connection_error",
          message: "Could not connect to Nylas",
          error_details: error.message,
          troubleshoot_action: "setup_email_connection",
          troubleshoot_params: { 
            action: "troubleshoot",
            issue: error.message 
          }
        };
      }
    }
  }
  
  private async testEmailConnection(userId: string): Promise<TestResponse> {
    // This would be called after Juli has stored the credentials
    try {
      // Fetch a few recent emails as a test
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: { limit: 5 }
      });
      
      return {
        type: "connection_test_success",
        message: "Email connection is working perfectly!",
        stats: {
          emails_accessible: true,
          recent_email_count: messages.data.length,
          oldest_email_date: messages.data[messages.data.length - 1]?.date
        },
        ready_to_use: true
      };
    } catch (error) {
      return {
        type: "connection_test_failed",
        message: "Connection test failed",
        error: error.message,
        suggestion: "Try re-validating your credentials"
      };
    }
  }
  
  private async troubleshootIssue(issue: string, userId: string): Promise<TroubleshootResponse> {
    // AI-powered troubleshooting
    const commonIssues = {
      "permission": {
        keywords: ["permission", "denied", "access"],
        solution: "Re-authorize your email in Nylas dashboard with all permissions enabled"
      },
      "grant_expired": {
        keywords: ["expired", "invalid grant"],
        solution: "Create a new test grant in Nylas dashboard - they expire after 30 days"
      },
      "rate_limit": {
        keywords: ["rate", "limit", "429"],
        solution: "You've hit the rate limit. Wait a few minutes and try again"
      }
    };
    
    // Find matching issue
    const matchedIssue = Object.entries(commonIssues).find(([key, data]) =>
      data.keywords.some(keyword => issue.toLowerCase().includes(keyword))
    );
    
    if (matchedIssue) {
      return {
        type: "troubleshoot_solution",
        identified_issue: matchedIssue[0],
        solution: matchedIssue[1].solution,
        steps_to_fix: this.getFixSteps(matchedIssue[0])
      };
    }
    
    // Generic troubleshooting
    return {
      type: "troubleshoot_generic",
      message: "Let's debug this together",
      diagnostic_steps: [
        "Verify your Nylas account is active",
        "Check if your API key is still valid",
        "Ensure your email grant hasn't expired",
        "Try creating a fresh test grant"
      ],
      contact_support: {
        juli_support: "support@juli.ai",
        nylas_docs: "https://developer.nylas.com/docs/v3/"
      }
    };
  }
}
```

### How Juli and MCP Work Together

#### 1. Initial Connection (No Credentials)
```typescript
// Juli attempts to connect to MCP
Juli ‚Üí MCP: Connect with userId="user123", credentials=undefined

// MCP detects missing credentials
MCP ‚Üí Juli: {
  type: "needs_configuration",
  service: "nylas_email",
  setup_required: true,
  tools_available: ["setup_email_connection"],
  message: "Email not connected. Run 'setup_email_connection' to begin."
}

// Juli shows this to user and suggests the setup tool
```

#### 2. During Setup
```typescript
// User runs setup tool
User ‚Üí Juli: "setup_email_connection"
Juli ‚Üí MCP: setup_email_connection({ action: "get_instructions" })

// MCP returns structured instructions
MCP ‚Üí Juli: {
  type: "setup_instructions",
  // Structured data that Juli renders beautifully
}

// User provides credentials
User ‚Üí Juli: [Enters credentials in Juli's UI]
Juli ‚Üí MCP: setup_email_connection({ 
  action: "validate_credentials",
  credentials: { nylas_api_key: "...", nylas_grant_id: "..." }
})

// MCP validates and returns result
MCP ‚Üí Juli: {
  type: "setup_success",
  credentials_validated: true,
  credentials_to_store: { ... } // Juli stores these securely
}
```

#### 3. Future Connections
```typescript
      // Juli provides stored credentials automatically (grant only)
      Juli ‚Üí MCP: Connect with userId="user123", headers={
        'X-User-Credential-NYLAS_GRANT_ID': 'grant_id'
      }

// MCP initializes normally
MCP: Ready to handle email operations
```

### Developer Experience Benefits

#### For MCP Developers:
- **No Credential Management**: Juli handles all storage/encryption
- **Simple Validation**: Just test if credentials work, return result
- **Structured Responses**: Return data, Juli handles presentation
- **Focus on Logic**: Write email functionality, not auth infrastructure

#### For End Users:
- **One-Time Setup**: Credentials stored securely by Juli
- **Beautiful UI**: Juli renders instructions with proper formatting
- **Integrated Experience**: Feels native to Juli, not bolted-on
- **Smart Recovery**: Clear error messages and troubleshooting

### MCP Implementation Simplicity

```typescript
class AIEmailAssistantMCP extends McpServer {
  private nylas?: Nylas;
  private grantId?: string;
  
  constructor() {
    super({ 
      name: "ai-email-assistant", 
      version: "2.0.0",
      description: "AI-powered email expert"
    });
  }
  
  // Called by Juli on each connection
  async initialize(context: MCPContext) {
    if (!context.credentials?.nylas_api_key) {
      // Just tell Juli setup is needed
      return { needs_setup: true };
    }
    
    // Initialize with provided credentials
    this.nylas = new Nylas({ 
      apiKey: context.credentials.nylas_api_key 
    });
    this.grantId = context.credentials.nylas_grant_id;
  }
  
  // Tools are only registered if credentials exist
  registerTools() {
    if (!this.nylas) {
      // Only setup tool available
      this.registerTool("setup_email_connection", this.handleSetup);
      return;
    }
    
    // All email tools available
    this.registerTool("manage_email", this.handleManageEmail);
    this.registerTool("find_emails", this.handleFindEmails);
    // ... other tools
  }
}
```

## The 5 Essential Tools (AI-First Design)

### 1. `manage_email`
**The Swiss Army Knife of Email Actions**

```typescript
{
  name: "manage_email",
  description: "Send, reply, forward, or draft emails using natural language. Handles all email composition intelligently.",
  parameters: {
    action: {
      type: "string",
      enum: ["send", "reply", "forward", "draft"],
      description: "What to do with the email"
    },
    query: {
      type: "string", 
      description: "Natural language description of what you want. Examples: 'reply to Sarah thanking her for the proposal', 'forward the AWS alerts to the dev team with a summary', 'draft a follow-up to yesterday's meeting attendees'"
    },
    context_message_id: {
      type: "string",
      optional: true,
      description: "ID of email being replied to or forwarded (AI will find it if not provided)"
    },
    require_approval: {
      type: "boolean",
      default: true,
      description: "Whether to require approval before sending"
    }
  }
}
```

**How it works**: 
- AI analyzes the query to understand intent
- Finds relevant emails if replying/forwarding
- Generates appropriate content with proper tone
- Returns approval request with preview
- Sends after approval

### 2. `find_emails`
**Intelligent Email Search & Analysis**

```typescript
{
  name: "find_emails",
  description: "Find and analyze emails using natural language. Returns summaries and insights.",
  parameters: {
    query: {
      type: "string",
      description: "What you're looking for. Examples: 'unread emails from my manager', 'invoices from last month', 'important emails I haven't responded to', 'emails about the Q3 project'"
    },
    analysis_type: {
      type: "string",
      enum: ["summary", "detailed", "action_items", "priority"],
      default: "summary",
      description: "How to analyze the found emails"
    },
    limit: {
      type: "integer",
      default: 20,
      description: "Maximum emails to analyze"
    }
  }
}
```

**AI Features**:
- Natural language date parsing ("last week", "yesterday")
- Importance detection using GPT-4
- Automatic categorization
- Thread grouping
- Action item extraction

### 3. `organize_inbox`
**Bulk Intelligent Email Management**

```typescript
{
  name: "organize_inbox",
  description: "Organize, clean up, or triage emails in bulk using AI-powered rules",
  parameters: {
    instruction: {
      type: "string",
      description: "What you want to do. Examples: 'archive all newsletters older than a week', 'star emails that need responses', 'move receipts to a folder', 'clean up promotional emails keeping only important ones'"
    },
    scope: {
      type: "object",
      properties: {
        folder: { type: "string", default: "inbox" },
        date_range: { type: "string", optional: true },
        limit: { type: "integer", default: 100 }
      }
    },
    dry_run: {
      type: "boolean",
      default: true,
      description: "Preview what would happen without making changes"
    }
  }
}
```

**AI Capabilities**:
- Understands complex organizational rules
- Identifies email patterns (newsletters, receipts, notifications)
- Smart importance scoring
- Bulk operations with safety checks

### 4. `email_insights`
**Intelligent Email Analytics & Insights**

```typescript
{
  name: "email_insights",
  description: "Get AI-powered insights about your email patterns, important items, and what needs attention",
  parameters: {
    insight_type: {
      type: "string",
      enum: ["daily_summary", "important_items", "response_needed", "analytics", "relationships"],
      description: "Type of insight to generate"
    },
    time_period: {
      type: "string",
      default: "today",
      description: "Time period to analyze (natural language like 'this week', 'last month')"
    },
    focus_area: {
      type: "string",
      optional: true,
      description: "Specific area to focus on (e.g., 'project X', 'client communications')"
    }
  }
}
```

**Insights Provided**:
- Daily summaries with priority items
- Response time analytics
- Communication patterns
- Important relationships
- Trending topics
- Workload analysis

### 5. `smart_folders`
**AI-Powered Dynamic Folder Management**

```typescript
{
  name: "smart_folders",
  description: "Create or manage intelligent folders that automatically organize emails based on AI understanding",
  parameters: {
    action: {
      type: "string",
      enum: ["create", "update", "apply", "list"],
      description: "Operation to perform"
    },
    rule: {
      type: "string",
      description: "Natural language rule. Examples: 'create a folder for urgent client emails', 'organize by project automatically', 'separate personal from work emails'"
    },
    folder_name: {
      type: "string",
      optional: true,
      description: "Name for the folder (AI suggests if not provided)"
    }
  }
}
```

**Smart Features**:
- AI understands intent and creates rules
- Dynamic categorization
- Auto-organization based on patterns
- Learns from user corrections

## Implementation Architecture

### Credential Flow (Hosted Auth)

```typescript
// MCP server receives credentials from Juli
interface MCPContext {
  userId: string;
  credentials?: { nylas_grant_id?: string };
}

class AIEmailAssistantMCP extends McpServer {
  private nylas?: Nylas;
  private emailAI: EmailAI;
  
  async initialize(context: MCPContext) {
    if (!process.env.NYLAS_API_KEY || !context.credentials?.nylas_grant_id) {
      return this.setupNeededResponse();
    }
    this.nylas = new Nylas({ apiKey: process.env.NYLAS_API_KEY });
    this.grantId = context.credentials.nylas_grant_id;
  }
  
  private setupNeededResponse() {
    return {
      type: "needs_configuration",
      connect_url: "/setup/connect-url",
      message: "Email not connected. Open connect_url to authenticate.",
      documentation_url: "/docs/email-setup"
    };
  }
}
```

### OpenAI Integration Layer

```typescript
class EmailAI {
  private openai: OpenAI;
  
  async understandQuery(query: string, context?: EmailContext): Promise<EmailIntent> {
    // Use GPT-4 to understand natural language email requests
    const response = await this.openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: `You are an email assistant. Analyze the user's request and extract:
          - Intent (send, reply, forward, find, organize)
          - Recipients (if applicable)
          - Key topics or context
          - Urgency level
          - Required email content points`
        },
        {
          role: "user",
          content: query
        }
      ],
      response_format: { type: "json_object" }
    });
    
    return JSON.parse(response.choices[0].message.content);
  }
  
  async generateEmailContent(intent: EmailIntent, context?: Email): Promise<GeneratedEmail> {
    // Generate professional email content based on intent
  }
  
  async analyzeImportance(emails: Email[]): Promise<ImportanceScore[]> {
    // Batch analyze emails for importance/priority
  }
}
```

## User Experience Examples

### Natural Conversations

**User**: "Reply to Sarah's email about the budget proposal thanking her and asking for more details on Q3 projections"

**AI Email Assistant**:
1. Finds Sarah's most recent email about budget
2. Generates a professional reply
3. Shows preview for approval
4. Sends after confirmation

**User**: "Find all important emails I haven't responded to this week"

**AI Email Assistant**:
1. Searches for emails from this week
2. Analyzes importance using AI
3. Filters for those without replies
4. Returns organized summary with action items

**User**: "Clean up my inbox but keep anything that looks important"

**AI Email Assistant**:
1. Analyzes all inbox emails
2. Scores importance using GPT-4
3. Shows cleanup plan (dry run)
4. Executes after approval

## Security & Privacy

### Data Protection
- Email content never stored by MCP server
- All processing in-memory only
- Credentials passed securely from Juli
- No logging of email content
- PII automatically masked in any logs

### Access Control
- Credentials scoped per user
- Automatic token refresh handled by Juli
- Rate limiting per operation
- Audit logging for actions (not content)

## Monitoring & Analytics

### Key Metrics
- Email processing latency
- AI response quality scores
- Approval/rejection rates
- User satisfaction metrics
- Error rates by operation type

### Observability
```typescript
interface EmailOperationTrace {
  operation_id: string;
  user_id: string;
  tool: string;
  ai_processing_time: number;
  nylas_api_time: number;
  total_time: number;
  approval_required: boolean;
  outcome: "success" | "failed" | "cancelled";
}
```

## Future Enhancements

1. **Voice Integration**: "Hey Juli, read me my important emails"
2. **Smart Scheduling**: AI-powered meeting scheduling via email
3. **Email Templates**: Learning from user's writing style
4. **Team Features**: Shared inboxes and delegation
5. **Advanced Analytics**: Communication insights and optimization

## Implementation Priorities

### Phase 1: Core Infrastructure (Week 1)
- Credential handling from Juli
- Basic tool registration
- OpenAI integration setup

### Phase 2: Essential Tools (Week 2)
- `manage_email` with approval flow
- `find_emails` with AI analysis
- `email_insights` basic implementation

### Phase 3: Advanced Features (Week 3)
- `organize_inbox` with safety checks
- `smart_folders` implementation
- Enhanced AI capabilities

### Phase 4: Polish & Testing (Week 4)
- Comprehensive testing
- Performance optimization
- User experience refinement

## Developer Experience Summary

### What You (MCP Developer) Are Responsible For:

1. **Core Functionality**
   - Email operations (send, search, organize)
   - AI integration for natural language understanding
   - Business logic and email intelligence

2. **Setup Assistance**
   - Providing clear setup instructions
   - Validating credentials work correctly
   - Helpful error messages for troubleshooting

3. **Approval Logic**
   - Deciding when approval is needed
   - Generating meaningful previews
   - Temporarily storing pending actions

4. **Graceful Handling**
   - Detecting missing credentials
   - Returning structured responses
   - Clear error states

### What Juli Handles For You:

1. **All Infrastructure**
   - Credential storage and encryption
   - User authentication and identity
   - Session management
   - Security and compliance

2. **User Interface**
   - Beautiful rendering of your responses
   - Forms for credential input
   - Approval dialogs
   - Error display

3. **Developer Quality of Life**
   - Automatic credential injection
   - Retry logic for failed calls
   - Rate limiting
   - Analytics and monitoring

### The Developer Journey:

```typescript
// 1. Simple MCP server setup
class EmailAssistant extends McpServer {
  name = "ai-email-assistant";
  
  // 2. Check for credentials
  initialize(context) {
    if (!context.credentials) {
      return { needs_setup: true };
    }
    // Initialize your service
  }
  
  // 3. Implement your tools
  async handleManageEmail(params) {
    // Your email logic here
    if (needsApproval) {
      return { 
        type: "approval_required",
        preview: generatedEmail 
      };
    }
    // Send email
  }
}

// That's it! Juli handles the rest.
```

### Why This Architecture?

**For Developers:**
- Focus on your domain expertise (email AI)
- No auth infrastructure to build
- Clear boundaries of responsibility
- Structured data exchange

**For Users:**
- Consistent experience across all Juli tools
- One-time setup per service
- Beautiful, integrated UI
- Seamless approvals

**For Juli:**
- Maintain security standards
- Provide consistent UX
- Enable rapid tool development
- Scale to many services

## Conclusion

This transformation creates a truly intelligent email assistant that:
- Understands natural language perfectly
- Handles approvals seamlessly
- Provides genuine AI-powered insights
- Integrates smoothly with Juli's credential management
- Feels like a natural extension of Juli's AI capabilities

The key is thinking "AI-first" - users should just say what they want naturally, and the system handles all complexity behind the scenes. As a developer, you focus on making the best email AI possible, while Juli handles all the platform concerns. This separation of concerns creates the best experience for everyone involved.
</file>

<file path="DOCKER_GUIDE.md">
# Docker Deployment Guide for Inbox MCP

This guide explains how to run Inbox MCP using Docker for easy deployment and scaling.

## Table of Contents
- [Prerequisites](#prerequisites)
- [Quick Start](#quick-start)
- [Building the Docker Image](#building-the-docker-image)
- [Running with Docker](#running-with-docker)
- [Using Docker Compose](#using-docker-compose)
- [Configuration](#configuration)
- [Production Deployment](#production-deployment)
- [Troubleshooting](#troubleshooting)

## Prerequisites

- Docker Engine 20.10+ installed
- Docker Compose 2.0+ (optional, for easier management)
- OpenAI API key

## Quick Start

1. Clone the repository:
```bash
git clone https://github.com/yourusername/inbox-mcp.git
cd inbox-mcp
```

2. Create a `.env` file:
```bash
cp .env.example .env
# Edit .env and add your OpenAI API key
```

3. Run with Docker Compose:
```bash
docker-compose up -d
```

The server will be available at `http://localhost:3000`

## Building the Docker Image

### Build locally:
```bash
docker build -t inbox-mcp:latest .
```

### Build with specific version tag:
```bash
docker build -t inbox-mcp:v1.0.0 .
```

### Multi-platform build (for ARM64 and AMD64):
```bash
docker buildx build --platform linux/amd64,linux/arm64 -t inbox-mcp:latest .
```

## Running with Docker

### Basic run:
```bash
docker run -d \
  --name inbox-mcp \
  -p 3000:3000 \
  -e OPENAI_API_KEY="your_openai_key_here" \
  inbox-mcp:latest
```

### Run with environment file:
```bash
docker run -d \
  --name inbox-mcp \
  -p 3000:3000 \
  --env-file .env \
  inbox-mcp:latest
```

### Run with custom port:
```bash
docker run -d \
  --name inbox-mcp \
  -p 8080:3000 \
  -e PORT=3000 \
  -e OPENAI_API_KEY="your_openai_key_here" \
  inbox-mcp:latest
```

### Run with volume for logs (if needed):
```bash
docker run -d \
  --name inbox-mcp \
  -p 3000:3000 \
  -v $(pwd)/logs:/app/logs \
  --env-file .env \
  inbox-mcp:latest
```

## Using Docker Compose

### Start the service:
```bash
docker-compose up -d
```

### View logs:
```bash
docker-compose logs -f
```

### Stop the service:
```bash
docker-compose down
```

### Rebuild and restart:
```bash
docker-compose up -d --build
```

### Scale the service (for load balancing):
```bash
docker-compose up -d --scale inbox-mcp=3
```

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `OPENAI_API_KEY` | Your OpenAI API key (required) | - |
| `PORT` | Port the server listens on | 3000 |
| `NODE_ENV` | Environment (development/production) | production |

### Docker Compose Configuration

The `docker-compose.yml` file includes:
- Automatic container restart
- Health checks
- Log rotation
- Resource limits (can be added)

### Adding Resource Limits

Update `docker-compose.yml` to add resource constraints:

```yaml
services:
  inbox-mcp:
    # ... other configuration ...
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
```

## Production Deployment

### 1. Use a Reverse Proxy

Add Nginx configuration for HTTPS and load balancing:

```nginx
upstream inbox_mcp {
    server inbox-mcp:3000;
}

server {
    listen 80;
    server_name api.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.yourdomain.com;
    
    ssl_certificate /etc/nginx/certs/cert.pem;
    ssl_certificate_key /etc/nginx/certs/key.pem;
    
    location / {
        proxy_pass http://inbox_mcp;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 2. Use Docker Secrets for API Keys

Instead of environment variables, use Docker secrets:

```bash
# Create secret
echo "your_openai_key" | docker secret create openai_api_key -

# Update docker-compose.yml
services:
  inbox-mcp:
    secrets:
      - openai_api_key
    environment:
      - OPENAI_API_KEY_FILE=/run/secrets/openai_api_key

secrets:
  openai_api_key:
    external: true
```

### 3. Enable Monitoring

Add Prometheus metrics endpoint or use Docker's built-in monitoring:

```bash
docker stats inbox-mcp
```

### 4. Set Up Logging

Configure centralized logging with ELK stack or CloudWatch:

```yaml
services:
  inbox-mcp:
    logging:
      driver: "awslogs"
      options:
        awslogs-group: "inbox-mcp"
        awslogs-region: "us-east-1"
        awslogs-stream-prefix: "server"
```

## Troubleshooting

### Check container status:
```bash
docker ps -a | grep inbox-mcp
```

### View container logs:
```bash
docker logs inbox-mcp
```

### Access container shell:
```bash
docker exec -it inbox-mcp sh
```

### Test health endpoint:
```bash
curl http://localhost:3000/health
```

### Common Issues

1. **Container exits immediately**
   - Check logs: `docker logs inbox-mcp`
   - Verify environment variables are set correctly
   - Ensure OpenAI API key is valid

2. **Cannot connect to server**
   - Verify port mapping: `docker port inbox-mcp`
   - Check firewall rules
   - Ensure container is running: `docker ps`

3. **Permission denied errors**
   - The container runs as non-root user (nodejs)
   - Ensure mounted volumes have correct permissions

4. **High memory usage**
   - Add resource limits in docker-compose.yml
   - Monitor with `docker stats`

### Debugging Build Issues

```bash
# Build with no cache
docker build --no-cache -t inbox-mcp:latest .

# Build with verbose output
docker build --progress=plain -t inbox-mcp:latest .

# Check image layers
docker history inbox-mcp:latest
```

## Security Best Practices

1. **Run as non-root user** (already configured)
2. **Use secrets management** for sensitive data
3. **Enable security scanning**:
   ```bash
   docker scan inbox-mcp:latest
   ```
4. **Keep base images updated**:
   ```bash
   docker pull node:20-alpine
   docker build --pull -t inbox-mcp:latest .
   ```
5. **Use read-only filesystem** where possible:
   ```yaml
   services:
     inbox-mcp:
       read_only: true
       tmpfs:
         - /tmp
   ```

## Backup and Recovery

### Backup configuration:
```bash
# Backup environment configuration
cp .env .env.backup

# Export container configuration
docker inspect inbox-mcp > inbox-mcp-config.json
```

### Restore from backup:
```bash
# Restore environment
cp .env.backup .env

# Recreate container with same configuration
docker-compose up -d
```

## Integration with CI/CD

### GitHub Actions example:
```yaml
name: Build and Push Docker Image

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: yourusername/inbox-mcp:latest
          platforms: linux/amd64,linux/arm64
```

## Performance Optimization

1. **Use multi-stage builds** (already implemented)
2. **Enable BuildKit** for faster builds:
   ```bash
   DOCKER_BUILDKIT=1 docker build -t inbox-mcp:latest .
   ```
3. **Cache npm dependencies** (already optimized in Dockerfile)
4. **Use Alpine Linux** for smaller image size (already used)

## Monitoring and Observability

### Add health check endpoint monitoring:
```bash
# Simple monitoring script
while true; do
  if ! curl -f http://localhost:3000/health > /dev/null 2>&1; then
    echo "Health check failed at $(date)"
    # Send alert or restart container
  fi
  sleep 30
done
```

### Container metrics:
```bash
# Real-time stats
docker stats inbox-mcp

# Export metrics to file
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" > metrics.txt
```

## Conclusion

Docker provides a consistent and scalable way to deploy Inbox MCP. This guide covers basic usage through production deployment strategies. For additional help, refer to the main README or open an issue on GitHub.
</file>

<file path="MCP_DEVELOPER_GUIDE.md">
# MCP Developer Guide for Juli Platform

A comprehensive guide to building Model Context Protocol (MCP) servers for Juli - the AI platform used by thousands of users worldwide.

## Table of Contents
- [Overview](#overview)
- [Juli Authentication System](#juli-authentication-system)
- [MCP Protocol Specification](#mcp-protocol-specification)
- [Building Your MCP Server](#building-your-mcp-server)
- [Tool Design Best Practices](#tool-design-best-practices)
- [Testing and Deployment](#testing-and-deployment)

## Overview

### What is Juli?

Juli is an AI platform that orchestrates multiple AI models and tools to help users accomplish complex tasks. MCP servers extend Juli's capabilities by providing specialized tools that integrate with external services.

### What is MCP?

Model Context Protocol (MCP) is a standardized way for AI systems to interact with external tools and services. It defines:
- How tools are discovered and described
- How requests and responses are formatted
- How authentication and context are handled
- How approvals and safety checks work

### Why Build for Juli?

- **Reach thousands of users** - Juli's growing user base needs quality tools
- **Monetization** - Premium MCP servers can generate revenue
- **Simple integration** - Juli handles all the complex infrastructure
- **Focus on your expertise** - Build tools in domains you know best

## Juli Authentication System

### How Juli Handles Credentials

Juli implements a secure, user-friendly authentication system that makes using MCP servers seamless:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
‚îÇ   Juli Client   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Juli Platform  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   MCP Server    ‚îÇ
‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                       ‚îÇ                         ‚îÇ
        ‚îÇ                       ‚îÇ                         ‚îÇ
    User provides           Stores & manages         Receives creds
    credentials once        credentials              per request
```

### Setup Flow (Hosted Auth)

Important: Users authenticate via Nylas Hosted Auth. The server keeps `NYLAS_API_KEY` in env and returns a `grant_id`. MCP servers are stateless and never store per-user credentials.

When a user first installs your MCP:

```typescript
// 1) Juli checks if setup is needed
GET /mcp/needs-setup
Response: { "needs_setup": true, "connect_url": "/setup/connect-url" }

// 2) Juli fetches the Hosted Auth URL
GET /setup/connect-url?redirect_uri=https://yourapp.com/api/nylas-email/callback
Response: { "url": "https://api.us.nylas.com/v3/connect/auth?..." }

// 3) User completes provider login; callback returns the grant
GET /api/nylas-email/callback?code=...
Response: { "success": true, "grant_id": "...", "email": "user@example.com" }

// 4) Juli stores only the grant_id
// 5) Every future request includes:
Headers: { "X-User-Credential-NYLAS_GRANT_ID": "..." }
```

### Agent-to-Agent (A2A)

For inter-agent integrations, use JSON‚ÄëRPC A2A:

- Discovery: `GET /.well-known/a2a.json` (Agent Card)
- RPC endpoint: `POST /a2a/rpc` (JSON‚ÄëRPC 2.0)
- Methods:
  - `agent.card` ‚Üí Agent Card
  - `agent.handshake` ‚Üí `{ agent, card, server_time }`
  - `tool.execute` ‚Üí params `{ tool, arguments, user_context, request_id }`
  - `tool.approve` ‚Üí params `{ tool, original_arguments, action_data, user_context, request_id }`

Auth:
- Use the Agent Card `auth` scheme(s). OIDC ID token in `Authorization: Bearer <id_token>` (audience per card). Dev: optional `X-A2A-Dev-Secret`.

The server remains stateless; only `NYLAS_API_KEY` is in env. User grant is injected per-request.

### Credential acquisition (optional manifest)

Agents may publish `GET /.well-known/a2a-credentials.json` describing how Brain can obtain credentials it must inject. Example:

```json
{
  "credentials": [
    {
      "key": "EMAIL_ACCOUNT_GRANT",
      "display_name": "Email Account Grant",
      "sensitive": true,
      "flows": [
        {
          "type": "hosted_auth",
          "connect_url": "/setup/connect-url",
          "callback": "/api/nylas-email/callback",
          "provider_scopes": {
            "google": [
              "openid",
              "https://www.googleapis.com/auth/userinfo.email",
              "https://www.googleapis.com/auth/userinfo.profile",
              "https://www.googleapis.com/auth/gmail.modify",
              "https://www.googleapis.com/auth/contacts",
              "https://www.googleapis.com/auth/contacts.readonly",
              "https://www.googleapis.com/auth/contacts.other.readonly"
            ],
            "microsoft": ["Mail.ReadWrite","Mail.Send","Contacts.Read","Contacts.Read.Shared"]
          }
        }
      ]
    }
  ]
}
```

### Request Format

All tool execution requests follow this format:

```typescript
POST /mcp/tools/{toolName}
Headers: {
  "Content-Type": "application/json",
  "X-Request-ID": "unique-request-id",
  "X-User-ID": "juli-user-id",
  "X-User-Credential-NYLAS_GRANT_ID": "uuid"
}
Body: {
  // Tool-specific parameters
  "param1": "value1",
  "param2": "value2"
}
```

### Response Format

#### Success Response
```typescript
{
  "success": true,
  "data": {}
}
```

#### Error Response
```typescript
{
  "error": "User-friendly error message",
  "error_code": "RATE_LIMIT_EXCEEDED"
}
```

#### Needs Setup Response
```typescript
{
  "needs_setup": true,
  "message": "Please complete setup to use this tool",
  "connect_url": "/setup/connect-url"
}
```

### Tool Discovery Format

```typescript
GET /mcp/tools
Response: {
  "tools": [
    {
      "name": "tool_name",
      "description": "Clear description of what this tool does",
      "inputSchema": {
        "type": "object",
        "properties": {
          "param1": {
            "type": "string",
            "description": "What this parameter does"
          },
          "param2": {
            "type": "number",
            "description": "Another parameter",
            "minimum": 0,
            "maximum": 100
          }
        },
        "required": ["param1"]
      }
    }
  ]
}
```

### Context Injection

Juli can automatically inject user context into tool calls:

```typescript
// In your tool schema
"inputSchema": {
  "type": "object",
  "properties": {
    "message": {
      "type": "string",
      "description": "Message to send"
    },
    "user_name": {
      "type": "string",
      "description": "User's name",
      "x-context-injection": "user_name"  // Juli auto-fills
    },
    "user_timezone": {
      "type": "string",
      "description": "User's timezone",
      "x-context-injection": "user_timezone"
    }
  }
}
```

Available context fields:
- `user_name` - User's display name
- `user_email` - User's email address
- `user_timezone` - User's timezone (e.g., "America/New_York")
- `current_date` - Current date in user's timezone
- `current_time` - Current time in user's timezone

## Building Your MCP Server

### Critical Design Principle: Stateless Credential Handling

MCP servers are stateless regarding user credentials. Extract credentials from headers per request and never store them.

```typescript
function handleRequest(req) {
  const credentials = extractCredentials(req.headers);
  const client = new ServiceClient(process.env.NYLAS_API_KEY);
  return client.doWork(credentials.nylas_grant_id);
}
```

**Why Stateless?**
- **Security**: No credential leaks if server is compromised
- **Scalability**: Servers can be scaled horizontally without session affinity
- **Reliability**: Server restarts don't affect users
- **Multi-tenancy**: One server instance serves all users safely

### Server Architecture

```typescript
import express from 'express';
import { z } from 'zod';

class MCPServer {
  private app: express.Application;
  private tools: Map<string, Tool>;
  
  constructor() {
    this.app = express();
    this.tools = new Map();
    this.setupMiddleware();
    this.setupRoutes();
  }
  
  private setupMiddleware() {
    this.app.use(express.json());
    this.app.use(this.logRequests);
    this.app.use(this.extractCredentials);
  }
  
  private extractCredentials(req, res, next) {
    req.credentials = {};
    
    // Extract all X-User-Credential-* headers
    Object.keys(req.headers).forEach(header => {
      if (header.startsWith('x-user-credential-')) {
        const credName = header.replace('x-user-credential-', '');
        req.credentials[credName] = req.headers[header];
      }
    });
    
    next();
  }
  
  private setupRoutes() {
    this.app.get('/health', (req, res) => {
      res.json({ status: 'healthy', version: '1.0.0' });
    });
    
    this.app.get('/mcp/needs-setup', (req, res) => {
      const needsSetup = !this.hasRequiredCredentials(req.credentials);
      res.json({
        needs_setup: needsSetup,
        auth_type: 'api_key',
        service_name: 'Your Service',
        setup_tool: 'setup_service'
      });
    });
    
    this.app.get('/mcp/tools', (req, res) => {
      const tools = Array.from(this.tools.values()).map(tool => ({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.getSchema()
      }));
      res.json({ tools });
    });
    
    this.app.post('/mcp/tools/:toolName', async (req, res) => {
      try {
        const { toolName } = req.params;
        const tool = this.tools.get(toolName);
        
        if (!tool) {
          return res.status(404).json({
            error: `Tool '${toolName}' not found`
          });
        }
        
        // Check credentials
        if (!this.hasRequiredCredentials(req.credentials)) {
          return res.json({
            needs_setup: true,
            message: 'Please complete setup first',
            setup_tool: 'setup_service'
          });
        }
        
        // Validate input
        const validatedInput = tool.validateInput(req.body);
        
        // Execute tool
        const result = await tool.execute(validatedInput, req.credentials);
        
        res.json(result);
      } catch (error) {
        console.error(`Error in tool ${req.params.toolName}:`, error);
        res.status(500).json({
          error: 'An error occurred processing your request',
          error_code: 'INTERNAL_ERROR'
        });
      }
    });
  }
}
```

### Tool Implementation Pattern

```typescript
abstract class Tool {
  constructor(
    public name: string,
    public description: string
  ) {}
  
  abstract getSchema(): object;
  abstract validateInput(input: any): any;
  abstract execute(input: any, credentials: any): Promise<any>;
}

class ExampleTool extends Tool {
  constructor() {
    super(
      'example_tool',
      'Does something useful with natural language'
    );
  }
  
  getSchema() {
    return {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Natural language description of what you want'
        },
        options: {
          type: 'object',
          properties: {
            include_details: {
              type: 'boolean',
              default: false
            }
          }
        }
      },
      required: ['query']
    };
  }
  
  validateInput(input: any) {
    // Use zod or another validator
    const schema = z.object({
      query: z.string().min(1),
      options: z.object({
        include_details: z.boolean().optional()
      }).optional()
    });
    
    return schema.parse(input);
  }
  
  async execute(input: any, credentials: any) {
    // Create service client with credentials
    const client = new YourServiceClient({
      apiKey: credentials.api_key
    });
    
    try {
      // Process natural language
      const intent = await this.understandQuery(input.query);
      
      // Execute action
      const result = await client.doSomething(intent);
      
      return {
        success: true,
        data: result
      };
    } catch (error) {
      if (error.code === 'RATE_LIMIT') {
        return {
          error: 'Rate limit exceeded. Please try again later.',
          error_code: 'RATE_LIMIT_EXCEEDED',
          details: {
            retry_after: 60
          }
        };
      }
      throw error;
    }
  }
}
```

### Stateless Design Principles

1. **No Session State**
   ```typescript
   // ‚ùå Bad: Storing user state
   const userSessions = new Map();
   
   // ‚úÖ Good: Everything in request
   function handleRequest(req) {
     const credentials = req.credentials;
     const client = createClient(credentials);
     return client.doWork();
   }
   ```

2. **Request-Scoped Clients**
   ```typescript
   // ‚ùå Bad: Global client
   const client = new ServiceClient(process.env.API_KEY);
   
   // ‚úÖ Good: Per-request client
   function handleRequest(req) {
     const client = new ServiceClient(req.credentials.api_key);
     return client.doWork();
   }
   ```

3. **Horizontal Scaling Ready**
   ```typescript
   // Your server should work with multiple instances
   // No in-memory caches for user data
   // No local file storage for user content
   // Use external services for persistence if needed
   ```

## Tool Design Best Practices

### 1. Natural Language First

```typescript
// ‚ùå Bad: Technical parameters
{
  name: "execute_query",
  parameters: {
    sql: "SELECT * FROM users WHERE...",
    database: "production",
    timeout: 30000
  }
}

// ‚úÖ Good: Natural language
{
  name: "find_data",
  parameters: {
    query: "Show me active users from last week",
    include_details: true
  }
}
```

### 2. Progressive Disclosure

```typescript
// Start simple
{
  name: "analyze_data",
  parameters: {
    query: "What are my top selling products?"
  }
}

// Allow advanced options
{
  name: "analyze_data",
  parameters: {
    query: "What are my top selling products?",
    options: {
      time_range: "last_quarter",
      group_by: "category",
      include_trends: true
    }
  }
}
```

### 3. Clear Descriptions

```typescript
{
  name: "manage_email",
  description: "Send, reply, forward, or draft emails using natural language. Handles all email composition intelligently.",
  inputSchema: {
    type: "object",
    properties: {
      action: {
        type: "string",
        enum: ["send", "reply", "forward", "draft"],
        description: "What to do with the email"
      },
      query: {
        type: "string",
        description: "Natural language description. Examples: 'reply to Sarah thanking her for the proposal', 'forward the AWS alerts to the dev team with a summary'"
      }
    }
  }
}
```

### 4. Error Messages Users Understand

```typescript
// ‚ùå Bad: Technical errors
{
  error: "Connection timeout: ETIMEDOUT 192.168.1.1:5432"
}

// ‚úÖ Good: User-friendly errors
{
  error: "Unable to connect to your database. Please check if your database is online and accessible.",
  error_code: "DATABASE_UNAVAILABLE",
  details: {
    suggestion: "Try again in a few moments or contact your database administrator"
  }
}
```

### 5. Approval Flow for Sensitive Actions

```typescript
async function deleteData(params, credentials) {
  // Calculate impact
  const itemsToDelete = await findItems(params.filter);
  
  // Request approval for large deletions
  if (itemsToDelete.length > 10) {
    return {
      needs_approval: true,
      action_type: 'bulk_delete',
      action_data: {
        filter: params.filter,
        ids: itemsToDelete.map(i => i.id)
      },
      preview: {
        summary: `Delete ${itemsToDelete.length} items`,
        details: {
          oldest_item: itemsToDelete[0].created_at,
          newest_item: itemsToDelete[itemsToDelete.length - 1].created_at
        },
        risks: ['This action cannot be undone']
      }
    };
  }
  
  // Execute for small deletions
  await performDelete(itemsToDelete);
  return {
    success: true,
    message: `Deleted ${itemsToDelete.length} items`
  };
}
```

## Testing and Deployment

### Testing Your MCP

```typescript
// Test the full flow
describe('MCP Server', () => {
  it('should handle the complete setup flow', async () => {
    // 1. Check needs setup
    const needsSetup = await fetch('/mcp/needs-setup');
    expect(needsSetup.body.needs_setup).toBe(true);
    
    // 2. Get instructions
    const instructions = await fetch('/setup/instructions');
    expect(instructions.body.steps).toHaveLength(3);
    
    // 3. Validate credentials
    const validation = await fetch('/setup/validate', {
      method: 'POST',
      body: {
        nylas_api_key: 'env_server_key',
        nylas_grant_id: 'user_grant_id'
      }
    });
    expect(validation.body.valid).toBe(true);
  });
  
  it('should execute tools with credentials', async () => {
    const response = await fetch('/mcp/tools/my_tool', {
      method: 'POST',
      headers: {
        'X-User-Credential-API_KEY': 'test-key'
      },
      body: {
        query: 'test query'
      }
    });
    
    expect(response.body.success).toBe(true);
  });
});
```

### Docker Deployment

```dockerfile
# Multi-stage build for efficiency
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production image
FROM node:20-alpine
RUN apk add --no-cache tini
WORKDIR /app

# Copy only production dependencies
COPY package*.json ./
RUN npm ci --production && npm cache clean --force

# Copy built app
COPY --from=builder /app/dist ./dist

# Run as non-root
USER node

# Use tini for proper signal handling
ENTRYPOINT ["/sbin/tini", "--"]
CMD ["node", "dist/server.js"]

EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"
```

### Production Checklist

- [ ] Comprehensive error handling
- [ ] Rate limiting implementation
- [ ] Request validation
- [ ] Secure credential handling
- [ ] Health check endpoint
- [ ] Structured logging
- [ ] Monitoring and metrics
- [ ] Graceful shutdown
- [ ] Documentation complete
- [ ] Security review passed

## Publishing to Juli

### Requirements

1. **Functional Requirements**
   - All tools must have clear descriptions
   - Natural language processing required
   - Proper error handling
   - Setup flow must be user-friendly

2. **Technical Requirements**
   - HTTP-only server (no WebSocket)
   - Stateless operation
   - Docker support recommended
   - Health check endpoint required

3. **Documentation Requirements**
   - README with clear examples
   - API documentation
   - Setup instructions
   - Troubleshooting guide

### Submission Process

1. Test thoroughly with multiple accounts
3. Submit via Juli Developer Portal
4. Respond to review feedback
5. Launch to thousands of users!

## Common Patterns

### Multi-Service Integration
```typescript
// When your MCP needs multiple API keys
headers: {
  'X-User-Credential-OPENAI_KEY': 'sk-...',
  'X-User-Credential-SERVICE_KEY': 'svc_...',
  'X-User-Credential-WORKSPACE': 'ws_123'
}
```

### Webhook Support
```typescript
// Register webhooks with callback URL
const callbackUrl = `https://juli-webhooks.com/mcp/${req.userId}/${toolName}`;
await client.registerWebhook(callbackUrl);
```

### Batch Operations
```typescript
// Process multiple items efficiently
{
  name: "bulk_process",
  parameters: {
    items: ["item1", "item2", "item3"],
    operation: "analyze"
  }
}
```

## Conclusion

Building MCP servers for Juli opens your tools to thousands of users who need specialized capabilities. Focus on:

1. **User Experience** - Natural language, clear errors, smooth setup
2. **Reliability** - Proper error handling, stateless design, monitoring
3. **Security** - Never store credentials, validate all input
4. **Performance** - Efficient operations, proper timeouts, scaling ready

Your MCP server will help Juli users be more productive and accomplish amazing things. Welcome to the Juli developer community!

## Resources

- [MCP Protocol Specification](https://modelcontextprotocol.io)
- [Juli Developer Portal](https://juli-ai.com/developers)
- [Support](ignacio@juli-ai.com)
</file>

<file path="TOOLS_DOCUMENTATION.md">
# Inbox MCP Tools Documentation

Comprehensive documentation for all tools available in the Inbox MCP server, including the setup endpoint.

## Table of Contents
- [Authentication & Credentials](#authentication--credentials)
- [Setup Tool](#setup-tool)
- [manage_email](#manage_email)
- [find_emails](#find_emails)
- [organize_inbox](#organize_inbox)
- [email_insights](#email_insights)
- [smart_folders](#smart_folders)

---

## Authentication & Credentials

**Critical Information**: This MCP server is **stateless** and **never stores user credentials**.

### How Credentials Work

1. **Hosted Auth**: Users authenticate via Nylas Hosted Auth; server keeps API key in env
2. **Storage**: Juli securely stores only the user's `grant_id`
3. **Runtime**: For MCP, send `X-User-Credential-NYLAS_GRANT_ID`. For A2A, include `EMAIL_ACCOUNT_GRANT` (preferred) or `NYLAS_GRANT_ID` in `user_context.credentials`.

### Required Headers for All Tools (MCP)

Every request to email tools must include this header:

```http
X-User-Credential-NYLAS_GRANT_ID: your_grant_id_here
```

### A2A (JSON‚ÄëRPC)

- Discovery: `GET /.well-known/a2a.json` ‚Üí Agent Card
- Credentials: `GET /.well-known/a2a-credentials.json`
- RPC: `POST /a2a/rpc` with methods `agent.card`, `agent.handshake`, `tool.execute`, `tool.approve`

Auth:
- Production: `Authorization: Bearer <OIDC_ID_TOKEN>` (audience from Agent Card)
- Dev: `X-A2A-Dev-Secret: <secret>` when enabled

### What Happens Without Credentials

If credentials are missing from headers, all email tools will return:

```json
{
  "error": "Missing Nylas credentials. Please connect your email account first."
}
```

---

## Connect your email (Hosted Auth)

Hosted Auth keeps the Nylas API key on the server and returns a per-user `grant_id`.

### 1) Detect if setup is needed

Request:
```bash
curl -s https://juli-ai.com/mcp/needs-setup
```

Response when not connected:
```json
{
  "needs_setup": true,
  "has_credentials": false,
  "setup_url": "/setup/instructions",
  "connect_url": "/setup/connect-url"
}
```

### 2) Get the Hosted Auth URL

Request (prod):
```bash
curl -s "https://juli-ai.com/setup/connect-url?redirect_uri=https%3A%2F%2Fjuli-ai.com%2Fapi%2Fnylas-email%2Fcallback&scope=openid,https://www.googleapis.com/auth/userinfo.email,https://www.googleapis.com/auth/userinfo.profile,https://www.googleapis.com/auth/gmail.modify,https://www.googleapis.com/auth/calendar&prompt=detect,select_provider"
```

Response:
```json
{ "url": "https://api.us.nylas.com/v3/connect/auth?..." }
```

Open the `url` in a browser to complete provider login.

### 3) Callback returns your grant

After login, the server responds at the callback with:
```json
{ "success": true, "grant_id": "86a3c08f-...", "email": "user@example.com" }
```

### 4) Use the tools

Send the header on every request:
```http
X-User-Credential-NYLAS_GRANT_ID: <grant_id>
```

---

## manage_email

Send, reply, forward, or draft emails using natural language. The AI understands context and handles email composition intelligently.

### Parameters

```typescript
{
  action: "send" | "reply" | "forward" | "draft",
  query: string,                    // Natural language description
  context_message_id?: string,      // For replies/forwards
  require_approval?: boolean,       // Default: true
  
  // Context injection (auto-filled by Juli)
  user_name?: string,
  user_email?: string
}
```

### Examples

#### Send New Email
**Request**:
```json
{
  "action": "send",
  "query": "Email Sarah about postponing tomorrow's meeting to Friday at 2pm"
}
```

**Response** (Needs Approval):
```json
{
  "needs_approval": true,
  "action_type": "send_email",
  "action_data": {
    "email_content": {
      "to": ["sarah.johnson@company.com"],
      "subject": "Meeting Reschedule - Moving to Friday",
      "body": "Hi Sarah,\n\nI hope this email finds you well. I wanted to reach out about tomorrow's meeting.\n\nWould it be possible to reschedule our meeting to Friday at 2pm instead? Something urgent has come up that requires my attention tomorrow.\n\nPlease let me know if Friday at 2pm works for your schedule.\n\nBest regards,\nJohn"
    }
  },
  "preview": {
    "summary": "Send email to sarah.johnson@company.com",
    "details": {
      "recipient": "Sarah Johnson",
      "subject": "Meeting Reschedule - Moving to Friday",
      "word_count": 67
    }
  }
}
```

#### Reply to Email
**Request**:
```json
{
  "action": "reply",
  "query": "Thank her for the proposal and ask for clarification on the timeline",
  "context_message_id": "msg_abc123"
}
```

**Response**:
```json
{
  "needs_approval": true,
  "action_type": "send_email",
  "action_data": {
    "email_content": {
      "to": ["sender@example.com"],
      "subject": "Re: Project Proposal",
      "body": "Hi Jane,\n\nThank you for sending over the proposal. I've had a chance to review it and I'm impressed with the comprehensive approach.\n\nCould you please provide some clarification on the timeline? Specifically, I'd like to understand the key milestones and deliverable dates.\n\nLooking forward to your response.\n\nBest regards,\nJohn",
      "reply_to_message_id": "msg_abc123"
    }
  },
  "preview": {
    "summary": "Reply to Jane about Project Proposal",
    "details": {
      "in_reply_to": "Project Proposal",
      "thread_length": 3
    }
  }
}
```

#### Forward Email
**Request**:
```json
{
  "action": "forward",
  "query": "Forward this to the dev team with a note about prioritizing the security issues",
  "context_message_id": "msg_xyz789"
}
```

#### Draft Email
**Request**:
```json
{
  "action": "draft",
  "query": "Draft a follow-up email to all attendees from yesterday's meeting with action items"
}
```

**Response**:
```json
{
  "success": true,
  "draft_id": "draft_123",
  "message": "Draft saved successfully",
  "draft_preview": {
    "subject": "Follow-up: Yesterday's Meeting - Action Items",
    "recipients": ["attendee1@company.com", "attendee2@company.com"]
  }
}
```

---

## find_emails

Search and analyze emails using natural language queries. Returns intelligent summaries and insights.

### Parameters

```typescript
{
  query: string,                              // Natural language search
  analysis_type?: "summary" | "detailed" | "action_items" | "priority",
  limit?: number,                             // Max emails to analyze (default: 20)
  include_spam?: boolean,                     // Include spam folder (default: false)
  
  // Context injection
  user_timezone?: string
}
```

### Examples

#### Find Unread Important Emails
**Request**:
```json
{
  "query": "important unread emails from this week",
  "analysis_type": "priority"
}
```

**Response**:
```json
{
  "success": true,
  "total_found": 12,
  "analysis": {
    "high_priority": [
      {
        "id": "msg_123",
        "from": "boss@company.com",
        "subject": "Urgent: Budget Review Needed",
        "received": "2024-01-24T10:30:00Z",
        "importance_score": 0.95,
        "why_important": "From direct manager, marked urgent, mentions deadline"
      }
    ],
    "medium_priority": [
      {
        "id": "msg_456",
        "from": "client@example.com",
        "subject": "Re: Project Timeline",
        "importance_score": 0.75,
        "why_important": "Client response, ongoing project discussion"
      }
    ],
    "summary": "You have 3 high-priority emails requiring immediate attention"
  }
}
```

#### Find Emails with Action Items
**Request**:
```json
{
  "query": "emails that need my response",
  "analysis_type": "action_items"
}
```

**Response**:
```json
{
  "success": true,
  "total_found": 8,
  "action_items": [
    {
      "email_id": "msg_789",
      "from": "colleague@company.com",
      "subject": "Review needed: Q4 Report",
      "action_required": "Review and provide feedback on Q4 report",
      "deadline": "2024-01-26",
      "extracted_from": "Could you please review the attached Q4 report and provide your feedback by Friday?"
    }
  ]
}
```

#### Search with Natural Dates
**Request**:
```json
{
  "query": "invoices from last month",
  "analysis_type": "summary"
}
```

---

## organize_inbox

Perform bulk operations on emails using intelligent rules and natural language instructions.

### Parameters

```typescript
{
  instruction: string,                    // What to do
  scope?: {
    folder?: string,                      // Which folder (default: "inbox")
    date_range?: string,                  // Natural language date range
    limit?: number                        // Max emails to process
  },
  dry_run?: boolean,                      // Preview without executing (default: true)
  confirmed?: boolean                     // Execute the operation
}
```

### Examples

#### Archive Old Emails
**Request**:
```json
{
  "instruction": "Archive all emails older than 30 days except starred ones",
  "scope": {
    "folder": "inbox"
  },
  "dry_run": true
}
```

**Response** (Dry Run):
```json
{
  "preview": true,
  "operation": "archive",
  "would_affect": {
    "total": 156,
    "breakdown": {
      "newsletters": 89,
      "notifications": 45,
      "conversations": 22
    },
    "excluded": {
      "starred": 5,
      "important": 3
    }
  },
  "sample_emails": [
    {
      "subject": "Your Weekly Newsletter",
      "from": "newsletter@example.com",
      "date": "2023-12-15"
    }
  ],
  "to_execute": "Set 'confirmed': true to execute"
}
```

#### Clean Up Newsletters
**Request**:
```json
{
  "instruction": "Move all unread newsletters to a Newsletter folder",
  "confirmed": true
}
```

**Response**:
```json
{
  "success": true,
  "operation": "move",
  "processed": 34,
  "details": {
    "moved_to": "Newsletter",
    "folder_created": true,
    "time_saved": "Approximately 15 minutes of manual sorting"
  }
}
```

#### Smart Filtering
**Request**:
```json
{
  "instruction": "Delete promotional emails keeping only those from services I actually use",
  "dry_run": true
}
```

The AI will intelligently identify which services you use based on your email history.

---

## email_insights

Get AI-powered insights and analytics about your email patterns and important items.

### Parameters

```typescript
{
  insight_type: "daily_summary" | "important_items" | "response_needed" | 
                "analytics" | "relationships",
  time_period?: string,                   // Natural language (default: "today")
  focus_area?: string,                    // Specific topic/project/person
  
  // Context injection
  user_timezone?: string,
  current_date?: string
}
```

### Examples

#### Daily Summary
**Request**:
```json
{
  "insight_type": "daily_summary",
  "time_period": "today"
}
```

**Response**:
```json
{
  "success": true,
  "summary": {
    "date": "2024-01-24",
    "new_emails": 47,
    "important_count": 5,
    "urgent_items": [
      {
        "from": "manager@company.com",
        "subject": "Budget approval needed today",
        "action": "Requires approval by EOD"
      }
    ],
    "meetings_mentioned": [
      "Product Review - Tomorrow 2pm",
      "Client Call - Friday 10am"
    ],
    "key_topics": ["Q4 Report", "Budget Review", "Project Alpha"],
    "response_needed": 3,
    "can_archive": 31
  },
  "recommendation": "Focus on the budget approval first, then address the 3 emails needing responses"
}
```

#### Relationship Insights
**Request**:
```json
{
  "insight_type": "relationships",
  "time_period": "last month"
}
```

**Response**:
```json
{
  "success": true,
  "top_correspondents": [
    {
      "email": "sarah@company.com",
      "name": "Sarah Johnson",
      "interaction_count": 45,
      "your_average_response_time": "2.5 hours",
      "their_average_response_time": "1.2 hours",
      "topics": ["Project Alpha", "Budget Planning"],
      "relationship_type": "frequent_collaborator"
    }
  ],
  "communication_patterns": {
    "busiest_day": "Tuesday",
    "peak_hours": "9am-11am",
    "average_daily_emails": 67
  }
}
```

#### Response Analytics
**Request**:
```json
{
  "insight_type": "response_needed",
  "focus_area": "Project Alpha"
}
```

---

## smart_folders

Create and manage intelligent folders that automatically organize emails based on AI understanding.

### Parameters

```typescript
{
  action: "create" | "update" | "apply" | "list",
  rule?: string,                          // Natural language rule
  folder_name?: string,                   // Folder name (AI suggests if not provided)
  options?: {
    auto_apply?: boolean,                 // Apply to existing emails
    ongoing?: boolean                     // Apply to future emails
  }
}
```

### Examples

#### Create Smart Folder
**Request**:
```json
{
  "action": "create",
  "rule": "Important client emails that mention contracts or proposals",
  "folder_name": "Client Contracts"
}
```

**Response**:
```json
{
  "success": true,
  "folder_created": "Client Contracts",
  "rule_interpretation": {
    "conditions": [
      "From domain in known client list",
      "Contains keywords: contract, proposal, agreement, SOW",
      "Importance score > 0.7"
    ]
  },
  "would_match": 23,
  "sample_matches": [
    "Contract renewal - Acme Corp",
    "Proposal for Q1 Services"
  ]
}
```

#### Apply Smart Folder
**Request**:
```json
{
  "action": "apply",
  "folder_name": "Client Contracts",
  "options": {
    "auto_apply": true
  }
}
```

**Response**:
```json
{
  "success": true,
  "emails_organized": 23,
  "folder": "Client Contracts",
  "future_handling": "New matching emails will be automatically filed"
}
```

#### List Smart Folders
**Request**:
```json
{
  "action": "list"
}
```

**Response**:
```json
{
  "smart_folders": [
    {
      "name": "Client Contracts",
      "email_count": 23,
      "rule": "Important client emails with contracts/proposals",
      "auto_filing": true,
      "created": "2024-01-15"
    },
    {
      "name": "Team Updates",
      "email_count": 156,
      "rule": "Updates from team members about ongoing projects",
      "auto_filing": false
    }
  ]
}
```

---

## Error Responses

All tools return consistent error responses:

```json
{
  "error": "User-friendly error message",
  "error_code": "SPECIFIC_ERROR_CODE",
  "details": {
    "suggestion": "How to fix the issue",
    "retry_after": 60  // If rate limited
  }
}
```

Common error codes:
- `NEEDS_SETUP` - Credentials not configured
- `INVALID_CREDENTIALS` - Credentials validation failed
- `RATE_LIMIT_EXCEEDED` - Too many requests
- `EMAIL_NOT_FOUND` - Referenced email doesn't exist
- `INVALID_PARAMETER` - Parameter validation failed
- `AI_PROCESSING_ERROR` - AI couldn't understand request

## Best Practices

1. **Use Natural Language**: Users should speak naturally, not in technical terms
2. **Provide Context**: Include context when referencing previous emails
3. **Test Edge Cases**: Empty inboxes, invalid email addresses, network failures
4. **Handle Errors Gracefully**: Always return helpful error messages
5. **Respect Rate Limits**: Implement exponential backoff for retries
</file>

</files>
