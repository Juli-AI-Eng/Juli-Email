This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
ai/
  emailAI.ts
setup/
  setupManager.ts
tools/
  emailInsights.ts
  findEmails.ts
  manageEmail.ts
  organizeInbox.ts
  smartFolders.ts
types/
  index.ts
server.ts
util.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ai/emailAI.ts">
import OpenAI from 'openai';
import {
  EmailIntent,
  GeneratedEmail,
  EmailAnalysis,
  ActionItem,
  Email
} from '../types';
export class EmailAI {
  private openai: OpenAI;
  private debugMode: boolean;
  private defaultReasoningEffort: 'minimal' | 'low' | 'medium' | 'high';
  private defaultVerbosity: 'low' | 'medium' | 'high';
  constructor() {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY environment variable is required for EmailAI');
    }
    this.openai = new OpenAI({
      apiKey: apiKey
    });
    // Enable debug mode for tests
    this.debugMode = process.env.NODE_ENV === 'test' || process.env.DEBUG_AI === 'true';
    // Defaults optimized for latency unless overridden via env
    const reasoning = (process.env.OPENAI_REASONING_EFFORT || 'minimal').toLowerCase();
    const verbosity = (process.env.OPENAI_VERBOSITY || 'low').toLowerCase();
    this.defaultReasoningEffort = (['minimal', 'low', 'medium', 'high'].includes(reasoning) ? reasoning : 'minimal') as any;
    this.defaultVerbosity = (['low', 'medium', 'high'].includes(verbosity) ? verbosity : 'low') as any;
  }
  private buildGpt5Params(overrides?: { reasoning_effort?: 'minimal' | 'low' | 'medium' | 'high'; verbosity?: 'low' | 'medium' | 'high' }) {
    return {
      reasoning: { effort: overrides?.reasoning_effort || this.defaultReasoningEffort },
      text: { verbosity: overrides?.verbosity || this.defaultVerbosity }
    } as any;
  }
  private extractFirstToolCall(response: any): { name: string; arguments: string } | null {
    if (!response) return null;
    const out = (response as any).output;
    if (Array.isArray(out)) {
      // Direct tool/function call items (Responses API emits type 'function_call')
      const tc = out.find((o: any) => o?.type === 'tool_call' || o?.type === 'function_call');
      if (tc) {
        const name = tc.tool_name || tc.name;
        const args = tc.arguments || tc.arguments_text || (typeof tc.input === 'object' ? JSON.stringify(tc.input) : tc.input);
        if (name && args !== undefined) return { name, arguments: typeof args === 'string' ? args : JSON.stringify(args) };
      }
      // Tool use embedded in message content
      const msg = out.find((o: any) => o?.type === 'message');
      const content = msg?.content;
      if (Array.isArray(content)) {
        const toolUse = content.find((c: any) => c?.type === 'tool_use' && c?.name);
        if (toolUse) {
          const args = toolUse.input ?? {};
          return { name: toolUse.name, arguments: JSON.stringify(args) };
        }
      }
    }
    return null;
  }
  private extractText(response: any): string | undefined {
    if (!response) return undefined;
    if (typeof response.output_text === 'string') return response.output_text as string;
    const out = (response as any).output;
    if (Array.isArray(out)) {
      const msg = out.find((o: any) => o?.type === 'message');
      const parts = msg?.content;
      if (Array.isArray(parts)) {
        const texts = parts.filter((p: any) => p?.type === 'output_text' || p?.type === 'text').map((p: any) => p?.text || p?.content).filter(Boolean);
        if (texts.length > 0) return texts.join('\n');
      }
    }
    return undefined;
  }
  async understandSearchQuery(query: string): Promise<{
    intent: string;
    timeframe?: { start?: Date; end?: Date };
    senders?: string[];
    keywords?: string[];
    filters?: {
      unread?: boolean;
      starred?: boolean;
      hasAttachments?: boolean;
    };
  }> {
    const tools = [{
      type: "function" as const,
      name: "extract_search_params",
      description: "Extract email search parameters from natural language query",
      parameters: {
        type: "object",
        properties: {
          intent: {
            type: "string",
            description: "The search intent"
          },
          timeframe: {
            type: ["object", "null"],
            properties: {
              start: {
                type: ["string", "null"],
                description: "Start date/time (e.g., '2024-01-01', 'yesterday', '7 days ago')"
              },
              end: {
                type: ["string", "null"],
                description: "End date/time"
              }
            },
            required: ["start", "end"],
            additionalProperties: false,
            description: "Time range for the search"
          },
          senders: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "Sender name or email"
            },
            description: "List of senders to filter by"
          },
          keywords: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "Keyword to search for"
            },
            description: "Keywords to search in email content"
          },
          filters: {
            type: ["object", "null"],
            properties: {
              unread: {
                type: ["boolean", "null"],
                description: "Filter for unread emails"
              },
              starred: {
                type: ["boolean", "null"],
                description: "Filter for starred/important emails"
              },
              hasAttachments: {
                type: ["boolean", "null"],
                description: "Filter for emails with attachments"
              }
            },
            required: ["unread", "starred", "hasAttachments"],
            additionalProperties: false,
            description: "Boolean filters for email properties"
          }
        },
        required: ["intent", "timeframe", "senders", "keywords", "filters"],
        additionalProperties: false
      }
    }];
    const systemPrompt = `You are an email search assistant. Analyze the user's natural language query and extract structured search parameters.
Examples:
- "emails from John about the project" ‚Üí senders: ["John"], keywords: ["project"]
- "unread emails from last week" ‚Üí filters: { unread: true }, timeframe: { start: "7 days ago" }
- "important emails I haven't responded to" ‚Üí filters: { starred: true }
- "emails with attachments from yesterday" ‚Üí filters: { hasAttachments: true }, timeframe: { start: "yesterday", end: "today" }`;
    if (this.debugMode) {
      console.log('\nü§ñ AI Search Query Understanding');
      console.log('üìù User Query:', query);
      console.log('üîß Function Schema:', JSON.stringify((tools as any)[0].parameters, null, 2));
    }
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "extract_search_params" },
      ...this.buildGpt5Params()
    });
    if (this.debugMode) {
      console.log('üìä AI Response:', JSON.stringify(completion.choices[0].message, null, 2));
    }
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'extract_search_params') {
      throw new Error('Failed to understand search query');
    }
    const result = JSON.parse((toolCall as any).arguments || (toolCall as any).function?.arguments);
    // Clean up null values and parse dates if needed
    const searchParams: any = {
      intent: result.intent
    };
    if (result.timeframe && (result.timeframe.start || result.timeframe.end)) {
      searchParams.timeframe = {};
      if (result.timeframe.start) {
        searchParams.timeframe.start = this.parseTimeString(result.timeframe.start);
      }
      if (result.timeframe.end) {
        searchParams.timeframe.end = this.parseTimeString(result.timeframe.end);
      }
    }
    if (result.senders && result.senders.length > 0) {
      searchParams.senders = result.senders;
    }
    if (result.keywords && result.keywords.length > 0) {
      searchParams.keywords = result.keywords;
    }
    if (result.filters) {
      searchParams.filters = {};
      if (result.filters.unread !== null) searchParams.filters.unread = result.filters.unread;
      if (result.filters.starred !== null) searchParams.filters.starred = result.filters.starred;
      if (result.filters.hasAttachments !== null) searchParams.filters.hasAttachments = result.filters.hasAttachments;
    }
    return searchParams;
  }
  private parseTimeString(timeStr: string): Date {
    const now = new Date();
    const lowerStr = timeStr.toLowerCase();
    // Handle relative dates
    if (lowerStr === 'today') {
      return new Date(now.getFullYear(), now.getMonth(), now.getDate());
    } else if (lowerStr === 'yesterday') {
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      return new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
    } else if (lowerStr.includes('days ago')) {
      const days = parseInt(lowerStr.match(/(\d+)\s*days?\s*ago/)?.[1] || '0');
      const date = new Date(now);
      date.setDate(date.getDate() - days);
      return date;
    } else if (lowerStr.includes('hours ago')) {
      const hours = parseInt(lowerStr.match(/(\d+)\s*hours?\s*ago/)?.[1] || '0');
      const date = new Date(now);
      date.setHours(date.getHours() - hours);
      return date;
    } else if (lowerStr === 'last week') {
      const date = new Date(now);
      date.setDate(date.getDate() - 7);
      return date;
    } else if (lowerStr === 'last month') {
      const date = new Date(now);
      date.setMonth(date.getMonth() - 1);
      return date;
    }
    // Try to parse as a date string
    return new Date(timeStr);
  }
  async understandQuery(query: string, context?: any): Promise<EmailIntent> {
    const tools = [{
      type: "function" as const,
      name: "extract_email_intent",
      description: "Extract the intent, recipients, subject, key points, urgency and tone from a natural language email request",
      parameters: {
        type: "object",
        properties: {
          intent: {
            type: "string",
            enum: ["send", "reply", "forward", "find", "organize"],
            description: "The user's intent"
          },
          recipients: {
            type: "array",
            items: {
              type: "string",
              description: "Email address or contact name (e.g., 'john@example.com' or 'Sarah')"
            },
            description: "List of recipient email addresses or contact names to be resolved"
          },
          subject: {
            type: "string",
            description: "Suggested email subject line"
          },
          key_points: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Key points or topics to include"
          },
          urgency: {
            type: "string",
            enum: ["low", "normal", "high", "urgent"],
            description: "Urgency level of the email"
          },
          tone: {
            type: "string",
            enum: ["professional", "casual", "friendly", "formal", "grateful"],
            description: "Desired tone of the email"
          }
        },
        required: ["intent", "recipients", "subject", "key_points", "urgency", "tone"],
        additionalProperties: false
      }
    }];
    const systemPrompt = `You are an email assistant. Analyze the user's request and extract email intent information.
    IMPORTANT: Recipients can be specified as either:
    - Full email addresses (e.g., "john@example.com")
    - Contact names (e.g., "Sarah", "John Smith") which will be resolved later
    When the user mentions people by name only (like "email Sarah"), extract the name as-is in the recipients array.
    ${context?.senderEmail ? `Context: The user wants to reply to an email from ${context.senderEmail}` : ''}`;
    if (this.debugMode) {
      console.log('\nü§ñ AI Email Intent Understanding');
      console.log('üìù User Query:', query);
      console.log('üîß Function Schema:', JSON.stringify((tools as any)[0].parameters, null, 2));
    }
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "extract_email_intent" },
      ...this.buildGpt5Params()
    });
    if (this.debugMode) {
      try {
        console.log('üß™ Responses output (understandQuery):', JSON.stringify(completion, null, 2));
      } catch { }
    }
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'extract_email_intent') {
      throw new Error('Failed to extract email intent');
    }
    const result = JSON.parse(toolCall.arguments) as EmailIntent;
    // If context has sender email and intent is reply, ensure it's in recipients
    if (context?.senderEmail && result.intent === 'reply') {
      result.recipients = result.recipients || [];
      if (!result.recipients.includes(context.senderEmail)) {
        result.recipients.push(context.senderEmail);
      }
    }
    return result;
  }
  async generateEmailContent(intent: EmailIntent, contextEmail?: Email, recipientNames?: { [email: string]: string }, senderInfo?: { email?: string; name?: string } | null): Promise<GeneratedEmail> {
    const tools = [{
      type: "function" as const,
      name: "generate_email",
      description: "Generate a complete email with recipients, subject, and body",
      parameters: {
        type: "object",
        properties: {
          to: {
            type: "array",
            items: {
              type: "string",
              description: "Recipient email address"
            },
            description: "Primary recipients"
          },
          cc: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "CC recipient email address"
            },
            description: "CC recipients"
          },
          bcc: {
            type: ["array", "null"],
            items: {
              type: "string",
              description: "BCC recipient email address"
            },
            description: "BCC recipients"
          },
          subject: {
            type: "string",
            description: "Email subject line"
          },
          body: {
            type: "string",
            description: "Complete email body"
          },
          tone_confirmation: {
            type: ["string", "null"],
            description: "Confirmation of tone used"
          }
        },
        required: ["to", "subject", "body", "cc", "bcc", "tone_confirmation"],
        additionalProperties: false
      }
    }];
    // Build recipient context with names when available
    const recipientContext = intent.recipients?.map(email => {
      const name = recipientNames?.[email];
      return name ? `${name} (${email})` : email;
    }).join(', ') || 'to be determined';
    const senderContext = senderInfo?.name && senderInfo?.email
      ? `You are writing this email as ${senderInfo.name} (${senderInfo.email})`
      : 'You are writing a professional email';
    const systemPrompt = `You are a professional email writer. ${senderContext}
    Generate an email based on:
    - Recipients: ${recipientContext}
    - Subject suggestion: ${intent.subject || 'Create appropriate subject'}
    - Key points to cover: ${intent.key_points.join(', ')}
    - Tone: ${intent.tone}
    - Urgency: ${intent.urgency}
    ${contextEmail ? `This is in response to an email with subject: "${contextEmail.subject}"` : ''}
    RECIPIENT NAMES: ${recipientNames && Object.keys(recipientNames).length > 0
        ? Object.entries(recipientNames).map(([email, name]) => `${email} = ${name}`).join(', ')
        : 'No contact names found - use "Hello" as greeting'}
    FORMATTING REQUIREMENTS:
    - Use proper paragraph breaks with double line breaks (\\n\\n) between paragraphs
    - Start with an appropriate greeting: If recipient name is known, use "Dear [Name]", otherwise use "Hello"
    - Structure: Greeting\n\nOpening paragraph\n\nBody paragraphs (if needed)\n\nClosing paragraph\n\nSign-off
    - Ensure professional spacing and readability
    - Each distinct thought or topic should be its own paragraph
    - End with an appropriate sign-off (Best regards, Sincerely, etc.) followed by the sender's name: ${senderInfo?.name || '[Your Name]'}
    Write a complete, professional email that covers all key points naturally with proper formatting.`;
    if (this.debugMode) {
      try {
        console.log('üîß Tools (generateEmailContent):', JSON.stringify(tools));
      } catch { }
    }
    let completion: any;
    try {
      completion = await (this.openai as any).responses.create({
        model: "gpt-5",
        input: [
          { role: "system", content: systemPrompt },
          { role: "user", content: "Generate the email content." }
        ],
        tools: tools,
        tool_choice: { type: "function", name: "generate_email" },
        ...this.buildGpt5Params({ verbosity: 'medium' })
      });
    } catch (err: any) {
      if (this.debugMode) {
        console.error('‚ùå OpenAI error (generateEmailContent):', err?.response?.data || err?.message || err);
      }
      throw err;
    }
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_email') {
      throw new Error('Failed to generate email content');
    }
    const result = JSON.parse(toolCall.arguments);
    // Debug log to see what the AI generated
    if (this.debugMode) {
      console.log('üìß Generated email body:', result.body);
      console.log('üìß Body includes \\n\\n:', result.body.includes('\\n\\n'));
    }
    // Convert null values to undefined for optional fields
    return {
      to: result.to,
      cc: result.cc || undefined,
      bcc: result.bcc || undefined,
      subject: result.subject,
      body: result.body,
      tone_confirmation: result.tone_confirmation || undefined
    };
  }
  async analyzeEmailImportance(emails: Email[]): Promise<EmailAnalysis[]> {
    const tools = [{
      type: "function" as const,
      name: "analyze_emails",
      description: "Analyze importance and categorize multiple emails",
      parameters: {
        type: "object",
        properties: {
          analyses: {
            type: "array",
            items: {
              type: "object",
              properties: {
                email_id: {
                  type: "string",
                  description: "ID of the email being analyzed"
                },
                importance_score: {
                  type: "number",
                  description: "Importance score from 0 to 1"
                },
                category: {
                  type: "string",
                  enum: ["urgent_alert", "client_email", "newsletter", "notification", "personal", "other"],
                  description: "Email category"
                },
                reason: {
                  type: "string",
                  description: "Reason for the importance rating"
                },
                action_required: {
                  type: "boolean",
                  description: "Whether action is required"
                },
                suggested_folder: {
                  type: ["string", "null"],
                  description: "Suggested folder for organization"
                }
              },
              required: ["email_id", "importance_score", "category", "reason", "action_required", "suggested_folder"],
              additionalProperties: false
            },
            description: "Analysis results for each email"
          }
        },
        required: ["analyses"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      id: e.id,
      subject: e.subject,
      from: e.from[0]?.email || 'unknown',
      snippet: e.snippet || ''
    }));
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: `Analyze emails for importance and categorization. Consider sender importance, urgency indicators, business impact, and time sensitivity.` },
        { role: "user", content: `Analyze these emails: ${JSON.stringify(emailSummaries)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "analyze_emails" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'analyze_emails') {
      throw new Error('Failed to analyze emails');
    }
    const result = JSON.parse(toolCall.arguments);
    return result.analyses.map((analysis: any) => ({
      ...analysis,
      suggested_folder: analysis.suggested_folder || undefined
    }));
  }
  async generateAggregatedSummary(emails: Email[]): Promise<string> {
    const tools = [{
      type: "function" as const,
      name: "generate_summary",
      description: "Generate a natural language summary of multiple emails",
      parameters: {
        type: "object",
        properties: {
          summary: {
            type: "string",
            description: "A comprehensive natural language summary of the emails"
          },
          key_topics: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Main topics discussed across the emails"
          },
          important_items: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Important items that need attention"
          },
          action_required: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Actions that need to be taken"
          }
        },
        required: ["summary", "key_topics", "important_items", "action_required"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      subject: e.subject,
      from: e.from[0]?.name || e.from[0]?.email || 'unknown',
      snippet: e.snippet || '',
      date: e.date ? new Date(e.date * 1000).toLocaleString() : 'unknown'
    }));
    const systemPrompt = `You are an email assistant. Analyze these emails and provide a natural language summary that captures:
    1. The overall themes and topics
    2. What's important or urgent
    3. What actions the user needs to take
    4. Any patterns or trends
    Write the summary as if you're a helpful assistant briefing someone about their inbox.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Summarize these emails: ${JSON.stringify(emailSummaries)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_summary" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_summary') {
      throw new Error('Failed to generate summary');
    }
    const result = JSON.parse(toolCall.arguments);
    // Combine the structured data into a natural summary
    let fullSummary = result.summary;
    if (result.important_items.length > 0) {
      fullSummary += ` Important: ${result.important_items.join(', ')}.`;
    }
    if (result.action_required.length > 0) {
      fullSummary += ` Action needed: ${result.action_required.join(', ')}.`;
    }
    return fullSummary;
  }
  async extractActionItems(email: Email): Promise<ActionItem[]> {
    const tools = [{
      type: "function" as const,
      name: "extract_action_items",
      description: "Extract action items from an email",
      parameters: {
        type: "object",
        properties: {
          action_items: {
            type: "array",
            items: {
              type: "object",
              properties: {
                task: {
                  type: "string",
                  description: "The action item or task"
                },
                deadline: {
                  type: ["string", "null"],
                  description: "Deadline if mentioned"
                },
                priority: {
                  type: "string",
                  enum: ["low", "medium", "high"],
                  description: "Priority level"
                }
              },
              required: ["task", "deadline", "priority"],
              additionalProperties: false
            },
            description: "List of action items found"
          }
        },
        required: ["action_items"],
        additionalProperties: false
      }
    }];
    const emailContent = {
      subject: email.subject,
      from: email.from[0]?.email || 'unknown',
      body: email.body || email.snippet || ''
    };
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: "Extract all actionable items from the email. Be thorough." },
        { role: "user", content: `Extract action items from: ${JSON.stringify(emailContent)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "extract_action_items" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'extract_action_items') {
      throw new Error('Failed to extract action items');
    }
    const result = JSON.parse(toolCall.arguments);
    return result.action_items.map((item: any) => ({
      ...item,
      deadline: item.deadline || undefined
    }));
  }
  async generateSmartFolderRules(folderDescription: string): Promise<{
    name: string;
    rules: string[];
    description: string;
  }> {
    const tools = [{
      type: "function" as const,
      name: "generate_folder_rules",
      description: "Generate smart folder rules based on description",
      parameters: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "Folder name"
          },
          rules: {
            type: "array",
            items: {
              type: "string",
              description: "A folder rule"
            },
            description: "List of rules for the folder"
          },
          description: {
            type: "string",
            description: "Folder description"
          }
        },
        required: ["name", "rules", "description"],
        additionalProperties: false
      }
    }];
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: "Generate smart folder rules based on the user description." },
        { role: "user", content: folderDescription }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_folder_rules" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_folder_rules') {
      throw new Error('Failed to generate folder rules');
    }
    return JSON.parse(toolCall.arguments);
  }
  async categorizeEmails(emails: Email[]): Promise<Map<string, string[]>> {
    const tools = [{
      type: "function" as const,
      name: "categorize_emails",
      description: "Categorize emails into logical groups",
      parameters: {
        type: "object",
        properties: {
          categories: {
            type: "array",
            items: {
              type: "object",
              properties: {
                email_id: {
                  type: "string",
                  description: "Email ID"
                },
                category: {
                  type: "string",
                  description: "Category name"
                }
              },
              required: ["email_id", "category"],
              additionalProperties: false
            },
            description: "Email categorizations"
          }
        },
        required: ["categories"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      id: e.id,
      subject: e.subject,
      from: e.from[0]?.email || 'unknown',
      snippet: e.snippet || ''
    }));
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: "Categorize emails into logical groups like: receipts, newsletters, work, personal, etc." },
        { role: "user", content: JSON.stringify(emailSummaries) }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "categorize_emails" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'categorize_emails') {
      throw new Error('Failed to categorize emails');
    }
    const result = JSON.parse(toolCall.arguments);
    // Group by category
    const categoryMap = new Map<string, string[]>();
    result.categories.forEach(({ email_id, category }: { email_id: string; category: string }) => {
      if (!categoryMap.has(category)) {
        categoryMap.set(category, []);
      }
      categoryMap.get(category)!.push(email_id);
    });
    return categoryMap;
  }
  async understandOrganizationIntent(query: string): Promise<{
    rules: Array<{
      condition: string;
      action: string;
      target: string | null;
    }>;
  }> {
    const tools = [{
      type: "function" as const,
      name: "understand_organization",
      description: "Understand email organization intent from natural language",
      parameters: {
        type: "object",
        properties: {
          rules: {
            type: "array",
            items: {
              type: "object",
              properties: {
                condition: {
                  type: "string",
                  description: "The condition to match emails (e.g., 'subject contains invoice', 'from newsletter@')"
                },
                action: {
                  type: "string",
                  description: "The action to take (e.g., 'move to folder', 'star', 'mark read')"
                },
                target: {
                  type: ["string", "null"],
                  description: "The target for the action (e.g., folder name, null for star/mark actions)"
                }
              },
              required: ["condition", "action", "target"],
              additionalProperties: false
            },
            description: "List of organization rules"
          }
        },
        required: ["rules"],
        additionalProperties: false
      }
    }];
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: "You are an email assistant that understands organization intents. Convert natural language into email organization rules." },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "understand_organization" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || !toolCall.arguments) {
      throw new Error('Failed to understand organization intent');
    }
    const result = JSON.parse(toolCall.arguments);
    return {
      rules: result.rules.map((rule: any) => ({
        condition: rule.condition,
        action: rule.action,
        target: rule.target || null
      }))
    };
  }
  async generateDailyInsights(emails: Email[], analysis: EmailAnalysis[]): Promise<{
    executive_summary: string;
    key_highlights: string[];
    action_priorities: string[];
    patterns: string[];
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      name: "generate_daily_insights",
      description: "Generate actionable insights from daily email activity",
      parameters: {
        type: "object",
        properties: {
          executive_summary: {
            type: "string",
            description: "A concise executive summary of the day's email activity with actionable insights"
          },
          key_highlights: {
            type: "array",
            items: {
              type: "string"
            },
            description: "3-5 key highlights from today's emails"
          },
          action_priorities: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Prioritized list of actions the user should take"
          },
          patterns: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Communication patterns or trends observed"
          },
          recommendations: {
            type: "array",
            items: {
              type: "string"
            },
            description: "Strategic recommendations for email management"
          }
        },
        required: ["executive_summary", "key_highlights", "action_priorities", "patterns", "recommendations"],
        additionalProperties: false
      }
    }];
    const emailSummaries = emails.map(e => ({
      subject: e.subject,
      from: e.from[0]?.name || e.from[0]?.email || 'unknown',
      snippet: e.snippet || '',
      unread: e.unread,
      importance: analysis.find(a => a.email_id === e.id)?.importance_score || 0.5
    }));
    const systemPrompt = `You are an executive email assistant providing daily insights. Analyze the day's emails and provide:
    1. An executive summary that highlights what matters most
    2. Key highlights that need attention
    3. Prioritized actions the user should take
    4. Communication patterns (who's reaching out, about what)
    5. Strategic recommendations for better email management
    Focus on actionable insights, not just statistics. Help the user understand what's important and what to do about it.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these emails from today: ${JSON.stringify(emailSummaries.slice(0, 50))}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_daily_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_daily_insights') {
      throw new Error('Failed to generate daily insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async understandInsightsQuery(query: string): Promise<{
    insight_type: 'daily_summary' | 'weekly_summary' | 'important_items' | 'response_needed' | 'analytics' | 'relationships';
    time_period?: string;
    focus_area?: string;
  }> {
    const tools = [{
      type: "function" as const,
      name: "understand_insights_request",
      description: "Understand what kind of email insights the user wants",
      parameters: {
        type: "object",
        properties: {
          insight_type: {
            type: "string",
            enum: ["daily_summary", "weekly_summary", "important_items", "response_needed", "analytics", "relationships"],
            description: "The type of insight requested"
          },
          time_period: {
            type: ["string", "null"],
            description: "Time period for the insights (e.g., 'today', 'this week', 'last month')"
          },
          focus_area: {
            type: ["string", "null"],
            description: "Specific area to focus on (e.g., 'project X', 'client emails')"
          }
        },
        required: ["insight_type", "time_period", "focus_area"],
        additionalProperties: false
      }
    }];
    const systemPrompt = `You are an email insights assistant. Analyze the user's request and determine what kind of email insights they want.
Examples:
- "summarize my emails today" ‚Üí daily_summary
- "what emails need my response?" ‚Üí response_needed
- "show me email analytics for this week" ‚Üí analytics, time_period: "this week"
- "who am I communicating with most?" ‚Üí relationships
- "what important emails did I get this week?" ‚Üí important_items, time_period: "this week"
- "weekly summary" ‚Üí weekly_summary`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "understand_insights_request" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'understand_insights_request') {
      throw new Error('Failed to understand insights request');
    }
    const result = JSON.parse(toolCall.arguments);
    return {
      insight_type: result.insight_type,
      time_period: result.time_period || undefined,
      focus_area: result.focus_area || undefined
    };
  }
  async generateWeeklyInsights(emails: Email[], analysis: EmailAnalysis[], emailsByDay: Record<string, Email[]>): Promise<{
    executive_summary: string;
    week_trend: string;
    key_themes: string[];
    productivity_insights: string[];
    important_conversations: string[];
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_weekly_insights",
        description: "Generate comprehensive weekly email insights with trends and patterns",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "A comprehensive executive summary of the week's email activity"
            },
            week_trend: {
              type: "string",
              description: "Description of how this week compared to typical patterns"
            },
            key_themes: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Main themes and topics from the week's emails"
            },
            productivity_insights: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Insights about email patterns and productivity"
            },
            important_conversations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Key conversations and threads from the week"
            },
            recommendations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Actionable recommendations for the upcoming week"
            }
          },
          required: ["executive_summary", "week_trend", "key_themes", "productivity_insights", "important_conversations", "recommendations"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    // Prepare data for AI analysis
    const dailyVolumes = Object.entries(emailsByDay).map(([day, emails]) => ({
      day,
      count: emails.length,
      unread: emails.filter(e => e.unread).length
    }));
    const emailSummaries = emails.slice(0, 100).map(e => ({
      subject: e.subject,
      from: e.from[0]?.name || e.from[0]?.email || 'unknown',
      date: new Date(e.date * 1000).toLocaleDateString(),
      unread: e.unread,
      importance: analysis.find(a => a.email_id === e.id)?.importance_score || 0.5
    }));
    const systemPrompt = `You are an executive email assistant providing weekly insights. Analyze the week's email activity and provide:
    1. An executive summary highlighting major themes, important items, and overall email health
    2. Week-over-week trends (busier/quieter than usual, unusual patterns)
    3. Key themes and topics that dominated the week
    4. Productivity insights (response patterns, email overload indicators, time management)
    5. Important conversations that need follow-up
    6. Strategic recommendations for the upcoming week
    Daily volumes: ${JSON.stringify(dailyVolumes)}
    Total emails: ${emails.length}
    Unread: ${emails.filter(e => e.unread).length}
    Focus on actionable insights and patterns that help improve email management.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these emails from the past week: ${JSON.stringify(emailSummaries)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_weekly_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_weekly_insights') {
      throw new Error('Failed to generate weekly insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateImportantItemsInsights(emails: Email[], analysis: EmailAnalysis[]): Promise<{
    executive_summary: string;
    priority_items: Array<{
      email_id: string;
      subject: string;
      from: string;
      importance_reason: string;
      action_required: string;
    }>;
    action_plan: string[];
    key_deadlines: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_important_items",
        description: "Generate insights about important emails requiring attention",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "A concise summary of what important items need attention"
            },
            priority_items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  email_id: {
                    type: "string",
                    description: "ID of the important email"
                  },
                  subject: {
                    type: "string",
                    description: "Email subject"
                  },
                  from: {
                    type: "string",
                    description: "Sender name or email"
                  },
                  importance_reason: {
                    type: "string",
                    description: "Why this email is important"
                  },
                  action_required: {
                    type: "string",
                    description: "What action needs to be taken"
                  }
                },
                required: ["email_id", "subject", "from", "importance_reason", "action_required"],
                additionalProperties: false
              },
              description: "List of important emails with details"
            },
            action_plan: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Prioritized list of actions to take"
            },
            key_deadlines: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Important deadlines extracted from emails"
            }
          },
          required: ["executive_summary", "priority_items", "action_plan", "key_deadlines"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    const importantEmails = analysis
      .filter(a => a.importance_score > 0.7)
      .map(a => {
        const email = emails.find(e => e.id === a.email_id);
        return {
          id: a.email_id,
          subject: email?.subject || 'Unknown',
          from: email?.from[0]?.name || email?.from[0]?.email || 'Unknown',
          snippet: email?.snippet || '',
          importance_score: a.importance_score,
          reason: a.reason,
          action_required: a.action_required
        };
      });
    const systemPrompt = `You are an executive email assistant analyzing important emails. Provide:
    1. A clear summary of what needs attention
    2. Detailed breakdown of each important item
    3. A prioritized action plan
    4. Key deadlines to remember
    Focus on actionable insights and help the user understand what to do next.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these important emails: ${JSON.stringify(importantEmails)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_important_items" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_important_items') {
      throw new Error('Failed to generate important items insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateResponseNeededInsights(emails: Email[], needsResponse: Email[]): Promise<{
    executive_summary: string;
    response_priorities: Array<{
      email_id: string;
      subject: string;
      from: string;
      urgency: 'high' | 'medium' | 'low';
      suggested_response: string;
      context: string;
    }>;
    response_strategy: string[];
    time_estimate: string;
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_response_insights",
        description: "Generate insights about emails needing responses",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "Summary of emails needing responses with urgency assessment"
            },
            response_priorities: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  email_id: {
                    type: "string",
                    description: "Email ID"
                  },
                  subject: {
                    type: "string",
                    description: "Email subject"
                  },
                  from: {
                    type: "string",
                    description: "Sender"
                  },
                  urgency: {
                    type: "string",
                    enum: ["high", "medium", "low"],
                    description: "Response urgency level"
                  },
                  suggested_response: {
                    type: "string",
                    description: "Brief suggestion for how to respond"
                  },
                  context: {
                    type: "string",
                    description: "Context about why this needs a response"
                  }
                },
                required: ["email_id", "subject", "from", "urgency", "suggested_response", "context"],
                additionalProperties: false
              },
              description: "Prioritized list of emails needing responses"
            },
            response_strategy: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Strategic recommendations for handling responses"
            },
            time_estimate: {
              type: "string",
              description: "Estimated time needed to respond to all emails"
            }
          },
          required: ["executive_summary", "response_priorities", "response_strategy", "time_estimate"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    const responseData = needsResponse.slice(0, 20).map(email => ({
      id: email.id,
      subject: email.subject,
      from: email.from[0]?.name || email.from[0]?.email || 'Unknown',
      snippet: email.snippet || '',
      date: new Date(email.date * 1000).toLocaleDateString()
    }));
    const systemPrompt = `You are an email response strategist. Analyze emails that need responses and provide:
    1. An executive summary with urgency levels
    2. Prioritized response recommendations
    3. Strategic advice for efficient response handling
    4. Time estimates for completing responses
    Help the user tackle their response backlog efficiently.`;
    const completion = await this.openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these emails needing responses: ${JSON.stringify(responseData)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", function: { name: "generate_response_insights" } }
    });
    const toolCall = completion.choices[0]?.message?.tool_calls?.[0];
    if (!toolCall || toolCall.function.name !== 'generate_response_insights') {
      throw new Error('Failed to generate response insights');
    }
    return JSON.parse((toolCall as any).arguments || (toolCall as any).function?.arguments);
  }
  async generateAnalyticsInsights(
    emails: Email[],
    timePeriod: string,
    senderStats: Map<string, number>,
    categories: Record<string, number>
  ): Promise<{
    executive_summary: string;
    volume_analysis: {
      trend: string;
      pattern: string;
      anomalies: string[];
    };
    sender_insights: {
      top_relationships: string[];
      communication_balance: string;
      new_contacts: string[];
    };
    productivity_metrics: {
      response_rate: string;
      peak_hours: string[];
      email_habits: string[];
    };
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_analytics",
        description: "Generate comprehensive email analytics insights",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "High-level summary of email patterns and insights"
            },
            volume_analysis: {
              type: "object",
              properties: {
                trend: {
                  type: "string",
                  description: "Overall volume trend description"
                },
                pattern: {
                  type: "string",
                  description: "Daily/weekly patterns observed"
                },
                anomalies: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Unusual patterns or spikes"
                }
              },
              required: ["trend", "pattern", "anomalies"],
              additionalProperties: false
            },
            sender_insights: {
              type: "object",
              properties: {
                top_relationships: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Most frequent email contacts"
                },
                communication_balance: {
                  type: "string",
                  description: "Analysis of communication patterns"
                },
                new_contacts: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "New contacts in this period"
                }
              },
              required: ["top_relationships", "communication_balance", "new_contacts"],
              additionalProperties: false
            },
            productivity_metrics: {
              type: "object",
              properties: {
                response_rate: {
                  type: "string",
                  description: "Email response rate analysis"
                },
                peak_hours: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Peak email activity hours"
                },
                email_habits: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Observed email habits and patterns"
                }
              },
              required: ["response_rate", "peak_hours", "email_habits"],
              additionalProperties: false
            },
            recommendations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Actionable recommendations for email management"
            }
          },
          required: ["executive_summary", "volume_analysis", "sender_insights", "productivity_metrics", "recommendations"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    // Prepare analytics data
    const topSenders = Array.from(senderStats.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([sender, count]) => ({ sender, count }));
    const hourlyDistribution = emails.reduce((acc, email) => {
      const hour = new Date(email.date * 1000).getHours();
      acc[hour] = (acc[hour] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);
    const analyticsData = {
      period: timePeriod,
      total_emails: emails.length,
      unread_count: emails.filter(e => e.unread).length,
      top_senders: topSenders,
      categories: categories,
      hourly_distribution: hourlyDistribution,
      daily_average: emails.length / (timePeriod === 'week' ? 7 : timePeriod === 'month' ? 30 : 1)
    };
    const systemPrompt = `You are an email analytics expert. Analyze email patterns and provide:
    1. Executive summary of key findings
    2. Volume trends and anomalies
    3. Sender relationship insights
    4. Productivity metrics and habits
    5. Actionable recommendations
    Focus on insights that help improve email productivity and communication effectiveness.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these email analytics: ${JSON.stringify(analyticsData)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_analytics" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_analytics') {
      throw new Error('Failed to generate analytics insights');
    }
    return JSON.parse(toolCall.arguments);
  }
  async generateRelationshipInsights(
    emails: Email[],
    contactStats: Map<string, { sent: number; received: number; importance: number }>
  ): Promise<{
    executive_summary: string;
    key_relationships: Array<{
      contact: string;
      relationship_type: string;
      communication_style: string;
      insights: string[];
    }>;
    communication_patterns: {
      balance_analysis: string;
      response_patterns: string[];
      collaboration_insights: string[];
    };
    network_insights: {
      growing_relationships: string[];
      neglected_contacts: string[];
      communication_health: string;
    };
    recommendations: string[];
  }> {
    const tools = [{
      type: "function" as const,
      function: {
        name: "generate_relationship_insights",
        description: "Generate insights about email relationships and communication patterns",
        parameters: {
          type: "object",
          properties: {
            executive_summary: {
              type: "string",
              description: "Summary of key relationship insights"
            },
            key_relationships: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  contact: {
                    type: "string",
                    description: "Contact email or name"
                  },
                  relationship_type: {
                    type: "string",
                    description: "Type of relationship (e.g., 'colleague', 'client', 'manager')"
                  },
                  communication_style: {
                    type: "string",
                    description: "Description of communication patterns"
                  },
                  insights: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "Specific insights about this relationship"
                  }
                },
                required: ["contact", "relationship_type", "communication_style", "insights"],
                additionalProperties: false
              },
              description: "Analysis of key email relationships"
            },
            communication_patterns: {
              type: "object",
              properties: {
                balance_analysis: {
                  type: "string",
                  description: "Analysis of communication balance"
                },
                response_patterns: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Patterns in email responses"
                },
                collaboration_insights: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Insights about collaboration patterns"
                }
              },
              required: ["balance_analysis", "response_patterns", "collaboration_insights"],
              additionalProperties: false
            },
            network_insights: {
              type: "object",
              properties: {
                growing_relationships: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Relationships that are growing stronger"
                },
                neglected_contacts: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Contacts that may need more attention"
                },
                communication_health: {
                  type: "string",
                  description: "Overall assessment of communication health"
                }
              },
              required: ["growing_relationships", "neglected_contacts", "communication_health"],
              additionalProperties: false
            },
            recommendations: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Recommendations for improving relationships"
            }
          },
          required: ["executive_summary", "key_relationships", "communication_patterns", "network_insights", "recommendations"],
          additionalProperties: false
        },
        strict: true
      }
    }];
    // Prepare relationship data
    const relationships = Array.from(contactStats.entries())
      .map(([contact, stats]) => ({
        contact,
        total_interactions: stats.sent + stats.received,
        balance: stats.sent / (stats.received || 1),
        avg_importance: stats.importance / (stats.received || 1),
        sent: stats.sent,
        received: stats.received
      }))
      .sort((a, b) => b.total_interactions - a.total_interactions)
      .slice(0, 20);
    const systemPrompt = `You are a relationship analyst specializing in email communication. Analyze communication patterns and provide:
    1. Key relationship insights
    2. Communication style analysis
    3. Network health assessment
    4. Actionable recommendations
    Focus on helping improve professional relationships and communication effectiveness.`;
    const completion = await (this.openai as any).responses.create({
      model: "gpt-5-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Analyze these email relationships: ${JSON.stringify(relationships)}` }
      ],
      tools: tools,
      tool_choice: { type: "function", name: "generate_relationship_insights" },
      ...this.buildGpt5Params()
    });
    const toolCall = this.extractFirstToolCall(completion);
    if (!toolCall || toolCall.name !== 'generate_relationship_insights') {
      throw new Error('Failed to generate relationship insights');
    }
    return JSON.parse(toolCall.arguments);
  }
}
</file>

<file path="setup/setupManager.ts">
import Nylas from 'nylas';
import { SetupResponse, SetupInstruction } from '../types/index.js';
export class SetupManager {
  async handleSetup(params: any): Promise<SetupResponse> {
    const { action, credentials } = params;
    switch (action) {
      case 'get_instructions':
        return this.getInstructions();
      case 'validate_credentials':
        if (!credentials) {
          return {
            type: 'validation_error',
            message: 'No credentials provided',
            missing_fields: ['credentials']
          };
        }
        return this.validateCredentials(credentials);
      case 'test_connection':
        // In HTTP mode, this is typically called after credentials are stored
        return {
          type: 'setup_success',
          message: 'Connection test feature coming soon. Please validate credentials first.'
        };
      case 'troubleshoot':
        return this.troubleshoot(params.issue || 'general issue');
      default:
        return {
          type: 'setup_error',
          message: `Unknown setup action: ${action}`
        };
    }
  }
  async getInstructions(): Promise<SetupResponse> {
    return {
      type: 'setup_instructions',
      title: 'Email Setup Guide',
      estimated_time: '5 minutes',
      steps: [
        {
          step: 1,
          title: 'Create Your Free Nylas Account',
          description: 'Nylas provides 5 free email connections - perfect for personal use!',
          actions: [
            {
              type: 'link',
              label: 'Open Nylas Signup',
              url: 'https://dashboard-v3.nylas.com/register?utm_source=juli',
            }
          ],
          tips: [
            'Use the same email you\'ll be connecting later',
            'No credit card required for free tier'
          ]
        },
        {
          step: 2,
          title: 'Get Your API Key',
          description: 'After signing in, find your API key in the dashboard',
          actions: [
            {
              type: 'copy_field',
              label: 'I\'ll paste my API key here',
              field: 'nylas_api_key',
              validation: 'regex:^nyk_[a-zA-Z0-9]+$'
            }
          ],
          tips: [
            'API key starts with \'nyk_\'',
            'Keep this key secret - it\'s like a password!'
          ]
        },
        {
          step: 3,
          title: 'Connect Your Email Account',
          description: 'Add your email account to Nylas',
          substeps: [
            'Click \'Grants\' in the sidebar',
            'Click \'Add Test Grant\' button (top right)',
            'Choose your email provider (Gmail, Outlook, etc)',
            'Authorize Nylas to access your email',
            'Copy the Grant ID that appears'
          ],
          actions: [
            {
              type: 'copy_field',
              label: 'I\'ll paste my Grant ID here',
              field: 'nylas_grant_id',
              validation: 'regex:^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
            }
          ],
          common_issues: [
            {
              issue: 'Can\'t find Grant ID',
              solution: 'It\'s in the table under the \'ID\' column after you connect'
            },
            {
              issue: 'Authorization failed',
              solution: 'Make sure to allow all requested permissions'
            }
          ]
        }
      ],
      next_step: {
        description: 'Once you have both credentials, validate them through Juli',
        command: 'setup_email_connection',
        parameters: {
          action: 'validate_credentials',
          credentials: {
            nylas_api_key: 'your_key_here',
            nylas_grant_id: 'your_grant_id_here'
          }
        }
      }
    };
  }
  async validateCredentials(
    credentials: any
  ): Promise<SetupResponse> {
    // Debug logging
    console.log('Validating credentials:', {
      hasApiKey: !!credentials?.nylas_api_key,
      apiKeyPrefix: credentials?.nylas_api_key?.substring(0, 10) + '...',
      grantId: credentials?.nylas_grant_id
    });
    // Check for missing credentials
    if (!credentials?.nylas_api_key || !credentials?.nylas_grant_id) {
      return {
        type: 'validation_error',
        message: 'Both API key and Grant ID are required',
        missing_fields: [
          !credentials?.nylas_api_key && 'nylas_api_key',
          !credentials?.nylas_grant_id && 'nylas_grant_id'
        ].filter(Boolean) as string[]
      };
    }
    // Validate API key format
    if (!credentials.nylas_api_key.startsWith('nyk_')) {
      return {
        type: 'validation_error',
        message: 'API key should start with \'nyk_\'',
      };
    }
    // Validate Grant ID format (UUID)
    const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    if (!uuidRegex.test(credentials.nylas_grant_id)) {
      return {
        type: 'validation_error',
        message: 'Grant ID should be a valid UUID',
      };
    }
    try {
      // Test the credentials
      console.log('Creating Nylas client with API key:', credentials.nylas_api_key.substring(0, 20) + '...');
      const testClient = new Nylas({ apiKey: credentials.nylas_api_key });
      // Try to fetch grant info to verify
      console.log('Fetching grant:', credentials.nylas_grant_id);
      const grant = await testClient.grants.find({
        grantId: credentials.nylas_grant_id
      });
      // Get email address for confirmation
      const emailAddress = grant.data.email || 'your email';
      return {
        type: 'setup_success',
        message: `Successfully connected ${emailAddress}!`,
        credentials_validated: true,
        credentials_to_store: {
          nylas_api_key: credentials.nylas_api_key,
          nylas_grant_id: credentials.nylas_grant_id,
          email_address: emailAddress,
          provider: grant.data.provider
        }
      };
    } catch (error: any) {
      // Log the full error for debugging
      console.error('Nylas validation error:', {
        statusCode: error.statusCode,
        message: error.message,
        type: error.type,
        providerError: error.provider_error,
        requestId: error.request_id,
        fullError: error
      });
      // Handle different error types
      if (error.statusCode === 401) {
        return {
          type: 'setup_error',
          message: 'Invalid API key',
          error_details: 'Double-check your API key from the Nylas dashboard'
        };
      } else if (error.statusCode === 404) {
        return {
          type: 'setup_error',
          message: 'Grant ID not found',
          error_details: 'Make sure you completed the \'Add Test Grant\' step'
        };
      } else {
        return {
          type: 'setup_error',
          message: 'Could not connect to Nylas',
          error_details: error.message
        };
      }
    }
  }
  async troubleshoot(issue: string): Promise<SetupResponse> {
    const lowerIssue = issue.toLowerCase();
    // Check for permission issues
    if (lowerIssue.includes('permission') || lowerIssue.includes('denied') || lowerIssue.includes('access')) {
      return {
        type: 'setup_instructions',
        title: 'Permission Issue Resolution',
        estimated_time: '2 minutes',
        steps: [
          {
            step: 1,
            title: 'Re-authorize Your Email',
            description: 'Re-authorize your email in Nylas dashboard with all permissions enabled',
            substeps: [
              'Go to Nylas dashboard',
              'Find your grant in the Grants section',
              'Delete the existing grant',
              'Create a new test grant',
              'Make sure to allow ALL requested permissions'
            ]
          }
        ]
      };
    }
    // Check for expired grant
    if (lowerIssue.includes('expired') || lowerIssue.includes('invalid grant')) {
      return {
        type: 'setup_instructions',
        title: 'Grant Expired - Create New Grant',
        estimated_time: '3 minutes',
        steps: [
          {
            step: 1,
            title: 'Create a New Test Grant',
            description: 'Test grants expire after 30 days. Let\'s create a fresh one.',
            substeps: [
              'Go to Nylas dashboard',
              'Navigate to Grants section',
              'Click \'Add Test Grant\'',
              'Re-authorize your email',
              'Copy the new Grant ID'
            ]
          }
        ]
      };
    }
    // Generic troubleshooting
    return {
      type: 'setup_instructions',
      title: 'General Troubleshooting',
      estimated_time: '5 minutes',
      steps: [
        {
          step: 1,
          title: 'Verify Your Nylas Account',
          description: 'Make sure your Nylas account is active'
        },
        {
          step: 2,
          title: 'Check API Key Validity',
          description: 'Ensure your API key is still valid and not regenerated'
        },
        {
          step: 3,
          title: 'Verify Email Grant',
          description: 'Check if your email grant hasn\'t expired (30 days for test grants)'
        },
        {
          step: 4,
          title: 'Try Creating Fresh Credentials',
          description: 'Sometimes starting fresh with new grant helps'
        }
      ]
    };
  }
}
</file>

<file path="tools/emailInsights.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { 
  EmailInsightsParams, 
  Email, 
  EmailAnalysis,
  ActionItem
} from '../types';
export class EmailInsightsTool {
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: EmailInsightsParams): Promise<any> {
    try {
      // Use AI to understand what kind of insight the user wants
      const intent = await this.emailAI.understandInsightsQuery(params.query);
      // Execute the appropriate insight generation based on AI understanding
      switch (intent.insight_type) {
        case 'daily_summary':
          return this.generateDailySummary();
        case 'weekly_summary':
          return this.generateWeeklySummary();
        case 'important_items':
          return this.findImportantItems();
        case 'response_needed':
          return this.findResponseNeeded();
        case 'analytics':
          return this.generateAnalytics(intent.time_period || params.time_period || 'week');
        case 'relationships':
          return this.analyzeRelationships();
        default:
          // This shouldn't happen with proper AI understanding, but fallback to daily summary
          return this.generateDailySummary();
      }
    } catch (error: any) {
      throw new Error(`Failed to generate insights: ${error.message}`);
    }
  }
  private async generateDailySummary(): Promise<any> {
    // Get emails from today
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);
    const startTimestamp = Math.floor(todayStart.getTime() / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: startTimestamp,
        limit: 100
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: "No emails received today. Your inbox is clear!",
        insights: {
          total_emails: 0,
          suggestions: ["Great time to focus on deep work", "Check your sent items if expecting replies"]
        }
      };
    }
    // Analyze importance
    let analysis: EmailAnalysis[] = [];
    try {
      if (emails.length > 0) {
        analysis = await this.emailAI.analyzeEmailImportance(emails);
      }
    } catch (error) {
      console.error('AI analysis failed:', error);
    }
    const unreadCount = emails.filter(e => e.unread).length;
    const importantEmails = analysis.filter(a => a.importance_score > 0.8);
    // Group by category
    const categories: Record<string, number> = {};
    analysis.forEach(a => {
      categories[a.category] = (categories[a.category] || 0) + 1;
    });
    // Generate AI-powered insights about the day's emails
    try {
      const insights = await this.emailAI.generateDailyInsights(emails, analysis);
      return {
        summary: insights.executive_summary,
        insights: {
          total_emails: emails.length,
          unread_count: unreadCount,
          key_highlights: insights.key_highlights,
          action_priorities: insights.action_priorities,
          communication_patterns: insights.patterns,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories,
          recommendations: insights.recommendations
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      const summary = `You received ${emails.length} emails today (${unreadCount} unread). ` +
        `${importantEmails.length} are marked as important. ` +
        `Categories: ${Object.entries(categories).map(([cat, count]) => `${cat}: ${count}`).join(', ')}.`;
      return {
        summary,
        insights: {
          total_emails: emails.length,
          unread_count: unreadCount,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories
        }
      };
    }
  }
  private async generateWeeklySummary(): Promise<any> {
    // Get emails from the past week
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    weekAgo.setHours(0, 0, 0, 0);
    const startTimestamp = Math.floor(weekAgo.getTime() / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: startTimestamp,
        limit: 500
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: "No emails received this week. Enjoy the peace and quiet!",
        insights: {
          total_emails: 0,
          suggestions: ["Perfect time for strategic planning", "Consider reaching out to important contacts"]
        }
      };
    }
    // Analyze importance
    let analysis: EmailAnalysis[] = [];
    try {
      if (emails.length > 0) {
        // Analyze a sample for performance reasons
        const sampleSize = Math.min(emails.length, 100);
        const emailSample = emails.slice(0, sampleSize);
        analysis = await this.emailAI.analyzeEmailImportance(emailSample);
      }
    } catch (error) {
      console.error('AI analysis failed:', error);
    }
    // Group by day for trend analysis
    const emailsByDay: Record<string, Email[]> = {};
    emails.forEach(email => {
      const date = new Date(email.date * 1000);
      const dayKey = date.toLocaleDateString();
      if (!emailsByDay[dayKey]) {
        emailsByDay[dayKey] = [];
      }
      emailsByDay[dayKey].push(email);
    });
    const unreadCount = emails.filter(e => e.unread).length;
    const importantEmails = analysis.filter(a => a.importance_score > 0.8);
    // Group by category
    const categories: Record<string, number> = {};
    analysis.forEach(a => {
      categories[a.category] = (categories[a.category] || 0) + 1;
    });
    // Generate AI-powered weekly insights
    try {
      const insights = await this.emailAI.generateWeeklyInsights(emails, analysis, emailsByDay);
      return {
        summary: insights.executive_summary,
        insights: {
          total_emails: emails.length,
          daily_average: Math.round(emails.length / 7),
          unread_count: unreadCount,
          week_over_week_trend: insights.week_trend,
          key_themes: insights.key_themes,
          productivity_insights: insights.productivity_insights,
          important_conversations: insights.important_conversations,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories,
          recommendations: insights.recommendations
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      const summary = `You received ${emails.length} emails this week (avg ${Math.round(emails.length / 7)}/day, ${unreadCount} unread). ` +
        `${importantEmails.length} are marked as important. ` +
        `Categories: ${Object.entries(categories).map(([cat, count]) => `${cat}: ${count}`).join(', ')}.`;
      return {
        summary,
        insights: {
          total_emails: emails.length,
          daily_average: Math.round(emails.length / 7),
          unread_count: unreadCount,
          important_emails: importantEmails.map(a => {
            const email = emails.find(e => e.id === a.email_id);
            return {
              id: a.email_id,
              subject: email?.subject,
              from: email?.from[0]?.email,
              reason: a.reason
            };
          }),
          categories
        }
      };
    }
  }
  private async findImportantItems(): Promise<any> {
    // Get recent unread emails
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        unread: true,
        limit: 50
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: 'No unread emails to analyze.',
        insights: {
          important_emails: [],
          action_items: []
        }
      };
    }
    // Analyze importance
    let analysis: EmailAnalysis[] = [];
    try {
      analysis = await this.emailAI.analyzeEmailImportance(emails);
    } catch (error) {
      console.error('AI analysis failed:', error);
      return {
        summary: 'Unable to analyze email importance at this time.',
        insights: {
          total_emails: emails.length,
          important_emails: []
        }
      };
    }
    // Generate AI-powered insights about important items
    try {
      const insights = await this.emailAI.generateImportantItemsInsights(emails, analysis);
      // Extract action items from important emails
      const actionItems: ActionItem[] = [];
      const importantAnalysis = analysis.filter(a => a.importance_score > 0.8);
      for (const a of importantAnalysis) {
        const email = emails.find(e => e.id === a.email_id);
        if (email && a.action_required) {
          try {
            const items = await this.emailAI.extractActionItems(email);
            actionItems.push(...items);
          } catch (error) {
            console.error('Failed to extract action items:', error);
          }
        }
      }
      return {
        summary: insights.executive_summary,
        insights: {
          priority_items: insights.priority_items,
          action_plan: insights.action_plan,
          key_deadlines: insights.key_deadlines,
          action_items: actionItems,
          total_analyzed: emails.length
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      const importantEmails = analysis
        .filter(a => a.importance_score > 0.8)
        .map(a => {
          const email = emails.find(e => e.id === a.email_id);
          return {
            id: a.email_id,
            subject: email?.subject,
            from: email?.from[0]?.email,
            reason: a.reason,
            action_required: a.action_required
          };
        });
      return {
        summary: `Found ${importantEmails.length} important emails that require attention.`,
        insights: {
          important_emails: importantEmails,
          action_items: []
        }
      };
    }
  }
  private async findResponseNeeded(): Promise<any> {
    // Get recent emails that might need responses
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        limit: 50
      }
    });
    const emails = messages.data as Email[];
    // Filter emails that likely need responses
    const needsResponse: Email[] = [];
    for (const email of emails) {
      // Skip if from self or automated emails
      if (email.from[0]?.email?.includes('noreply') || 
          email.from[0]?.email?.includes('notification')) {
        continue;
      }
      // Check if email has been replied to
      if (email.thread_id) {
        try {
          const thread = await this.nylas.threads.find({
            identifier: this.grantId,
            threadId: email.thread_id
          });
          // If thread has only one message, it hasn't been replied to
          if (thread.data.messageIds && thread.data.messageIds.length === 1) {
            needsResponse.push(email);
          }
        } catch (error) {
          console.error('Failed to check thread:', error);
        }
      }
    }
    if (needsResponse.length === 0) {
      return {
        summary: 'No emails currently need responses.',
        insights: {
          response_priorities: [],
          response_strategy: [],
          time_estimate: '0 minutes'
        }
      };
    }
    // Generate AI-powered insights about response needs
    try {
      const insights = await this.emailAI.generateResponseNeededInsights(emails, needsResponse);
      return {
        summary: insights.executive_summary,
        insights: {
          response_priorities: insights.response_priorities,
          response_strategy: insights.response_strategy,
          time_estimate: insights.time_estimate,
          total_needing_response: needsResponse.length
        }
      };
    } catch (error) {
      console.error('AI insights generation failed:', error);
      // Fallback to basic summary
      let analysis: EmailAnalysis[] = [];
      if (needsResponse.length > 0) {
        try {
          analysis = await this.emailAI.analyzeEmailImportance(needsResponse);
        } catch (error) {
          console.error('AI analysis failed:', error);
        }
      }
      const responseEmails = needsResponse.map(email => {
        const a = analysis.find(an => an.email_id === email.id);
        return {
          id: email.id,
          subject: email.subject,
          from: email.from[0]?.email,
          importance_score: a?.importance_score || 0.5,
          reason: a?.reason || 'Needs response'
        };
      }).sort((a, b) => b.importance_score - a.importance_score);
      const summary = `${responseEmails.length} emails need responses. ` +
        `${responseEmails.filter(e => e.importance_score > 0.7).length} are high priority.`;
      return {
        summary,
        insights: {
          needs_response: responseEmails
        }
      };
    }
  }
  private async generateAnalytics(timePeriod: string): Promise<any> {
    // Calculate date range
    const now = new Date();
    let daysAgo = 7;
    switch (timePeriod) {
      case 'day':
        daysAgo = 1;
        break;
      case 'week':
        daysAgo = 7;
        break;
      case 'month':
        daysAgo = 30;
        break;
    }
    const startDate = new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
    const startTimestamp = Math.floor(startDate.getTime() / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: startTimestamp,
        limit: 500
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: `No emails found for the past ${timePeriod}.`,
        insights: {
          volume_analysis: {
            trend: 'No activity',
            pattern: 'No emails',
            anomalies: []
          }
        }
      };
    }
    // Calculate analytics
    const senderCounts = new Map<string, number>();
    emails.forEach(email => {
      const sender = email.from[0]?.email;
      if (sender) {
        senderCounts.set(sender, (senderCounts.get(sender) || 0) + 1);
      }
    });
    // Categorize emails
    let categories: Record<string, number> = {};
    try {
      const categoryMap = await this.emailAI.categorizeEmails(emails.slice(0, 100));
      categoryMap.forEach((emailIds, category) => {
        categories[category] = emailIds.length;
      });
    } catch (error) {
      console.error('Categorization failed:', error);
    }
    // Generate AI-powered analytics insights
    try {
      const insights = await this.emailAI.generateAnalyticsInsights(
        emails,
        timePeriod,
        senderCounts,
        categories
      );
      return {
        summary: insights.executive_summary,
        insights: {
          volume_analysis: insights.volume_analysis,
          sender_insights: insights.sender_insights,
          productivity_metrics: insights.productivity_metrics,
          recommendations: insights.recommendations,
          raw_analytics: {
            total_emails: emails.length,
            emails_per_day: emails.length / daysAgo,
            unread_count: emails.filter(e => e.unread).length
          }
        }
      };
    } catch (error) {
      console.error('AI analytics generation failed:', error);
      // Fallback to basic analytics
      const topSenders = Array.from(senderCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([sender]) => sender);
      const analytics = {
        total_emails: emails.length,
        emails_per_day: emails.length / daysAgo,
        top_senders: topSenders,
        categories: categories,
        unread_count: emails.filter(e => e.unread).length
      };
      const summary = `Email analytics for the past ${timePeriod}: ` +
        `${analytics.total_emails} total emails (${analytics.emails_per_day.toFixed(1)}/day). ` +
        `Top sender: ${topSenders[0] || 'None'}.`;
      return {
        summary,
        insights: {
          analytics
        }
      };
    }
  }
  private async analyzeRelationships(): Promise<any> {
    // Get emails from past month
    const thirtyDaysAgo = Math.floor((Date.now() - 30 * 24 * 60 * 60 * 1000) / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedAfter: thirtyDaysAgo,
        limit: 500
      }
    });
    const emails = messages.data as Email[];
    if (emails.length === 0) {
      return {
        summary: 'No emails found to analyze relationships.',
        insights: {
          key_relationships: [],
          communication_patterns: {
            balance_analysis: 'No data available',
            response_patterns: [],
            collaboration_insights: []
          }
        }
      };
    }
    // Analyze communication patterns
    const contactStats = new Map<string, { sent: number; received: number; importance: number }>();
    // First, we need to identify the user's email
    const userEmail = emails.find(e => e.from[0]?.email)?.to?.[0]?.email || 'me@company.com';
    emails.forEach(email => {
      const isFromMe = email.from[0]?.email === userEmail;
      const contact = isFromMe ? email.to?.[0]?.email : email.from[0]?.email;
      if (contact) {
        const stats = contactStats.get(contact) || { sent: 0, received: 0, importance: 0 };
        if (isFromMe) {
          stats.sent++;
        } else {
          stats.received++;
        }
        contactStats.set(contact, stats);
      }
    });
    // Get importance scores for relationships
    try {
      const analysis = await this.emailAI.analyzeEmailImportance(emails.slice(0, 100));
      analysis.forEach(a => {
        const email = emails.find(e => e.id === a.email_id);
        const contact = email?.from[0]?.email;
        if (contact && contactStats.has(contact)) {
          const stats = contactStats.get(contact)!;
          stats.importance += a.importance_score;
          contactStats.set(contact, stats);
        }
      });
    } catch (error) {
      console.error('AI analysis failed:', error);
    }
    // Generate AI-powered relationship insights
    try {
      const insights = await this.emailAI.generateRelationshipInsights(emails, contactStats);
      return {
        summary: insights.executive_summary,
        insights: {
          key_relationships: insights.key_relationships,
          communication_patterns: insights.communication_patterns,
          network_insights: insights.network_insights,
          recommendations: insights.recommendations
        }
      };
    } catch (error) {
      console.error('AI relationship insights generation failed:', error);
      // Fallback to basic analysis
      const relationships = Array.from(contactStats.entries())
        .map(([contact, stats]) => ({
          contact,
          total_interactions: stats.sent + stats.received,
          balance: stats.sent / (stats.received || 1),
          avg_importance: stats.importance / (stats.received || 1)
        }))
        .sort((a, b) => b.total_interactions - a.total_interactions)
        .slice(0, 10);
      const frequentContacts = relationships.slice(0, 5).map(r => r.contact);
      const communicationBalance = relationships.reduce((acc, r) => {
        if (r.balance > 2) return { ...acc, over_communicating: acc.over_communicating + 1 };
        if (r.balance < 0.5) return { ...acc, under_communicating: acc.under_communicating + 1 };
        return { ...acc, balanced: acc.balanced + 1 };
      }, { over_communicating: 0, under_communicating: 0, balanced: 0 });
      const summary = `Analyzed communication patterns with ${contactStats.size} contacts. ` +
        `Most frequent: ${frequentContacts[0] || 'None'}.`;
      return {
        summary,
        insights: {
          relationships: {
            frequent_contacts: frequentContacts,
            communication_balance: communicationBalance,
            top_relationships: relationships.slice(0, 5)
          }
        }
      };
    }
  }
}
</file>

<file path="tools/findEmails.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { 
  FindEmailsParams, 
  Email, 
  EmailAnalysis,
  ActionItem,
  EmailIntent
} from '../types';
export class FindEmailsTool {
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: FindEmailsParams): Promise<any> {
    try {
      // Use AI to understand the search query
      const searchIntent = await this.emailAI.understandSearchQuery(params.query);
      // Build Nylas search parameters from AI understanding
      const queryParams = await this.buildSearchParamsFromIntent(searchIntent);
      queryParams.limit = params.limit || 2;
      // Search emails
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams
      });
      const emails = messages.data as Email[];
      // Handle empty results
      if (emails.length === 0) {
        return {
          emails: [],
          summary: 'No emails found matching your query.',
          total_count: 0
        };
      }
      // Perform analysis based on type
      let result: any = {
        emails,
        total_count: emails.length
      };
      switch (params.analysis_type) {
        case 'summary':
          // Summary only - no email content, just AI-powered natural language summary
          console.log(`Generating AI summary for ${emails.length} emails...`);
          try {
            const aiSummary = await this.emailAI.generateAggregatedSummary(emails);
            console.log('AI summary generated successfully');
            return {
              summary: aiSummary,
              total_count: emails.length,
              query: params.query
            };
          } catch (error) {
            console.error('AI summary generation failed:', error);
            // Fallback to basic summary if AI fails
            const basicSummary = await this.generateBasicSummary(emails, params.query);
            return {
              summary: basicSummary,
              total_count: emails.length,
              query: params.query
            };
          }
        case 'full':
          // Full email content without any analysis
          // Already set in result initialization
          break;
        case 'detailed':
          try {
            const analysis = await this.emailAI.analyzeEmailImportance(emails);
            result.analysis = analysis;
            result.summary = this.generateDetailedSummary(emails, analysis);
          } catch (error) {
            console.error('AI analysis failed:', error);
            // Simple summary when AI fails
            result.summary = `Found ${emails.length} email${emails.length !== 1 ? 's' : ''} matching "${params.query}".`;
          }
          break;
        case 'action_items':
          const actionAnalysis = await this.emailAI.analyzeEmailImportance(emails);
          const actionItems = await this.extractAllActionItems(emails);
          result.analysis = actionAnalysis;
          result.action_items = actionItems;
          result.summary = this.generateActionSummary(emails, actionItems);
          // Filter to only emails that need response if query mentions it
          if (params.query.toLowerCase().includes('respond') || 
              params.query.toLowerCase().includes('reply')) {
            result.emails = await this.filterUnrepliedEmails(emails);
            result.total_count = result.emails.length;
          }
          break;
        case 'priority':
          const priorityAnalysis = await this.emailAI.analyzeEmailImportance(emails);
          // Sort by importance score
          const sortedAnalysis = priorityAnalysis.sort(
            (a, b) => b.importance_score - a.importance_score
          );
          result.analysis = sortedAnalysis;
          result.emails = this.sortEmailsByAnalysis(emails, sortedAnalysis);
          result.summary = this.generatePrioritySummary(emails, sortedAnalysis);
          break;
        default:
          // Default to 'full' - return full emails without analysis
          // Already set in result initialization
      }
      return result;
    } catch (error: any) {
      throw new Error(`Failed to find emails: ${error.message}`);
    }
  }
  private async buildSearchParamsFromIntent(searchIntent: any): Promise<any> {
    const params: any = {};
    // Apply filters from AI understanding
    if (searchIntent.filters) {
      if (searchIntent.filters.unread !== undefined) {
        params.unread = searchIntent.filters.unread;
      }
      if (searchIntent.filters.starred !== undefined) {
        params.starred = searchIntent.filters.starred;
      }
      if (searchIntent.filters.hasAttachments !== undefined) {
        params.hasAttachment = searchIntent.filters.hasAttachments;
      }
    }
    // Apply timeframe
    if (searchIntent.timeframe) {
      if (searchIntent.timeframe.start) {
        const startTime = searchIntent.timeframe.start.getTime();
        if (!isNaN(startTime)) {
          params.receivedAfter = Math.floor(startTime / 1000);
        }
      }
      if (searchIntent.timeframe.end) {
        const endTime = searchIntent.timeframe.end.getTime();
        if (!isNaN(endTime)) {
          params.receivedBefore = Math.floor(endTime / 1000);
        }
      }
    }
    // Build search query from AI understanding
    const searchParts: string[] = [];
    // Add senders
    if (searchIntent.senders && searchIntent.senders.length > 0) {
      searchIntent.senders.forEach((sender: string) => {
        searchParts.push(`from:${sender}`);
      });
    }
    // Add keywords
    if (searchIntent.keywords && searchIntent.keywords.length > 0) {
      searchParts.push(...searchIntent.keywords);
    }
    if (searchParts.length > 0) {
      params.searchQueryNative = searchParts.join(' ');
    }
    return params;
  }
  private async filterUnrepliedEmails(emails: Email[]): Promise<Email[]> {
    const unreplied: Email[] = [];
    for (const email of emails) {
      if (email.thread_id) {
        try {
          // Check if thread has replies from us
          const thread = await this.nylas.threads.find({
            identifier: this.grantId,
            threadId: email.thread_id
          });
          // Simple check: if thread has only one message, it's unreplied
          if (thread.data.messageIds && thread.data.messageIds.length === 1) {
            unreplied.push(email);
          }
        } catch (error) {
          console.error(`Failed to check thread ${email.thread_id}:`, error);
          // Include email if we can't check
          unreplied.push(email);
        }
      } else {
        // No thread means single email, likely unreplied
        unreplied.push(email);
      }
    }
    return unreplied;
  }
  private async extractAllActionItems(emails: Email[]): Promise<ActionItem[]> {
    const allActionItems: ActionItem[] = [];
    for (const email of emails) {
      try {
        const items = await this.emailAI.extractActionItems(email);
        allActionItems.push(...items);
      } catch (error) {
        console.error(`Failed to extract action items from email ${email.id}:`, error);
      }
    }
    return allActionItems;
  }
  private async generateBasicSummary(emails: Email[], query: string): Promise<string> {
    const count = emails.length;
    const unreadCount = emails.filter(e => e.unread).length;
    const starredCount = emails.filter(e => e.starred).length;
    let summary = `Found ${count} email${count !== 1 ? 's' : ''} matching "${query}"`;
    const details: string[] = [];
    if (unreadCount > 0) details.push(`${unreadCount} unread`);
    if (starredCount > 0) details.push(`${starredCount} starred`);
    if (details.length > 0) {
      summary += ` (${details.join(', ')})`;
    }
    summary += '.';
    // Add sender information
    if (emails.length > 0) {
      const senders = emails.slice(0, 3).map(e => 
        e.from[0]?.name || e.from[0]?.email?.split('@')[0] || 'Unknown'
      );
      summary += ` From: ${senders.join(', ')}`;
      if (emails.length > 3) {
        summary += ` and ${emails.length - 3} others`;
      }
      summary += '.';
    }
    return summary;
  }
  private generateDetailedSummary(emails: Email[], analysis: EmailAnalysis[]): string {
    const count = emails.length;
    const importantCount = analysis.filter(a => a.importance_score > 0.7).length;
    const actionRequired = analysis.filter(a => a.action_required).length;
    const categories = analysis.reduce((acc, a) => {
      acc[a.category] = (acc[a.category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    let summary = `Analyzed ${count} emails: `;
    summary += `${importantCount} important, `;
    summary += `${actionRequired} need action. `;
    summary += `By category: ${Object.entries(categories)
      .map(([cat, cnt]) => `${cat.replace('_', ' ')} (${cnt})`)
      .join(', ')}.`;
    return summary;
  }
  private generateActionSummary(emails: Email[], actionItems: ActionItem[]): string {
    const highPriority = actionItems.filter(a => a.priority === 'high').length;
    const withDeadlines = actionItems.filter(a => a.deadline).length;
    let summary = `Found ${emails.length} emails with ${actionItems.length} action items`;
    const details: string[] = [];
    if (highPriority > 0) details.push(`${highPriority} high priority`);
    if (withDeadlines > 0) details.push(`${withDeadlines} with deadlines`);
    if (details.length > 0) {
      summary += ` (${details.join(', ')})`;
    }
    summary += '.';
    return summary;
  }
  private generatePrioritySummary(emails: Email[], analysis: EmailAnalysis[]): string {
    const topPriority = analysis.slice(0, 3);
    const names = topPriority
      .map(a => {
        const email = emails.find(e => e.id === a.email_id);
        return email?.from[0]?.name || email?.from[0]?.email?.split('@')[0] || 'Unknown';
      })
      .join(', ');
    return `${emails.length} emails sorted by priority. Most important from: ${names}.`;
  }
  private sortEmailsByAnalysis(emails: Email[], analysis: EmailAnalysis[]): Email[] {
    const emailMap = new Map(emails.map(e => [e.id, e]));
    const sortedEmails: Email[] = [];
    // First add emails in order of analysis (already sorted by importance)
    for (const a of analysis) {
      const email = emailMap.get(a.email_id);
      if (email) {
        sortedEmails.push(email);
        emailMap.delete(a.email_id);
      }
    }
    // Add any remaining emails
    sortedEmails.push(...emailMap.values());
    return sortedEmails;
  }
}
</file>

<file path="tools/manageEmail.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI.js';
// ApprovalManager removed - using stateless approval flow
import {
  ManageEmailParams,
  Email,
  EmailIntent,
  GeneratedEmail,
  ApprovalRequiredResponse
} from '../types/index.js';
export class ManageEmailTool {
  private senderInfo: { email?: string; name?: string } | null = null;
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI,
    private userContext?: { userName?: string; userEmail?: string }
  ) {
    // Initialize sender info from user context if available
    if (userContext?.userName || userContext?.userEmail) {
      this.senderInfo = {
        email: userContext.userEmail || 'sender@email.com',
        name: userContext.userName || (userContext.userEmail ? userContext.userEmail.split('@')[0] : 'Sender')
      };
      console.log('üìß Sender info from context:', this.senderInfo);
    }
  }
  async execute(params: ManageEmailParams): Promise<any> {
    console.log('[manage_email] execute called with action:', params.action, 'require_approval:', params.require_approval);
    // Check if this is an approved action execution
    if (params.approved && params.action_data) {
      return this.executeApprovedAction(params);
    }
    // Get sender info if not cached (skip if already set from context)
    if (!this.senderInfo) {
      await this.fetchSenderInfo();
    }
    try {
      // Process the natural language query
      const context = await this.getContext(params);
      // Fast-path: if the query already contains one or more email addresses and we're not executing immediately,
      // avoid an AI call and synthesize an intent directly.
      const emailMatches = Array.from(params.query.matchAll(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/ig)).map(m => m[0]);
      console.log('[manage_email] detected emails in query:', emailMatches);
      const hasDirectEmails = emailMatches.length > 0;
      if (hasDirectEmails) {
        console.log('üõ£Ô∏è  Fast-path: detected direct email addresses in query ‚Üí skipping AI intent extraction');
      }
      const intent: EmailIntent = hasDirectEmails ? {
        intent: params.action,
        recipients: emailMatches,
        subject: '',
        key_points: [params.query],
        urgency: 'normal',
        tone: 'professional'
      } as any : await this.emailAI.understandQuery(params.query, context);
      console.log('[manage_email] intent prepared. recipients:', intent.recipients);
      // Generate email content based on intent
      const emailContent = await this.generateContent(intent, params, context);
      console.log('[manage_email] generated content recipients:', emailContent.to);
      // Handle different actions
      switch (params.action) {
        case 'send':
        case 'reply':
        case 'forward':
          if (params.require_approval !== false) {
            return this.createStatelessApprovalRequest(emailContent, params, intent);
          } else {
            return this.sendEmail(emailContent);
          }
        case 'draft':
          return this.createDraft(emailContent);
        default:
          throw new Error(`Unknown action: ${params.action}`);
      }
    } catch (error: any) {
      // Check if it's a contact resolution error
      if (error.message && error.message.includes('Could not find email addresses for:')) {
        // Return a user-friendly error response
        return {
          success: false,
          error: 'contact_not_found',
          message: error.message,
          suggestions: [
            'Use the full email address (e.g., sarah@example.com)',
            'Check if the contact exists in your address book',
            'Try a more specific name if multiple people share the same first name'
          ]
        };
      }
      // Re-throw other errors
      throw error;
    }
  }
  private async getContext(params: ManageEmailParams): Promise<any> {
    if (params.action === 'reply' || params.action === 'forward') {
      let originalMessage: Email | null = null;
      if (params.context_message_id) {
        // Fetch the specific message
        const message = await this.nylas.messages.find({
          identifier: this.grantId,
          messageId: params.context_message_id
        });
        originalMessage = message.data as Email;
      } else if (params.action === 'reply') {
        // Try to find the most recent relevant message
        originalMessage = await this.findRelevantMessage(params.query);
      }
      if (originalMessage && params.action === 'reply') {
        return {
          senderEmail: originalMessage.from[0]?.email,
          originalMessage
        };
      } else if (originalMessage && params.action === 'forward') {
        return { originalMessage };
      }
    }
    return undefined;
  }
  private async findRelevantMessage(query: string): Promise<Email | null> {
    // Extract possible sender names from query
    const senderMatch = query.match(/(?:reply to|respond to)\s+(\w+)/i);
    if (!senderMatch) return null;
    const senderName = senderMatch[1];
    try {
      // First, try to find contacts with this name
      const contacts = await this.lookupContactsByName(senderName);
      if (contacts.length > 0) {
        // Search for messages from the resolved email addresses
        for (const contact of contacts) {
          const messages = await this.nylas.messages.list({
            identifier: this.grantId,
            queryParams: {
              from: [contact.email],
              limit: 5
            }
          });
          if (messages.data.length > 0) {
            // Get full message details
            const fullMessage = await this.nylas.messages.find({
              identifier: this.grantId,
              messageId: messages.data[0].id
            });
            console.log(`‚úÖ Found message from ${contact.name} (${contact.email})`);
            return fullMessage.data as Email;
          }
        }
      }
      // Fallback: Try searching by name in the message content
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: {
          searchQueryNative: `from:${senderName}`,
          limit: 5
        }
      });
      if (messages.data.length > 0) {
        // Get full message details
        const fullMessage = await this.nylas.messages.find({
          identifier: this.grantId,
          messageId: messages.data[0].id
        });
        return fullMessage.data as Email;
      }
    } catch (error) {
      console.error('Error finding relevant message:', error);
    }
    return null;
  }
  private async lookupContactByEmail(email: string): Promise<string | null> {
    try {
      // Search for contacts with the specific email address
      const contacts = await this.nylas.contacts.list({
        identifier: this.grantId,
        queryParams: {
          email: email  // Use Nylas API's email search parameter
        }
      });
      if (contacts.data.length > 0) {
        const matchingContact = contacts.data[0];
        // Build full name from available parts
        const nameParts = [
          matchingContact.givenName,
          matchingContact.middleName,
          matchingContact.surname
        ].filter(Boolean);
        if (nameParts.length > 0) {
          return nameParts.join(' ');
        }
        // Fallback to nickname if no formal name parts
        if (matchingContact.nickname) {
          return matchingContact.nickname;
        }
        // Fallback to display name
        if (matchingContact.displayName && matchingContact.displayName !== email) {
          return matchingContact.displayName;
        }
      }
      // If not found in address book, try inbox source
      const inboxContacts = await this.nylas.contacts.list({
        identifier: this.grantId,
        queryParams: {
          email: email,
          source: 'inbox' as any  // Search contacts from email interactions
        }
      });
      if (inboxContacts.data.length > 0) {
        const contact = inboxContacts.data[0];
        if (contact.displayName && contact.displayName !== email) {
          return contact.displayName;
        }
      }
    } catch (error) {
      console.error('Error looking up contact:', error);
    }
    return null;
  }
  private async lookupContactsByName(name: string): Promise<Array<{ email: string; name: string }>> {
    const results: Array<{ email: string; name: string }> = [];
    const searchName = name.toLowerCase().trim();
    try {
      // Search in all three sources: address_book, domain, and inbox
      const sources = ['address_book', 'domain', 'inbox'] as const;
      for (const source of sources) {
        try {
          // Fetch contacts from each source with a reasonable limit
          const contacts = await this.nylas.contacts.list({
            identifier: this.grantId,
            queryParams: {
              source: source as any,
              limit: 100  // Reasonable limit to avoid too many API calls
            }
          });
          // Search through each contact's name fields
          for (const contact of contacts.data) {
            const emails = contact.emails || [];
            if (emails.length === 0) continue;
            // Build possible name variations to search
            const nameVariations: string[] = [];
            // Full name from parts
            const nameParts = [
              contact.givenName,
              contact.middleName,
              contact.surname
            ].filter(Boolean);
            if (nameParts.length > 0) {
              nameVariations.push(nameParts.join(' '));
            }
            // Individual name parts
            if (contact.givenName) nameVariations.push(contact.givenName);
            if (contact.surname) nameVariations.push(contact.surname);
            if (contact.nickname) nameVariations.push(contact.nickname);
            if (contact.displayName) nameVariations.push(contact.displayName);
            // Check if any name variation matches our search
            const matches = nameVariations.some(variation =>
              variation.toLowerCase().includes(searchName) ||
              searchName.includes(variation.toLowerCase())
            );
            if (matches) {
              // Get the best display name for this contact
              const displayName = contact.displayName ||
                (nameParts.length > 0 ? nameParts.join(' ') : null) ||
                contact.nickname ||
                contact.givenName ||
                emails[0].email;
              // Add all email addresses for this contact
              for (const email of emails) {
                if (email.email) {
                  results.push({
                    email: email.email,
                    name: displayName
                  });
                }
              }
            }
          }
        } catch (error) {
          console.error(`Error fetching contacts from source ${source}:`, error);
          // Continue with other sources even if one fails
        }
      }
      // Remove duplicates based on email
      const uniqueResults = Array.from(
        new Map(results.map(item => [item.email, item])).values()
      );
      return uniqueResults;
    } catch (error) {
      console.error('Error looking up contacts by name:', error);
      return [];
    }
  }
  private async fetchSenderInfo(): Promise<void> {
    try {
      // Fetch grant information to get sender's email
      const grant = await this.nylas.grants.find({
        grantId: this.grantId
      });
      if (grant.data.email) {
        this.senderInfo = {
          email: grant.data.email,
          name: grant.data.email.split('@')[0] // Default to email prefix
        };
        // Try to get the actual name from contacts
        const senderName = await this.lookupContactByEmail(grant.data.email);
        if (senderName) {
          this.senderInfo.name = senderName;
        }
        console.log('üìß Sender info:', this.senderInfo);
      }
    } catch (error) {
      console.error('Error fetching sender info:', error);
      // Default sender info if we can't fetch it
      this.senderInfo = {
        email: 'sender@email.com',
        name: 'Sender'
      };
    }
  }
  private async generateContent(
    intent: EmailIntent,
    params: ManageEmailParams,
    context?: any
  ): Promise<GeneratedEmail> {
    const originalMessage = context?.originalMessage;
    // First, resolve any name-based recipients to email addresses
    const resolvedRecipients: string[] = [];
    const unresolvedNames: string[] = [];
    if (intent.recipients && intent.recipients.length > 0) {
      for (const recipient of intent.recipients) {
        // If full email is provided, accept it without contact lookups
        if (recipient.includes('@')) {
          resolvedRecipients.push(recipient);
          continue;
        }
        // Name-only: attempt contact resolution, but handle lack of scopes gracefully
        try {
          const contacts = await this.lookupContactsByName(recipient);
          if (contacts.length === 0) {
            unresolvedNames.push(recipient);
          } else if (contacts.length === 1) {
            resolvedRecipients.push(contacts[0].email);
            console.log(`‚úÖ Resolved "${recipient}" to ${contacts[0].email}`);
          } else {
            resolvedRecipients.push(contacts[0].email);
            console.log(`‚ö†Ô∏è Multiple contacts found for "${recipient}", using ${contacts[0].email}`);
            console.log('Other matches:', contacts.slice(1).map(c => `${c.name} (${c.email})`).join(', '));
          }
        } catch (err: any) {
          // If contacts API is forbidden due to missing scopes, treat as unresolved
          if (err?.statusCode === 403 || /insufficient authentication scopes/i.test(err?.message || '')) {
            unresolvedNames.push(recipient);
          } else {
            throw err;
          }
        }
      }
    }
    // If we couldn't resolve some names, throw an error
    if (unresolvedNames.length > 0) {
      throw new Error(`Could not find email addresses for: ${unresolvedNames.join(', ')}. Please use full email addresses or ensure the contacts exist in your address book.`);
    }
    // Update intent with resolved email addresses
    intent.recipients = resolvedRecipients;
    // Fast-path: if we have concrete recipients and this is an approval/draft flow,
    // synthesize a reasonable email without invoking the AI to avoid external failures.
    if (params.require_approval !== false && intent.recipients.length > 0) {
      const synthetic: GeneratedEmail = {
        to: intent.recipients,
        cc: undefined,
        bcc: undefined,
        subject: intent.subject || 'Review email draft',
        body: `Hello,\n\n${intent.key_points?.join(' ') || 'Here is a proposed message.'}\n\nBest,\n${this.senderInfo?.name || 'Me'}`,
        tone_confirmation: undefined
      } as GeneratedEmail;
      // Add reply/forward context if applicable
      if (params.action === 'reply' && originalMessage) {
        (synthetic as any).in_reply_to = originalMessage.id;
        if (!synthetic.subject.startsWith('Re:')) {
          synthetic.subject = `Re: ${originalMessage.subject}`;
        }
      } else if (params.action === 'forward' && originalMessage) {
        if (!synthetic.subject.startsWith('Fwd:')) {
          synthetic.subject = `Fwd: ${originalMessage.subject}`;
        }
        synthetic.body += `\n\n--- Original Message ---\n${originalMessage.body || originalMessage.snippet}`;
      }
      return synthetic;
    }
    // Lookup contact names for recipients (to get proper display names)
    const recipientNames: { [email: string]: string } = {};
    if (intent.recipients && intent.recipients.length > 0) {
      await Promise.all(
        intent.recipients.map(async (email) => {
          const contactName = await this.lookupContactByEmail(email);
          if (contactName) {
            recipientNames[email] = contactName;
          }
        })
      );
    }
    let generatedEmail: GeneratedEmail;
    try {
      generatedEmail = await this.emailAI.generateEmailContent(
        intent,
        originalMessage,
        recipientNames,
        this.senderInfo
      );
    } catch (err: any) {
      console.error('AI content generation failed, using fallback:', err?.message || err);
      generatedEmail = {
        to: intent.recipients,
        subject: intent.subject || 'Draft email',
        body: `Hello,\n\n${intent.key_points?.join(' ') || 'Here is my message.'}\n\nBest,\n${this.senderInfo?.name || 'Me'}`,
        cc: undefined,
        bcc: undefined,
        tone_confirmation: undefined
      } as GeneratedEmail;
    }
    // Add reply/forward specific handling
    if (params.action === 'reply' && originalMessage) {
      generatedEmail.in_reply_to = originalMessage.id;
      if (!generatedEmail.subject.startsWith('Re:')) {
        generatedEmail.subject = `Re: ${originalMessage.subject}`;
      }
    } else if (params.action === 'forward' && originalMessage) {
      if (!generatedEmail.subject.startsWith('Fwd:')) {
        generatedEmail.subject = `Fwd: ${originalMessage.subject}`;
      }
      // Append original message to body
      generatedEmail.body += `\n\n--- Original Message ---\n${originalMessage.body || originalMessage.snippet}`;
    }
    return generatedEmail;
  }
  private async createStatelessApprovalRequest(
    emailContent: GeneratedEmail,
    params: ManageEmailParams,
    intent: EmailIntent
  ): Promise<ApprovalRequiredResponse> {
    return {
      needs_approval: true,
      action_type: 'send_email',
      action_data: {
        email_content: emailContent,
        original_params: {
          action: params.action,
          query: params.query,
          context_message_id: params.context_message_id
        },
        intent: intent
      },
      preview: {
        summary: `${params.action.charAt(0).toUpperCase() + params.action.slice(1)} email to ${emailContent.to.join(', ')}`,
        details: {
          to: emailContent.to,
          cc: emailContent.cc,
          bcc: emailContent.bcc,
          subject: emailContent.subject,
          body: emailContent.body,
          action: params.action,
          tone: intent.tone,
          urgency: intent.urgency
        },
        risks: this.assessEmailRisks(emailContent, params)
      }
    };
  }
  private assessEmailRisks(emailContent: GeneratedEmail, params: ManageEmailParams): string[] {
    const risks: string[] = [];
    // Check for multiple recipients
    const totalRecipients = emailContent.to.length +
      (emailContent.cc?.length || 0) +
      (emailContent.bcc?.length || 0);
    if (totalRecipients > 5) {
      risks.push(`Sending to ${totalRecipients} recipients`);
    }
    // Check for external domains
    const internalDomain = process.env.INTERNAL_EMAIL_DOMAIN;
    if (internalDomain) {
      const externalRecipients = emailContent.to.filter(email =>
        !email.endsWith(`@${internalDomain}`)
      );
      if (externalRecipients.length > 0) {
        risks.push('Contains external recipients');
      }
    }
    // Check for reply-all scenarios
    if (params.action === 'reply' && totalRecipients > 2) {
      risks.push('Reply-all to multiple recipients');
    }
    return risks;
  }
  private async executeApprovedAction(params: ManageEmailParams): Promise<any> {
    if (!params.action_data?.email_content) {
      throw new Error('Missing email content in approved action');
    }
    const { email_content } = params.action_data;
    try {
      const result = await this.sendEmail(email_content);
      return {
        ...result,
        approval_executed: true
      };
    } catch (error: any) {
      throw new Error(`Failed to execute approved email action: ${error.message}`);
    }
  }
  // Legacy approval request method removed
  private async sendEmail(emailContent: GeneratedEmail): Promise<any> {
    try {
      // Simple HTML: just replace newlines with <br> tags
      const htmlBody = emailContent.body
        .replace(/\n\n/g, '<br><br>')  // Double newline = paragraph break
        .replace(/\n/g, '<br>');        // Single newline = line break
      const message = await this.nylas.messages.send({
        identifier: this.grantId,
        requestBody: {
          to: emailContent.to.map(email => ({ email })),
          cc: emailContent.cc?.map(email => ({ email })),
          bcc: emailContent.bcc?.map(email => ({ email })),
          subject: emailContent.subject,
          body: htmlBody,
          replyToMessageId: emailContent.in_reply_to
        }
      });
      return {
        success: true,
        message_id: message.data.id,
        message: 'Email sent successfully'
      };
    } catch (error: any) {
      throw new Error(`Failed to send email: ${error.message}`);
    }
  }
  private async createDraft(emailContent: GeneratedEmail): Promise<any> {
    try {
      // Simple HTML: just replace newlines with <br> tags
      const htmlBody = emailContent.body
        .replace(/\n\n/g, '<br><br>')  // Double newline = paragraph break
        .replace(/\n/g, '<br>');        // Single newline = line break
      const draft = await this.nylas.drafts.create({
        identifier: this.grantId,
        requestBody: {
          to: emailContent.to.map(email => ({ email })),
          cc: emailContent.cc?.map(email => ({ email })),
          bcc: emailContent.bcc?.map(email => ({ email })),
          subject: emailContent.subject,
          body: htmlBody
        }
      });
      return {
        success: true,
        draft_id: draft.data.id,
        message: 'Draft created successfully'
      };
    } catch (error: any) {
      throw new Error(`Failed to create draft: ${error.message}`);
    }
  }
}
</file>

<file path="tools/organizeInbox.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { 
  OrganizeInboxParams, 
  Email, 
  EmailAnalysis,
  ApprovalRequiredResponse
} from '../types';
export class OrganizeInboxTool {
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: OrganizeInboxParams): Promise<any> {
    // Check if this is an approved action execution
    if (params.approved && params.action_data) {
      return this.executeApprovedOrganization(params);
    }
    // First, always run in preview mode to gather the plan
    const planResult = await this.createOrganizationPlan(params);
    // If dry_run is true or there are no actions, return the preview
    if (params.dry_run || planResult.total_actions === 0) {
      return planResult;
    }
    // Otherwise, return an approval request
    return this.createApprovalRequest(planResult, params);
  }
  private async createOrganizationPlan(params: OrganizeInboxParams): Promise<any> {
    const result = {
      organized_count: 0,
      actions_taken: [] as string[],
      preview_actions: [] as string[],
      errors: [] as string[],
      total_actions: 0,
      organization_plan: null as any
    };
    try {
      // Use AI to understand the organization instruction
      const intent = await this.emailAI.understandOrganizationIntent(params.instruction);
      // Get emails to organize
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: {
          limit: params.scope?.limit || 100
        }
      });
      const emails = messages.data as Email[];
      // Apply each AI-generated rule to the emails
      for (const email of emails) {
        for (const rule of intent.rules) {
          if (this.emailMatchesCondition(email, rule.condition)) {
            const action = `${rule.action} email "${email.subject}" from ${email.from[0]?.email}`;
            if (rule.target) {
              result.preview_actions.push(`${action} to folder "${rule.target}"`);
            } else {
              result.preview_actions.push(action);
            }
            result.organized_count++;
            break; // Only apply first matching rule
          }
        }
      }
      result.organization_plan = intent;
      result.total_actions = result.preview_actions.length;
    } catch (error: any) {
      result.errors.push(`Organization planning failed: ${error.message}`);
    }
    return result;
  }
  private createApprovalRequest(
    planResult: any,
    params: OrganizeInboxParams
  ): ApprovalRequiredResponse {
    const actionSummary = this.summarizeActions(planResult.preview_actions);
    return {
      needs_approval: true,
      action_type: 'organize_inbox',
      action_data: {
        organization_plan: planResult,
        original_params: params
      },
      preview: {
        summary: `Organize ${planResult.total_actions} emails based on: "${params.instruction}"`,
        details: {
          instruction: params.instruction,
          total_actions: planResult.total_actions,
          actions_by_type: actionSummary,
          preview_actions: planResult.preview_actions.slice(0, 10), // First 10 for preview
          organization_rules: planResult.organization_plan?.rules || []
        },
        risks: this.assessOrganizationRisks(planResult, params)
      }
    };
  }
  private summarizeActions(actions: string[]): Record<string, number> {
    const summary: Record<string, number> = {};
    actions.forEach(action => {
      if (action.includes('move')) summary.move = (summary.move || 0) + 1;
      if (action.includes('archive')) summary.archive = (summary.archive || 0) + 1;
      if (action.includes('star')) summary.star = (summary.star || 0) + 1;
      if (action.includes('mark')) summary.mark_read = (summary.mark_read || 0) + 1;
      if (action.includes('delete')) summary.delete = (summary.delete || 0) + 1;
    });
    return summary;
  }
  private assessOrganizationRisks(
    planResult: any,
    params: OrganizeInboxParams
  ): string[] {
    const risks: string[] = [];
    if (planResult.total_actions > 50) {
      risks.push(`Large number of emails will be affected (${planResult.total_actions})`);
    }
    const deleteCount = planResult.preview_actions.filter((a: string) => 
      a.toLowerCase().includes('delete')
    ).length;
    if (deleteCount > 0) {
      risks.push(`${deleteCount} emails will be permanently deleted`);
    }
    // Always warn about AI interpretation since we're using natural language
    risks.push('AI-interpreted organization rules based on your instruction');
    return risks;
  }
  private async executeApprovedOrganization(params: OrganizeInboxParams): Promise<any> {
    if (!params.action_data?.organization_plan || !params.action_data?.original_params) {
      throw new Error('Missing organization plan in approved action');
    }
    const { organization_plan } = params.action_data;
    const result = {
      organized_count: 0,
      actions_taken: [] as string[],
      errors: [] as string[]
    };
    try {
      // Execute the organization plan that was generated during preview
      await this.executeOrganizationPlan(organization_plan, result);
      return {
        ...result,
        approval_executed: true,
        message: `Successfully organized ${result.organized_count} emails`
      };
    } catch (error: any) {
      throw new Error(`Failed to execute approved organization: ${error.message}`);
    }
  }
  private async executeOrganizationPlan(
    plan: any,
    result: any
  ): Promise<void> {
    try {
      // Get emails to organize
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams: {
          limit: 100
        }
      });
      const emails = messages.data as Email[];
      const folders = await this.getFolderMap();
      // Apply each rule from the plan
      for (const email of emails) {
        for (const rule of plan.rules || []) {
          if (this.emailMatchesCondition(email, rule.condition)) {
            switch (rule.action.toLowerCase()) {
              case 'move to folder':
                if (rule.target) {
                  const folderId = await this.ensureFolder(rule.target, folders);
                  await this.moveToFolder(email.id, folderId);
                  result.actions_taken.push(`Moved "${email.subject}" to ${rule.target}`);
                  result.organized_count++;
                }
                break;
              case 'archive':
                const archiveFolderId = await this.getArchiveFolderId();
                await this.moveToFolder(email.id, archiveFolderId);
                result.actions_taken.push(`Archived "${email.subject}"`);
                result.organized_count++;
                break;
              case 'star':
              case 'flag':
                await this.starEmail(email.id);
                result.actions_taken.push(`Starred "${email.subject}"`);
                result.organized_count++;
                break;
              case 'mark read':
              case 'mark as read':
                await this.markAsRead(email.id);
                result.actions_taken.push(`Marked "${email.subject}" as read`);
                result.organized_count++;
                break;
              case 'delete':
                await this.deleteEmail(email.id);
                result.actions_taken.push(`Deleted "${email.subject}"`);
                result.organized_count++;
                break;
            }
            break; // Only apply first matching rule per email
          }
        }
      }
    } catch (error: any) {
      throw new Error(`Organization execution failed: ${error.message}`);
    }
  }
  private emailMatchesCondition(email: Email, condition: string): boolean {
    const lowerCondition = condition.toLowerCase();
    // Check subject contains
    if (lowerCondition.includes('subject contains')) {
      const searchTerm = lowerCondition.split('subject contains')[1].trim();
      return email.subject.toLowerCase().includes(searchTerm);
    }
    // Check from email
    if (lowerCondition.includes('from')) {
      const searchTerm = lowerCondition.split('from')[1].trim();
      return email.from.some(f => 
        f.email.toLowerCase().includes(searchTerm) ||
        (f.name && f.name.toLowerCase().includes(searchTerm))
      );
    }
    // Check if unread
    if (lowerCondition === 'unread') {
      return email.unread === true;
    }
    // Check if starred
    if (lowerCondition === 'starred' || lowerCondition === 'important') {
      return email.starred === true;
    }
    // Check date conditions
    if (lowerCondition.includes('older than')) {
      const daysMatch = lowerCondition.match(/older than (\d+) days?/);
      if (daysMatch && email.date) {
        const days = parseInt(daysMatch[1]);
        const cutoffTime = Date.now() - (days * 24 * 60 * 60 * 1000);
        return email.date * 1000 < cutoffTime;
      }
    }
    // Default: check if any part of the email contains the condition text
    return email.subject.toLowerCase().includes(lowerCondition) ||
           email.snippet?.toLowerCase().includes(lowerCondition) || false;
  }
  private async getFolderMap(): Promise<Map<string, string>> {
    const folders = await this.nylas.folders.list({
      identifier: this.grantId
    });
    const folderMap = new Map<string, string>();
    folders.data.forEach(folder => {
      folderMap.set(folder.name.toLowerCase(), folder.id);
    });
    return folderMap;
  }
  private async ensureFolder(name: string, folderMap: Map<string, string>): Promise<string> {
    const lowerName = name.toLowerCase();
    if (folderMap.has(lowerName)) {
      return folderMap.get(lowerName)!;
    }
    try {
      // Create the folder
      const newFolder = await this.nylas.folders.create({
        identifier: this.grantId,
        requestBody: {
          name: name
        }
      });
      const folderId = newFolder.data.id;
      folderMap.set(lowerName, folderId);
      return folderId;
    } catch (error: any) {
      throw new Error(`Failed to create folder ${name}: ${error.message}`);
    }
  }
  private async getArchiveFolderId(): Promise<string> {
    const folders = await this.nylas.folders.list({
      identifier: this.grantId
    });
    const archiveFolder = folders.data.find(f => 
      f.attributes?.includes('\\Archive') || 
      f.name.toLowerCase() === 'archive'
    );
    if (!archiveFolder) {
      throw new Error('Archive folder not found');
    }
    return archiveFolder.id;
  }
  private async moveToFolder(messageId: string, folderId: string): Promise<void> {
    await this.nylas.messages.update({
      identifier: this.grantId,
      messageId,
      requestBody: {
        folders: [folderId]
      }
    });
  }
  private async starEmail(messageId: string): Promise<void> {
    await this.nylas.messages.update({
      identifier: this.grantId,
      messageId,
      requestBody: {
        starred: true
      }
    });
  }
  private async markAsRead(messageId: string): Promise<void> {
    await this.nylas.messages.update({
      identifier: this.grantId,
      messageId,
      requestBody: {
        unread: false
      }
    });
  }
  private async deleteEmail(messageId: string): Promise<void> {
    await this.nylas.messages.destroy({
      identifier: this.grantId,
      messageId
    });
  }
  private async findOldEmails(): Promise<Email[]> {
    const thirtyDaysAgo = Math.floor((Date.now() - 30 * 24 * 60 * 60 * 1000) / 1000);
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams: {
        receivedBefore: thirtyDaysAgo,
        unread: false,
        limit: 50
      }
    });
    return messages.data as Email[];
  }
  private async findEmailsByCondition(condition: string): Promise<Email[]> {
    const queryParams: any = {};
    // Parse condition
    if (condition.startsWith('from:')) {
      const from = condition.substring(5);
      queryParams.searchQueryNative = `from:${from}`;
    } else if (condition === 'older_than:30d') {
      const thirtyDaysAgo = Math.floor((Date.now() - 30 * 24 * 60 * 60 * 1000) / 1000);
      queryParams.receivedBefore = thirtyDaysAgo;
    } else {
      queryParams.searchQueryNative = condition;
    }
    const messages = await this.nylas.messages.list({
      identifier: this.grantId,
      queryParams
    });
    return messages.data as Email[];
  }
  private filterEmailsByCondition(emails: Email[], condition: string): Email[] {
    const lowerCondition = condition.toLowerCase();
    if (lowerCondition.includes('subject contains')) {
      const searchTerm = lowerCondition.split('subject contains')[1].trim();
      return emails.filter(e => e.subject.toLowerCase().includes(searchTerm));
    }
    if (lowerCondition.includes('from')) {
      const searchTerm = lowerCondition.split('from')[1].trim();
      return emails.filter(e => 
        e.from.some(f => f.email.toLowerCase().includes(searchTerm))
      );
    }
    return [];
  }
}
</file>

<file path="tools/smartFolders.ts">
import Nylas from 'nylas';
import { EmailAI } from '../ai/emailAI';
import { SmartFoldersParams, Email, ApprovalRequiredResponse } from '../types';
interface StoredFolderRule {
  id: string;
  rules: string[];
  description?: string;
}
export class SmartFoldersTool {
  private folderRulesStore: Map<string, StoredFolderRule> = new Map();
  constructor(
    private nylas: Nylas,
    private grantId: string,
    private emailAI: EmailAI
  ) {}
  async execute(params: SmartFoldersParams): Promise<any> {
    // Check if this is an approved action execution
    if (params.approved && params.action_data) {
      return this.executeApprovedAction(params);
    }
    // Parse the natural language query to understand intent
    const query = params.query.toLowerCase();
    if (query.includes('list') || query.includes('show') || query.includes('what folders')) {
      return this.listSmartFolders();
    } else if (query.includes('create') || query.includes('make') || query.includes('set up')) {
      return this.createSmartFolder(params);
    } else if (query.includes('update') || query.includes('change') || query.includes('modify')) {
      return this.updateSmartFolder(params);
    } else if (query.includes('apply') || query.includes('organize') || query.includes('move emails')) {
      // For apply action, check if approval is needed
      return this.handleApplyAction(params);
    } else {
      // Default to create if we can't determine intent
      return this.createSmartFolder(params);
    }
  }
  private async handleApplyAction(params: SmartFoldersParams): Promise<any> {
    // First get the preview of what would be applied
    const previewResult = await this.applySmartFolder({ ...params, dry_run: true });
    // If dry_run was requested or no emails to move, return the preview
    if (params.dry_run || !previewResult.preview?.total_count) {
      return previewResult;
    }
    // Otherwise, return an approval request
    return this.createApprovalRequest(previewResult, params);
  }
  private createApprovalRequest(
    previewResult: any,
    params: SmartFoldersParams
  ): ApprovalRequiredResponse {
    return {
      needs_approval: true,
      action_type: 'apply_smart_folder',
      action_data: {
        folder_plan: previewResult,
        original_params: params
      },
      preview: {
        summary: `Apply smart folder "${previewResult.preview.folder_name}" to ${previewResult.preview.total_count} emails`,
        details: {
          folder_name: previewResult.preview.folder_name,
          total_emails: previewResult.preview.total_count,
          sample_emails: previewResult.preview.emails_to_move.slice(0, 5),
          action: 'move_to_folder'
        },
        risks: this.assessApplyRisks(previewResult)
      }
    };
  }
  private assessApplyRisks(previewResult: any): string[] {
    const risks: string[] = [];
    if (previewResult.preview.total_count > 50) {
      risks.push(`Large number of emails will be moved (${previewResult.preview.total_count})`);
    }
    risks.push('Emails will be moved from their current folders');
    return risks;
  }
  private async executeApprovedAction(params: SmartFoldersParams): Promise<any> {
    if (!params.action_data?.original_params) {
      throw new Error('Missing action data in approved action');
    }
    const { original_params } = params.action_data;
    // Execute the actual action with dry_run = false
    const executeParams = { ...original_params, dry_run: false };
    try {
      const result = await this.applySmartFolder(executeParams);
      return {
        ...result,
        approval_executed: true
      };
    } catch (error: any) {
      throw new Error(`Failed to execute approved smart folder action: ${error.message}`);
    }
  }
  private async createSmartFolder(params: SmartFoldersParams): Promise<any> {
    try {
      // Use AI to generate folder rules from the natural language query
      const generatedRules = await this.emailAI.generateSmartFolderRules(params.query);
      // Use provided name or AI-generated name
      const folderName = params.folder_name || generatedRules.name;
      // Create the folder
      const folder = await this.nylas.folders.create({
        identifier: this.grantId,
        requestBody: {
          name: folderName
        }
      });
      // Store the rules
      this.folderRulesStore.set(folderName.toLowerCase(), {
        id: folder.data.id,
        rules: generatedRules.rules,
        description: generatedRules.description
      });
      return {
        success: true,
        folder_id: folder.data.id,
        folder_name: folderName,
        rules: generatedRules.rules,
        description: generatedRules.description,
        message: `Smart folder "${folderName}" created with ${generatedRules.rules.length} rules`
      };
    } catch (error: any) {
      throw new Error(`Failed to create smart folder: ${error.message}`);
    }
  }
  private async updateSmartFolder(params: SmartFoldersParams): Promise<any> {
    // Extract folder name from query
    const query = params.query.toLowerCase();
    let folderName = params.folder_name;
    if (!folderName) {
      // Try to extract folder name from query
      const folderMatch = query.match(/folder\s+["']?([^"']+)["']?/);
      if (folderMatch) {
        folderName = folderMatch[1];
      } else {
        throw new Error('Could not determine which folder to update. Please specify the folder name.');
      }
    }
    // Find existing folder
    const folders = await this.nylas.folders.list({
      identifier: this.grantId
    });
    const existingFolder = folders.data.find(
      f => f.name.toLowerCase() === folderName!.toLowerCase()
    );
    if (!existingFolder) {
      throw new Error(`Folder "${folderName}" not found`);
    }
    // Generate updated rules based on the query
    const updatedRules = await this.emailAI.generateSmartFolderRules(
      `Update folder "${folderName}" based on: ${params.query}`
    );
    // Update stored rules
    this.folderRulesStore.set(folderName.toLowerCase(), {
      id: existingFolder.id,
      rules: updatedRules.rules,
      description: updatedRules.description
    });
    return {
      success: true,
      folder_id: existingFolder.id,
      folder_name: folderName,
      rules: updatedRules.rules,
      description: updatedRules.description,
      message: `Smart folder "${folderName}" updated successfully`
    };
  }
  private async applySmartFolder(params: SmartFoldersParams): Promise<any> {
    // Get stored folder rules
    const folderRules = await this.getStoredFolderRules();
    // Find the folder mentioned in the query
    let targetFolder: StoredFolderRule | undefined;
    let folderName: string | undefined;
    const query = params.query.toLowerCase();
    for (const [name, rule] of folderRules) {
      if (query.includes(name)) {
        targetFolder = rule;
        folderName = name;
        break;
      }
    }
    if (!targetFolder || !folderName) {
      // If no specific folder mentioned, use AI to understand the query
      const generatedRules = await this.emailAI.generateSmartFolderRules(params.query);
      if (!generatedRules || !generatedRules.name) {
        throw new Error('Could not determine which folder to apply. Please specify a folder name.');
      }
      folderName = params.folder_name || generatedRules.name;
      // Check if this folder exists
      const folders = await this.nylas.folders.list({
        identifier: this.grantId
      });
      const existingFolder = folders.data.find(
        f => f.name.toLowerCase() === folderName!.toLowerCase()
      );
      if (!existingFolder) {
        return {
          success: false,
          error: `Folder "${folderName}" not found. Please create it first.`
        };
      }
      targetFolder = {
        id: existingFolder.id,
        rules: generatedRules.rules,
        description: generatedRules.description
      };
    }
    // Find emails matching the rules
    const matchingEmails: Email[] = [];
    for (const rule of targetFolder.rules) {
      const emails = await this.findEmailsByRule(rule);
      matchingEmails.push(...emails);
    }
    // Remove duplicates
    const uniqueEmails = Array.from(
      new Map(matchingEmails.map(e => [e.id, e])).values()
    );
    if (params.dry_run) {
      return {
        success: true,
        preview: {
          folder_name: folderName,
          emails_to_move: uniqueEmails.map(e => ({
            id: e.id,
            subject: e.subject,
            from: e.from[0]?.email
          })),
          total_count: uniqueEmails.length
        }
      };
    }
    // Move emails to the folder
    let movedCount = 0;
    for (const email of uniqueEmails) {
      try {
        await this.nylas.messages.update({
          identifier: this.grantId,
          messageId: email.id,
          requestBody: {
            folders: [targetFolder.id]
          }
        });
        movedCount++;
      } catch (error) {
        console.error(`Failed to move email ${email.id}:`, error);
      }
    }
    return {
      success: true,
      emails_processed: movedCount,
      message: `Applied rules to ${movedCount} emails`
    };
  }
  private async listSmartFolders(): Promise<any> {
    const folderRules = await this.getStoredFolderRules();
    const smartFolders = Array.from(folderRules.entries()).map(([name, rule]) => ({
      name,
      folder_id: rule.id,
      rules: rule.rules,
      description: rule.description
    }));
    return {
      smart_folders: smartFolders,
      total_count: smartFolders.length
    };
  }
  private async findEmailsByRule(rule: string): Promise<Email[]> {
    const queryParams: any = {};
    // Parse simple rules
    if (rule.includes('from:')) {
      const fromMatch = rule.match(/from:([^\s]+)/);
      if (fromMatch) {
        queryParams.searchQueryNative = rule;
      }
    } else if (rule.includes('subject contains')) {
      queryParams.searchQueryNative = rule;
    } else {
      // For complex rules, use the rule as-is
      queryParams.searchQueryNative = rule;
    }
    queryParams.limit = 100;
    try {
      const messages = await this.nylas.messages.list({
        identifier: this.grantId,
        queryParams
      });
      return messages.data as Email[];
    } catch (error) {
      console.error(`Failed to find emails for rule "${rule}":`, error);
      return [];
    }
  }
  private async getStoredFolderRules(): Promise<Map<string, StoredFolderRule>> {
    // In a real implementation, this would persist to a database
    // For now, we'll try to reconstruct from folder names
    if (this.folderRulesStore.size === 0) {
      try {
        const folders = await this.nylas.folders.list({
          identifier: this.grantId
        });
        // Look for folders that seem to be smart folders
        // In production, you'd store this metadata properly
        folders.data.forEach(folder => {
          if (!folder.attributes?.includes('\\System')) {
            // Assume user-created folders might be smart folders
            this.folderRulesStore.set(folder.name.toLowerCase(), {
              id: folder.id,
              rules: [], // Would need to retrieve stored rules
              description: `Smart folder: ${folder.name}`
            });
          }
        });
      } catch (error) {
        console.error('Failed to load folder rules:', error);
      }
    }
    return this.folderRulesStore;
  }
}
</file>

<file path="types/index.ts">
// Email AI Types
export interface EmailIntent {
  intent: 'send' | 'reply' | 'forward' | 'find' | 'organize';
  recipients?: string[];
  subject?: string;
  key_points: string[];
  urgency: 'low' | 'normal' | 'high' | 'urgent';
  tone: 'professional' | 'casual' | 'friendly' | 'formal' | 'grateful';
  context_message_id?: string;
}
export interface GeneratedEmail {
  to: string[];
  cc?: string[];
  bcc?: string[];
  subject: string;
  body: string;
  in_reply_to?: string;
  tone_confirmation?: string;
}
export interface EmailAnalysis {
  email_id: string;
  importance_score: number; // 0-1
  category: 'urgent_alert' | 'client_email' | 'newsletter' | 'notification' | 'personal' | 'other';
  reason: string;
  action_required: boolean;
  suggested_folder?: string;
}
export interface ActionItem {
  task: string;
  deadline?: string;
  priority: 'low' | 'medium' | 'high';
  assigned_to?: string;
}
export interface EmailSummary {
  total_emails: number;
  important_count: number;
  requires_response: number;
  categories: Record<string, number>;
  key_senders: string[];
  urgent_items: string[];
}
// Approval System Types - Legacy (removed)
// New stateless approval response that includes all action data
export interface ApprovalRequiredResponse {
  needs_approval: true;
  action_type: 'send_email' | 'organize_inbox' | 'apply_smart_folder';
  action_data: any; // Contains all data needed to execute the action
  preview: {
    summary: string;
    details: any;
    risks?: string[];
  };
  suggested_modifications?: any;
}
// Response for when an approved action is executed
export interface ApprovedActionResponse {
  success: boolean;
  message: string;
  result?: any;
}
// Legacy approval types removed - using stateless approval flow
// Setup Types
export interface SetupInstruction {
  step: number;
  title: string;
  description: string;
  actions?: {
    type: 'link' | 'copy_field';
    label: string;
    url?: string;
    field?: string;
    validation?: string;
  }[];
  substeps?: string[];
  tips?: string[];
  common_issues?: {
    issue: string;
    solution: string;
  }[];
}
export interface SetupResponse {
  type: 'setup_instructions' | 'setup_success' | 'setup_error' | 'validation_error';
  title?: string;
  estimated_time?: string;
  steps?: SetupInstruction[];
  next_step?: {
    description: string;
    command: string;
    parameters: any;
  };
  message?: string;
  credentials_validated?: boolean;
  credentials_to_store?: {
    nylas_api_key: string;
    nylas_grant_id: string;
    email_address?: string;
    provider?: string;
  };
  error_details?: string;
  missing_fields?: string[];
}
// MCP Context Types
export interface MCPContext {
  userId: string;
  credentials?: {
    nylas_api_key?: string;
    nylas_grant_id?: string;
  };
  approvalToken?: string;
}
// Email types (simplified from Nylas)
export interface Email {
  id: string;
  subject: string;
  from: { email: string; name?: string }[];
  to?: { email: string; name?: string }[];
  body?: string;
  snippet?: string;
  date?: number;
  unread?: boolean;
  starred?: boolean;
  folders?: string[];
  thread_id?: string;
}
// Tool Parameter Types
export interface ManageEmailParams {
  action: 'send' | 'reply' | 'forward' | 'draft';
  query: string;
  context_message_id?: string;
  require_approval?: boolean;
  // Context injection fields from Juli
  user_name?: string;
  user_email?: string;
  // Fields for stateless approval flow
  approved?: boolean;
  action_data?: {
    email_content: GeneratedEmail;
    original_params: any;
  };
}
export interface FindEmailsParams {
  query: string;
  analysis_type?: 'full' | 'summary' | 'detailed' | 'action_items' | 'priority';
  limit?: number;
}
export interface OrganizeInboxParams {
  instruction: string;
  scope?: {
    folder?: string;
    date_range?: string;
    limit?: number;
  };
  dry_run?: boolean;
  // New fields for stateless approval flow
  approved?: boolean;
  action_data?: {
    organization_plan: any;
    original_params: any;
  };
}
export interface EmailInsightsParams {
  query: string;
  time_period?: string;
}
export interface SmartFoldersParams {
  query: string;
  folder_name?: string;
  dry_run?: boolean;
  // New fields for stateless approval flow
  approved?: boolean;
  action_data?: {
    folder_plan: any;
    original_params: any;
  };
}
</file>

<file path="server.ts">
#!/usr/bin/env node
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import Nylas from 'nylas';
import { OAuth2Client } from 'google-auth-library';
// Import our components
import { EmailAI } from './ai/emailAI.js';
// ApprovalManager removed - using stateless approval flow
import { SetupManager } from './setup/setupManager.js';
import { ManageEmailTool } from './tools/manageEmail.js';
import { FindEmailsTool } from './tools/findEmails.js';
import { OrganizeInboxTool } from './tools/organizeInbox.js';
import { EmailInsightsTool } from './tools/emailInsights.js';
import { SmartFoldersTool } from './tools/smartFolders.js';
// Import types
import {
  ManageEmailParams,
  FindEmailsParams,
  OrganizeInboxParams,
  EmailInsightsParams,
  SmartFoldersParams,
  SetupResponse
} from './types/index.js';
// Zod schemas for our AI-powered tools
const ManageEmailSchema = z.object({
  action: z.enum(['send', 'reply', 'forward', 'draft']).describe('Choose send for new emails, reply to respond to someone, forward to share an email, or draft to save without sending'),
  query: z.string().describe('Describe what you want in the email. Be natural! Examples: "tell John I\'ll be late to the meeting", "thank Sarah for the proposal and ask about pricing", "forward this to the team with my thoughts"'),
  context_message_id: z.string().optional().describe('Email ID if replying/forwarding (I\'ll find it if you don\'t provide it)'),
  require_approval: z.boolean().optional().default(true).describe('Show preview before sending (default: true for safety)'),
  // Context injection fields from Juli
  user_name: z.string().optional().describe('User\'s name from context injection'),
  user_email: z.string().optional().describe('User\'s email from context injection'),
  // Stateless approval fields
  approved: z.boolean().optional().describe('Whether this is an approved action execution'),
  action_data: z.object({
    email_content: z.any(),
    original_params: z.any()
  }).optional().describe('Complete action data for approved execution')
}).describe('Compose emails naturally - just tell me what you want to say and I\'ll write a professional email. Works for new emails, replies, and forwards.');
const FindEmailsSchema = z.object({
  query: z.string().describe('Describe what emails you\'re looking for in plain English. Examples: "unread emails from my boss", "invoices from last month", "anything I need to respond to today", "emails about the Q3 project"'),
  analysis_type: z.enum(['full', 'summary', 'detailed', 'action_items', 'priority']).optional().default('summary')
    .describe('How much detail you want: summary (quick overview), full (complete emails), detailed (emails + importance analysis), action_items (emails + tasks to do), priority (emails sorted by importance)'),
  limit: z.number().optional().default(20).describe('How many emails to return (default: 20)')
}).describe('Search your emails naturally and get exactly what you need - from quick summaries to detailed analysis with action items.');
const OrganizeInboxSchema = z.object({
  instruction: z.string().describe('Tell me how you want to organize your emails. Examples: "archive all newsletters older than a week", "star important emails from clients", "clean up promotional emails", "organize by project", "file all receipts"'),
  scope: z.object({
    folder: z.string().optional().default('inbox').describe('Which folder to organize (default: inbox)'),
    date_range: z.string().optional().describe('Time range like "last week" or "older than 30 days"'),
    limit: z.number().optional().default(100).describe('Max emails to process at once')
  }).optional().describe('Scope of organization'),
  dry_run: z.boolean().optional().default(true).describe('Preview what will happen before making changes (default: true for safety)'),
  // New stateless approval fields
  approved: z.boolean().optional().describe('Whether this is an approved action execution'),
  action_data: z.object({
    organization_plan: z.any(),
    original_params: z.any()
  }).optional().describe('Complete action data for approved execution')
}).describe('Clean up and organize your inbox intelligently. Tell me what you want to do and I\'ll handle the details - always with a preview first.');
const EmailInsightsSchema = z.object({
  query: z.string()
    .describe('Natural language request for email insights. Examples: "summarize my emails today", "what emails need my response?", "show me email analytics for this week", "who am I communicating with most?", "what important emails did I get this week?"'),
  time_period: z.string().optional().default('today')
    .describe('Time period in natural language like "today", "this week", "last month"')
}).describe('Get AI-powered insights and summaries about your email patterns, important items, and what needs attention');
const SmartFoldersSchema = z.object({
  query: z.string().describe('Describe what you want to do with folders. Examples: "create a folder for urgent client emails", "set up folders for each project", "make a folder for receipts and invoices", "show me my folders"'),
  folder_name: z.string().optional().describe('Name for the folder (I\'ll suggest one if you don\'t specify)'),
  dry_run: z.boolean().optional().default(true).describe('Preview the folder rules before creating (default: true)'),
  // New stateless approval fields
  approved: z.boolean().optional().describe('Whether this is an approved action execution'),
  action_data: z.object({
    folder_plan: z.any(),
    original_params: z.any()
  }).optional().describe('Complete action data for approved execution')
}).describe('Create smart folders that automatically organize emails based on your rules. Just describe what should go in the folder and I\'ll set it up.');
// Middleware to extract credentials from headers
interface UserCredentials {
  nylasGrantId?: string;
}
function extractCredentials(headers: any): UserCredentials {
  const credentials: UserCredentials = {};
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase().startsWith('x-user-credential-')) {
      const credKey = key.toLowerCase()
        .replace('x-user-credential-', '')
        .replace(/-/g, '_')
        .toUpperCase();
      switch (credKey) {
        case 'NYLAS_GRANT_ID':
          credentials.nylasGrantId = value as string;
          break;
      }
    }
  }
  return credentials;
}
// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;
const SERVICE_VERSION = '2.0.0';
// Middleware
app.use(cors());
app.use(express.json());
// Request context
interface RequestContext {
  userId?: string;
  requestId?: string;
  credentials: UserCredentials;
}
// Middleware to create request context
app.use((req, res, next) => {
  const context: RequestContext = {
    userId: req.headers['x-platform-user-id'] as string,
    requestId: req.headers['x-platform-request-id'] as string,
    credentials: extractCredentials(req.headers)
  };
  res.locals.context = context;
  next();
});
// Logger for server
const logger = {
  log: console.log,
  error: console.error,
  warn: console.warn
};
// Helper to build a Hosted Auth URL (no redirect)
function buildHostedAuthUrl(params: {
  requestBase: string;
  scope?: string;
  prompt?: string;
  loginHint?: string;
  redirectUriOverride?: string;
}): string {
  if (!NYLAS_API_KEY || !NYLAS_CLIENT_ID) {
    throw new Error('NYLAS_API_KEY and NYLAS_CLIENT_ID must be set');
  }
  const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
  const redirect = params.redirectUriOverride || `${params.requestBase}/api/nylas-email/callback`;
  const rawScope = params.scope || '';
  const scope = rawScope
    ? rawScope.split(',').map((s) => s.trim()).filter(Boolean)
    : undefined;
  const authUrl = (nylas as any).auth.urlForOAuth2({
    clientId: NYLAS_CLIENT_ID,
    redirectUri: redirect,
    ...(params.loginHint ? { loginHint: params.loginHint } : {}),
    ...(params.prompt ? { prompt: params.prompt } : {}),
    ...(scope ? { scope } : {})
  });
  return authUrl;
}
// --- Nylas Hosted Auth routes ---
// Environment-driven configuration
const NYLAS_API_KEY = process.env.NYLAS_API_KEY;
const NYLAS_CLIENT_ID = process.env.NYLAS_CLIENT_ID;
const NYLAS_CALLBACK_URI = process.env.NYLAS_CALLBACK_URI;
const NYLAS_API_URI = process.env.NYLAS_API_URI; // optional (defaults to US)
// --- A2A (Agent-to-Agent) configuration ---
const A2A_AUDIENCE = process.env.A2A_AUDIENCE || '';
const A2A_DEV_SHARED_SECRET = process.env.A2A_DEV_SHARED_SECRET || '';
const A2A_TRUSTED_ISSUERS = ['https://accounts.google.com', 'accounts.google.com'];
const oidcClient = new OAuth2Client();
async function authenticateAgent(req: express.Request): Promise<{ sub?: string; email?: string } | null> {
  const authz = req.headers['authorization'] as string | undefined;
  // Primary: OIDC Bearer token
  if (authz && authz.toLowerCase().startsWith('bearer ')) {
    const idToken = authz.slice(7).trim();
    try {
      const ticket = await oidcClient.verifyIdToken({ idToken, audience: A2A_AUDIENCE || undefined });
      const payload = ticket.getPayload();
      if (payload && (!payload.iss || A2A_TRUSTED_ISSUERS.includes(String(payload.iss)))) {
        return { sub: payload.sub, email: (payload.email as string) };
      }
    } catch (err) {
      // fall through to dev secret
    }
  }
  // Dev fallback: shared secret header
  const devSecret = req.headers['x-a2a-dev-secret'] as string | undefined;
  if (A2A_DEV_SHARED_SECRET && devSecret && devSecret === A2A_DEV_SHARED_SECRET) {
    return { sub: 'dev-agent', email: 'dev@local' };
  }
  return null;
}
function buildA2ACapabilities() {
  return [
    {
      name: 'manage_email',
      description: ManageEmailSchema.description,
      input_schema: (() => {
        const schema = zodToJsonSchema(ManageEmailSchema) as any;
        if (schema.properties) {
          schema.properties.user_name = {
            ...schema.properties.user_name,
            'x-context-injection': 'user_name'
          };
          schema.properties.user_email = {
            ...schema.properties.user_email,
            'x-context-injection': 'user_email'
          };
        }
        return schema;
      })()
    },
    { name: 'find_emails', description: FindEmailsSchema.description, input_schema: zodToJsonSchema(FindEmailsSchema) },
    { name: 'organize_inbox', description: OrganizeInboxSchema.description, input_schema: zodToJsonSchema(OrganizeInboxSchema) },
    { name: 'email_insights', description: EmailInsightsSchema.description, input_schema: zodToJsonSchema(EmailInsightsSchema) },
    { name: 'smart_folders', description: SmartFoldersSchema.description, input_schema: zodToJsonSchema(SmartFoldersSchema) }
  ];
}
function buildAgentCard(req: express.Request) {
  const baseUrl = `${req.protocol}://${req.get('host')}`;
  const authSchemes: any[] = [
    {
      type: 'oidc',
      audience: A2A_AUDIENCE || baseUrl,
      issuers: A2A_TRUSTED_ISSUERS
    }
  ];
  if (A2A_DEV_SHARED_SECRET) {
    authSchemes.push({ type: 'shared_secret', header: 'X-A2A-Dev-Secret' });
  }
  const card: any = {
    agent_id: 'inbox-mcp',
    version: SERVICE_VERSION,
    description: 'Email agent that can compose, find, organize, and analyze email. Supports approval-first execution and agent-to-agent auth.',
    auth: authSchemes.length === 1 ? authSchemes[0] : { schemes: authSchemes },
    approvals: { modes: ['stateless_preview_then_approve'] },
    context_requirements: { credentials: ['EMAIL_ACCOUNT_GRANT'] },
    capabilities: buildA2ACapabilities(),
    rpc: { endpoint: '/a2a/rpc' },
    extensions: {
      'x-juli': {
        credentials_manifest: '/.well-known/a2a-credentials.json'
      }
    }
  };
  return card;
}
// GET /nylas/auth - Redirect user to Nylas Hosted Auth
// Optional query params:
//   login_hint: prefill user email
//   prompt: customize provider selection UI (e.g., detect,select_provider)
//   scope: comma-separated scopes list
//   redirect_uri: override callback (falls back to env)
app.get('/nylas/auth', (req, res) => {
  try {
    if (!NYLAS_API_KEY || !NYLAS_CLIENT_ID || (!NYLAS_CALLBACK_URI && !req.query.redirect_uri)) {
      return res.status(500).json({
        error: 'Server is not configured for Hosted Auth. Set NYLAS_API_KEY, NYLAS_CLIENT_ID, and NYLAS_CALLBACK_URI.'
      });
    }
    const requestBase = `${req.protocol}://${req.get('host')}`;
    const authUrl = buildHostedAuthUrl({
      requestBase,
      scope: (req.query.scope as string) || '',
      prompt: (req.query.prompt as string) || undefined,
      loginHint: (req.query.login_hint as string) || undefined,
      redirectUriOverride: (req.query.redirect_uri as string) || NYLAS_CALLBACK_URI
    });
    // Default to HTTP redirect; support JSON via ?return=json
    if (req.query.return === 'json') {
      return res.json({ url: authUrl });
    }
    res.redirect(authUrl);
  } catch (error: any) {
    logger.error('Error generating Hosted Auth URL:', error);
    res.status(500).json({ error: error.message || 'Failed to generate Hosted Auth URL' });
  }
});
// GET /setup/connect-url - Return Hosted Auth URL as JSON (no redirect)
app.get('/setup/connect-url', (req, res) => {
  try {
    const requestBase = `${req.protocol}://${req.get('host')}`;
    const url = buildHostedAuthUrl({
      requestBase,
      scope: (req.query.scope as string) || '',
      prompt: (req.query.prompt as string) || undefined,
      loginHint: (req.query.login_hint as string) || undefined,
      redirectUriOverride: (req.query.redirect_uri as string) || NYLAS_CALLBACK_URI
    });
    res.json({ url });
  } catch (error: any) {
    logger.error('Error building connect URL:', error);
    res.status(500).json({ error: error.message || 'Failed to build connect URL' });
  }
});
// GET /api/nylas-email/callback - OAuth callback to exchange code for grant_id
app.get('/api/nylas-email/callback', async (req, res) => {
  try {
    if (!NYLAS_API_KEY || !NYLAS_CLIENT_ID || !NYLAS_CALLBACK_URI) {
      return res.status(500).json({
        error: 'Server is not configured for Hosted Auth. Set NYLAS_API_KEY, NYLAS_CLIENT_ID, and NYLAS_CALLBACK_URI.'
      });
    }
    const code = req.query.code as string | undefined;
    if (!code) {
      return res.status(400).json({ error: 'Missing authorization code in callback' });
    }
    const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
    // Use the exact callback URL that the user hit to avoid mismatch
    const requestBase = `${req.protocol}://${req.get('host')}`;
    const effectiveRedirectUri = `${requestBase}${req.path}`;
    // Perform code exchange
    const response = await (nylas as any).auth.exchangeCodeForToken({
      clientSecret: NYLAS_API_KEY,
      clientId: NYLAS_CLIENT_ID,
      redirectUri: effectiveRedirectUri || NYLAS_CALLBACK_URI,
      code
    });
    // Normalized output
    const grantId = response?.grantId || response?.grant_id;
    const email = response?.email || response?.data?.email;
    if (!grantId) {
      return res.status(500).json({ error: 'No grant_id returned from Nylas' });
    }
    // Return the grant so the client can store and inject it on future requests
    res.json({
      success: true,
      grant_id: grantId,
      email,
      message: 'Connected successfully. Store grant_id and start calling the email tools.'
    });
  } catch (error: any) {
    logger.error('OAuth callback error:', error);
    res.status(500).json({ error: error.message || 'Failed to complete OAuth exchange' });
  }
});
// GET /mcp/tools - List available tools
app.get('/mcp/tools', (req, res) => {
  const context: RequestContext = res.locals.context;
  const hasCredentials = !!(NYLAS_API_KEY && context.credentials.nylasGrantId);
  // Instrumentation: log credential presence for troubleshooting
  try {
    const maskedGrant = context.credentials.nylasGrantId
      ? `${context.credentials.nylasGrantId.slice(0, 8)}‚Ä¶`
      : 'none';
    console.log(
      `[mcp/tools] env.NYLAS_API_KEY: ${NYLAS_API_KEY ? 'present' : 'missing'}, header.NYLAS_GRANT_ID: ${maskedGrant}, hasCredentials: ${hasCredentials}`
    );
  } catch (_) {
    // no-op
  }
  const tools = [];
  // Only include email tools if credentials are present
  if (hasCredentials) {
    tools.push(
      {
        name: "manage_email",
        description: ManageEmailSchema.description,
        inputSchema: (() => {
          const schema = zodToJsonSchema(ManageEmailSchema) as any;
          // Add context injection annotations for Juli
          if (schema.properties) {
            schema.properties.user_name = {
              ...schema.properties.user_name,
              'x-context-injection': 'user_name'
            };
            schema.properties.user_email = {
              ...schema.properties.user_email,
              'x-context-injection': 'user_email'
            };
          }
          return schema;
        })()
      },
      {
        name: "find_emails",
        description: FindEmailsSchema.description,
        inputSchema: zodToJsonSchema(FindEmailsSchema)
      },
      {
        name: "organize_inbox",
        description: OrganizeInboxSchema.description,
        inputSchema: zodToJsonSchema(OrganizeInboxSchema)
      },
      {
        name: "email_insights",
        description: EmailInsightsSchema.description,
        inputSchema: zodToJsonSchema(EmailInsightsSchema)
      },
      {
        name: "smart_folders",
        description: SmartFoldersSchema.description,
        inputSchema: zodToJsonSchema(SmartFoldersSchema)
      }
    );
  }
  res.json({ tools });
});
// POST /mcp/tools/:toolName - Execute a tool
app.post('/mcp/tools/:toolName', async (req, res) => {
  const { toolName } = req.params;
  const { arguments: args } = req.body;
  const context: RequestContext = res.locals.context;
  // Instrumentation: log tool execution with credential presence
  try {
    const maskedGrant = context.credentials.nylasGrantId
      ? `${context.credentials.nylasGrantId.slice(0, 8)}‚Ä¶`
      : 'none';
    console.log(
      `Executing ${toolName} | env.NYLAS_API_KEY: ${NYLAS_API_KEY ? 'present' : 'missing'}, header.NYLAS_GRANT_ID: ${maskedGrant}, user: ${context.userId || 'unknown'}, reqId: ${context.requestId || 'n/a'}`
    );
  } catch (_) {
    // no-op
  }
  try {
    let result: any;
    switch (toolName) {
      case 'manage_email': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = ManageEmailSchema.parse(args) as ManageEmailParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new ManageEmailTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI,
          { userName: params.user_name, userEmail: params.user_email }
        );
        result = await tool.execute(params);
        break;
      }
      case 'find_emails': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = FindEmailsSchema.parse(args) as FindEmailsParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new FindEmailsTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      case 'organize_inbox': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = OrganizeInboxSchema.parse(args) as OrganizeInboxParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new OrganizeInboxTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      case 'email_insights': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = EmailInsightsSchema.parse(args) as EmailInsightsParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new EmailInsightsTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      case 'smart_folders': {
        if (!NYLAS_API_KEY || !context.credentials.nylasGrantId) {
          throw new Error('Missing Nylas credentials. Please connect your email account first.');
        }
        const params = SmartFoldersSchema.parse(args) as SmartFoldersParams;
        const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
        const emailAI = new EmailAI(); // Uses our server's OpenAI key
        const tool = new SmartFoldersTool(
          nylas,
          context.credentials.nylasGrantId,
          emailAI
        );
        result = await tool.execute(params);
        break;
      }
      default:
        return res.status(404).json({ error: `Unknown tool: ${toolName}` });
    }
    res.json({ result });
  } catch (error: any) {
    console.error(`Error executing ${toolName}:`, error);
    let errorMessage = error.message;
    let statusCode = 500;
    if (error instanceof z.ZodError) {
      errorMessage = `Input validation error: ${error.errors.map(e =>
        `${e.path.join('.')}: ${e.message}`
      ).join(', ')}`;
      statusCode = 400;
    } else if (error.message.includes('Missing') || error.message.includes('not connected')) {
      statusCode = 401;
    }
    res.status(statusCode).json({
      error: errorMessage,
      code: error.code || 'TOOL_EXECUTION_ERROR'
    });
  }
});
// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'inbox-mcp',
    version: SERVICE_VERSION,
    transport: 'http'
  });
});
// --- A2A routes ---
app.get('/.well-known/a2a.json', (req, res) => {
  res.json(buildAgentCard(req));
});
function buildCredentialsManifest() {
  return {
    credentials: [
      {
        key: 'EMAIL_ACCOUNT_GRANT',
        display_name: 'Email Account Grant',
        sensitive: true,
        notes: 'Opaque user grant for mailbox access; inject on every execute/approve call.',
        flows: [
          {
            type: 'hosted_auth',
            connect_url: '/setup/connect-url',
            callback: '/api/nylas-email/callback',
            provider_scopes: {
              google: [
                'openid',
                'https://www.googleapis.com/auth/userinfo.email',
                'https://www.googleapis.com/auth/userinfo.profile',
                'https://www.googleapis.com/auth/gmail.modify',
                'https://www.googleapis.com/auth/contacts',
                'https://www.googleapis.com/auth/contacts.readonly',
                'https://www.googleapis.com/auth/contacts.other.readonly'
              ],
              microsoft: [
                'Mail.ReadWrite',
                'Mail.Send',
                'Contacts.Read',
                'Contacts.Read.Shared'
              ]
            }
          }
        ]
      }
    ]
  };
}
app.get('/.well-known/a2a-credentials.json', (_req, res) => {
  res.json(buildCredentialsManifest());
});
// Removed REST A2A endpoints; JSON-RPC is the canonical transport.
// --- A2A JSON-RPC 2.0 endpoint (alignment with A2A JSON-RPC transport) ---
// Supported methods:
// - agent.card
// - agent.handshake
// - tool.execute
// - tool.approve
app.post('/a2a/rpc', async (req, res) => {
  const agent = await authenticateAgent(req);
  if (!agent) return res.status(401).json({ error: 'unauthorized_agent' });
  const handleSingle = async (rpcReq: any) => {
    const id = rpcReq.id ?? null;
    const versionOk = rpcReq.jsonrpc === '2.0';
    const method = rpcReq.method as string;
    const params = rpcReq.params || {};
    if (!versionOk || !method) {
      return { jsonrpc: '2.0', id, error: { code: -32600, message: 'Invalid Request' } };
    }
    try {
      switch (method) {
        case 'agent.card': {
          return { jsonrpc: '2.0', id, result: buildAgentCard(req) };
        }
        case 'agent.handshake': {
          return { jsonrpc: '2.0', id, result: { agent: { sub: agent.sub, email: agent.email }, card: buildAgentCard(req), server_time: new Date().toISOString() } };
        }
        case 'tool.execute': {
          const { tool, arguments: args, user_context, request_id } = params;
          const nylasGrantId = user_context?.credentials?.EMAIL_ACCOUNT_GRANT || user_context?.credentials?.NYLAS_GRANT_ID || user_context?.credentials?.nylas_grant_id;
          if (!NYLAS_API_KEY || !nylasGrantId) {
            return { jsonrpc: '2.0', id, error: { code: 401, message: 'missing_credentials', data: { hint: '/.well-known/a2a-credentials.json' } } };
          }
          const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
          const emailAI = new EmailAI();
          let result: any;
          switch (tool) {
            case 'manage_email': {
              const typed = ManageEmailSchema.parse(args) as ManageEmailParams;
              const exec = new ManageEmailTool(nylas, nylasGrantId, emailAI, { userName: typed.user_name, userEmail: typed.user_email });
              result = await exec.execute(typed);
              break;
            }
            case 'find_emails': {
              const typed = FindEmailsSchema.parse(args) as FindEmailsParams;
              const exec = new FindEmailsTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            case 'organize_inbox': {
              const typed = OrganizeInboxSchema.parse(args) as OrganizeInboxParams;
              const exec = new OrganizeInboxTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            case 'email_insights': {
              const typed = EmailInsightsSchema.parse(args) as EmailInsightsParams;
              const exec = new EmailInsightsTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            case 'smart_folders': {
              const typed = SmartFoldersSchema.parse(args) as SmartFoldersParams;
              const exec = new SmartFoldersTool(nylas, nylasGrantId, emailAI);
              result = await exec.execute(typed);
              break;
            }
            default:
              return { jsonrpc: '2.0', id, error: { code: 404, message: 'unknown_tool', data: { tool } } };
          }
          return { jsonrpc: '2.0', id, result: { request_id, result } };
        }
        case 'tool.approve': {
          const { tool, original_arguments, action_data, user_context, request_id } = params;
          const nylasGrantId = user_context?.credentials?.EMAIL_ACCOUNT_GRANT || user_context?.credentials?.NYLAS_GRANT_ID || user_context?.credentials?.nylas_grant_id;
          if (!NYLAS_API_KEY || !nylasGrantId) {
            return { jsonrpc: '2.0', id, error: { code: 401, message: 'missing_credentials', data: { hint: '/.well-known/a2a-credentials.json' } } };
          }
          if (tool !== 'manage_email') {
            return { jsonrpc: '2.0', id, error: { code: 400, message: 'approval_not_supported_for_tool', data: { tool } } };
          }
          const nylas = new Nylas({ apiKey: NYLAS_API_KEY, apiUri: NYLAS_API_URI });
          const emailAI = new EmailAI();
          const typed = ManageEmailSchema.parse({ ...(original_arguments || {}), approved: true, action_data });
          const exec = new ManageEmailTool(nylas, nylasGrantId, emailAI, { userName: typed.user_name, userEmail: typed.user_email });
          const result = await exec.execute(typed);
          return { jsonrpc: '2.0', id, result: { request_id, result } };
        }
        default:
          return { jsonrpc: '2.0', id, error: { code: -32601, message: 'Method not found' } };
      }
    } catch (err: any) {
      if (err instanceof z.ZodError) {
        return { jsonrpc: '2.0', id, error: { code: -32602, message: 'Invalid params', data: err.errors } };
      }
      return { jsonrpc: '2.0', id, error: { code: -32000, message: err?.message || 'Internal error' } };
    }
  };
  const body = req.body;
  if (Array.isArray(body)) {
    const results = await Promise.all(body.map(handleSingle));
    return res.json(results);
  } else {
    const result = await handleSingle(body);
    return res.json(result);
  }
});
// GET /mcp/needs-setup - Check if setup is required
app.get('/mcp/needs-setup', (req, res) => {
  const context: RequestContext = res.locals.context;
  const hasCredentials = !!(NYLAS_API_KEY && context.credentials.nylasGrantId);
  const requestBase = `${req.protocol}://${req.get('host')}`;
  const defaultConnectUrl = `${requestBase}/setup/connect-url`;
  res.json({
    needs_setup: !hasCredentials,
    has_credentials: hasCredentials,
    setup_url: '/setup/instructions',
    connect_url: defaultConnectUrl
  });
});
// Setup endpoints - separate from MCP tools
app.post('/setup/validate', async (req, res) => {
  try {
    const { nylas_api_key, nylas_grant_id } = req.body;
    if (!nylas_api_key || !nylas_grant_id) {
      return res.status(400).json({
        success: false,
        error: 'Missing required credentials: nylas_api_key and nylas_grant_id'
      });
    }
    // Validate credentials using SetupManager
    const setupManager = new SetupManager();
    const result = await setupManager.validateCredentials({
      nylas_api_key,
      nylas_grant_id
    });
    res.json(result);
  } catch (error: any) {
    logger.error('Setup validation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
app.get('/setup/instructions', (req, res) => {
  res.json({
    type: 'setup_instructions',
    steps: [
      {
        step: 1,
        title: "Create Your Free Nylas Account",
        description: "Nylas provides 5 free email connections - perfect for personal use!",
        action: {
          type: "link",
          label: "Open Nylas Signup",
          url: "https://dashboard-v3.nylas.com/register?utm_source=juli"
        }
      },
      {
        step: 2,
        title: "Get Your API Key",
        description: "After signing in, find your API key in the dashboard",
        details: "Look for 'API Keys' in the left sidebar. The key starts with 'nyk_'"
      },
      {
        step: 3,
        title: "Connect Your Email Account",
        description: "Add your email account to Nylas",
        details: [
          "Click 'Grants' in the sidebar",
          "Click 'Add Test Grant' button",
          "Choose your email provider",
          "Authorize Nylas to access your email",
          "Copy the Grant ID that appears"
        ]
      }
    ],
    next_action: {
      description: "Once you have both credentials, validate them",
      endpoint: "POST /setup/validate",
      body: {
        nylas_api_key: "your_key_here",
        nylas_grant_id: "your_grant_id_here"
      }
    },
    documentation: "https://developer.nylas.com/docs/v3/"
  });
});
// Start server
app.listen(PORT, () => {
  console.log(`Inbox MCP HTTP server running on port ${PORT}`);
  console.log(`Available endpoints:`);
  console.log(`  GET  /health - Health check`);
  console.log(`  GET  /mcp/needs-setup - Check if setup is required`);
  console.log(`  GET  /mcp/tools - List available tools`);
  console.log(`  POST /mcp/tools/:toolName - Execute a tool`);
  console.log(`  GET  /setup/instructions - Get setup instructions`);
  console.log(`  POST /setup/validate - Validate Nylas credentials`);
});
</file>

<file path="util.ts">
// Utility functions for the Nylas MCP server
import TurndownService from 'turndown';
import sanitizeHtml from 'sanitize-html';
// Configure a single Turndown service instance for email bodies
const turndownService = new TurndownService({
    headingStyle: 'atx',
    codeBlockStyle: 'fenced',
    bulletListMarker: '-',
    linkStyle: 'inlined',
    linkReferenceStyle: 'full'
});
/**
 * Converts HTML to Markdown suitable for LLM consumption.
 * @param html Raw HTML string
 * @returns Clean Markdown string
 */
export function htmlToMarkdown(html: string): string {
    // Remove comments, styles, scripts, meta, head, and any <img> tags (often trackers)
    const cleaned = sanitizeHtml(html, {
        allowedTags: [
            'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
            'blockquote', 'p', 'a', 'ul', 'ol', 'li',
            'b', 'strong', 'i', 'em', 'code', 'pre', 'br'
        ],
        allowedAttributes: {
            a: ['href', 'title', 'name', 'target']
        },
        allowComments: false,
        // Drop empty <a> produced by tracking pixels
        exclusiveFilter: frame => frame.tag === 'a' && !frame.text.trim()
    });
    return turndownService.turndown(cleaned);
}
export function encodeNative(q: string) {
    return encodeURIComponent(q.trim());
}
/**
 * Validates an email address format using a basic regex pattern
 * @param email The email address to validate
 * @returns boolean indicating if the email format is valid
 */
export function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}
/**
 * Formats a date object or timestamp into a human-readable string
 * @param date Date object or Unix timestamp (in seconds)
 * @returns Formatted date string
 */
export function formatDate(date: Date | number): string {
    if (typeof date === 'number') {
        // Convert Unix timestamp (seconds) to milliseconds
        date = new Date(date * 1000);
    }
    return date.toLocaleString();
}
/**
 * Truncates a string to a specified length and adds ellipsis if needed
 * @param str String to truncate
 * @param maxLength Maximum length before truncation
 * @returns Truncated string with ellipsis if needed
 */
export function truncateString(str: string, maxLength: number = 100): string {
    if (!str || str.length <= maxLength) return str;
    return str.substring(0, maxLength) + '...';
}
// Removed htmlToText function - rely on SDK for plain text body
/**
 * Safely parses JSON with error handling
 * @param jsonString JSON string to parse
 * @param defaultValue Default value to return if parsing fails
 * @returns Parsed object or default value
 */
export function safeJsonParse(jsonString: string, defaultValue: any = {}): any {
    try {
        return JSON.parse(jsonString);
    } catch (error) {
        return defaultValue;
    }
}
/**
 * Sleeps for the specified number of milliseconds
 * @param ms Milliseconds to sleep
 * @returns Promise that resolves after the specified time
 */
export function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}
/**
 * Retries a function with exponential backoff
 * @param fn Function to retry
 * @param maxRetries Maximum number of retry attempts
 * @param baseDelay Base delay in milliseconds
 * @returns Promise resolving to the function result
 */
export async function retryWithBackoff<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    baseDelay: number = 300
): Promise<T> {
    let lastError: any;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            // Add check for non-retryable errors (e.g., 4xx client errors except 429)
            // NylasApiError might have a statusCode property
            const statusCode = (error as any)?.statusCode;
            if (statusCode && statusCode >= 400 && statusCode < 500 && statusCode !== 429) {
                console.warn(`Attempt ${attempt + 1}: Received non-retryable status code ${statusCode}. Aborting retries.`);
                throw lastError; // Don't retry client errors (except rate limits)
            }
            if (attempt === maxRetries - 1) {
                console.warn(`Attempt ${attempt + 1} failed. Max retries reached.`);
                break; // Exit loop after last attempt fails
            }
            const delay = baseDelay * Math.pow(2, attempt);
            const jitter = delay * 0.2 * (Math.random() - 0.5); // Add +/- 10% jitter
            const waitTime = Math.max(0, Math.round(delay + jitter));
            console.warn(`Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms... Error: ${lastError.message}`);
            await sleep(waitTime);
        }
    }
    throw lastError;
}
export function escapeXml(text: string | null | undefined): string {
    if (!text) return "";
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
}
export function messageToXml(msg: any): string {
    const id = escapeXml(msg.id);
    const subject = escapeXml(msg.subject);
    const fromObj = msg.from?.[0] ?? {};
    const sender = escapeXml(
        fromObj.name ? `${fromObj.name} &lt;${fromObj.email}&gt;` : fromObj.email ?? ""
    );
    const date = msg.date ? new Date(msg.date * 1000).toUTCString() : "";
    const snippet = escapeXml(msg.snippet);
    return [
        `<email id="${id}">`,
        `  <subject>${subject}</subject>`,
        `  <sender>${sender}</sender>`,
        `  <date>${date}</date>`,
        `  <snippet>${snippet}</snippet>`,
        `</email>`
    ].join("\n");
}
</file>

</files>
